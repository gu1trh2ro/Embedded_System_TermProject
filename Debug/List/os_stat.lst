###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_stat.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3BFA.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_stat.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_stat.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_stat.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_stat.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                           STATISTICS MODULE
     20          *
     21          * File    : os_stat.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_stat__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_STAT_TASK_EN > 0u)
     35          
     36          /*
     37          ************************************************************************************************************************
     38          *                                                   RESET STATISTICS
     39          *
     40          * Description: This function is called by your application to reset the statistics.
     41          *
     42          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
     43          *
     44          *                             OS_ERR_NONE            The call succeeded
     45          *
     46          * Returns    : none
     47          *
     48          * Note(s)    : none
     49          ************************************************************************************************************************
     50          */
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void  OSStatReset (OS_ERR  *p_err)
     53          {
   \                     OSStatReset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     54          #if (OS_CFG_DBG_EN > 0u)
     55              OS_TCB      *p_tcb;
     56          #if (OS_MSG_EN > 0u)
     57              OS_MSG_Q    *p_msg_q;
     58          #endif
     59          #if (OS_CFG_Q_EN > 0u)
     60              OS_Q        *p_q;
     61          #endif
     62          #endif
     63              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
     64          
     65          
     66          
     67          #ifdef OS_SAFETY_CRITICAL
     68              if (p_err == (OS_ERR *)0) {
     69                  OS_SAFETY_CRITICAL_EXCEPTION();
     70                  return;
     71              }
     72          #endif
     73          
     74              CPU_CRITICAL_ENTER();
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
     75          #if (OS_CFG_STAT_TASK_EN > 0u)
     76              OSStatTaskCPUUsageMax = 0u;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x....             LDR.N    R2,??DataTable3
   \   00000010   0x8011             STRH     R1,[R2, #+0]
     77          #if (OS_CFG_TS_EN > 0u)
     78              OSStatTaskTimeMax     = 0u;
     79          #endif
     80          #endif
     81          
     82          #if (OS_CFG_TS_EN > 0u) && (OS_CFG_TICK_EN > 0u)
     83              OSTickTime            = 0u;
     84              OSTickTimeMax         = 0u;
     85          #endif
     86          
     87          #if (OS_CFG_TMR_EN > 0u)
     88          #if (OS_CFG_TS_EN > 0u)
     89              OSTmrTaskTime         = 0u;
     90              OSTmrTaskTimeMax      = 0u;
     91          #endif
     92          #endif
     93          
     94          #ifdef CPU_CFG_INT_DIS_MEAS_EN
     95          #if (OS_CFG_TS_EN > 0u)
     96              OSIntDisTimeMax       = 0u;                                 /* Reset the maximum interrupt disable time             */
     97              CPU_StatReset();                                            /* Reset CPU-specific performance monitors.             */
     98          #endif
     99          #endif
    100          
    101          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
    102              OSSchedLockTimeMax    = 0u;                                 /* Reset the maximum scheduler lock time                */
    103          #endif
    104          
    105          #if ((OS_MSG_EN > 0u) && (OS_CFG_DBG_EN > 0u))
    106              OSMsgPool.NbrUsedMax  = 0u;
    107          #endif
    108              CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_SR_Restore
    109          
    110          #if (OS_CFG_DBG_EN > 0u)
    111              CPU_CRITICAL_ENTER();
    112              p_tcb = OSTaskDbgListPtr;
    113              CPU_CRITICAL_EXIT();
    114              while (p_tcb != (OS_TCB *)0) {                              /* Reset per-Task statistics                            */
    115                  CPU_CRITICAL_ENTER();
    116          
    117          #ifdef CPU_CFG_INT_DIS_MEAS_EN
    118                  p_tcb->IntDisTimeMax    = 0u;
    119          #endif
    120          
    121          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
    122                  p_tcb->SchedLockTimeMax = 0u;
    123          #endif
    124          
    125          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    126          #if (OS_CFG_TASK_Q_EN > 0u)
    127                  p_tcb->MsgQPendTimeMax  = 0u;
    128          #endif
    129                  p_tcb->SemPendTimeMax   = 0u;
    130                  p_tcb->CtxSwCtr         = 0u;
    131                  p_tcb->CPUUsage         = 0u;
    132                  p_tcb->CPUUsageMax      = 0u;
    133                  p_tcb->CyclesTotal      = 0u;
    134                  p_tcb->CyclesTotalPrev  = 0u;
    135          #if (OS_CFG_TS_EN > 0u)
    136                  p_tcb->CyclesStart      = OS_TS_GET();
    137          #endif
    138          #endif
    139          
    140          #if (OS_CFG_TASK_Q_EN > 0u)
    141                  p_msg_q                 = &p_tcb->MsgQ;
    142                  p_msg_q->NbrEntriesMax  = 0u;
    143          #endif
    144                  p_tcb                   = p_tcb->DbgNextPtr;
    145                  CPU_CRITICAL_EXIT();
    146              }
    147          #endif
    148          
    149          #if (OS_CFG_Q_EN > 0u) && (OS_CFG_DBG_EN > 0u)
    150              CPU_CRITICAL_ENTER();
    151              p_q = OSQDbgListPtr;
    152              CPU_CRITICAL_EXIT();
    153              while (p_q != (OS_Q *)0) {                                  /* Reset message queues statistics                      */
    154                  CPU_CRITICAL_ENTER();
    155                  p_msg_q                = &p_q->MsgQ;
    156                  p_msg_q->NbrEntriesMax = 0u;
    157                  p_q                    = p_q->DbgNextPtr;
    158                  CPU_CRITICAL_EXIT();
    159              }
    160          #endif
    161          
    162          
    163             *p_err = OS_ERR_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    164          }
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    165          
    166          
    167          /*
    168          ************************************************************************************************************************
    169          *                                                DETERMINE THE CPU CAPACITY
    170          *
    171          * Description: This function is called by your application to establish CPU usage by first determining how high a 32-bit
    172          *              counter would count to in 1/10 second if no other tasks were to execute during that time.  CPU usage is
    173          *              then determined by a low priority task which keeps track of this 32-bit counter every second but this
    174          *              time, with other tasks running.  CPU usage is determined by:
    175          *
    176          *                                             OS_Stat_IdleCtr
    177          *                 CPU Usage (%) = 100 * (1 - ------------------)
    178          *                                            OS_Stat_IdleCtrMax
    179          *
    180          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    181          *
    182          *                             OS_ERR_NONE              The call was successful
    183          *                             OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    184          *
    185          * Returns    : none
    186          *
    187          * Note(s)    : none
    188          ************************************************************************************************************************
    189          */
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void  OSStatTaskCPUUsageInit (OS_ERR  *p_err)
    192          {
   \                     OSStatTaskCPUUsageInit: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    193              OS_ERR   err;
    194              OS_TICK  dly;
    195              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    196          
    197          
    198              err = OS_ERR_NONE;                                          /* Initialize err explicitly for static analysis.       */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    199          
    200          #ifdef OS_SAFETY_CRITICAL
    201              if (p_err == (OS_ERR *)0) {
    202                  OS_SAFETY_CRITICAL_EXCEPTION();
    203                  return;
    204              }
    205          #endif
    206          
    207          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    208              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   0000000C   0x....             LDR.N    R0,??DataTable3_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD003             BEQ.N    ??OSStatTaskCPUUsageInit_0
    209                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000014   0xF645 0x6089      MOVW     R0,#+24201
   \   00000018   0x8020             STRH     R0,[R4, #+0]
    210                  return;
   \   0000001A   0xE052             B.N      ??OSStatTaskCPUUsageInit_1
    211              }
    212          #endif
    213          
    214          #if ((OS_CFG_TMR_EN > 0u) && (OS_CFG_TASK_SUSPEND_EN > 0u))
    215              OSTaskSuspend(&OSTmrTaskTCB, &err);
   \                     ??OSStatTaskCPUUsageInit_0: (+1)
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x....             LDR.N    R0,??DataTable3_2
   \   00000020   0x.... 0x....      BL       OSTaskSuspend
    216              if (err != OS_ERR_NONE) {
   \   00000024   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD003             BEQ.N    ??OSStatTaskCPUUsageInit_2
    217                 *p_err = err;
   \   0000002C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000030   0x8020             STRH     R0,[R4, #+0]
    218                  return;
   \   00000032   0xE046             B.N      ??OSStatTaskCPUUsageInit_1
    219              }
    220          #endif
    221          
    222              OSTimeDly(2u,                                               /* Synchronize with clock tick                          */
    223                        (OS_OPT  )OS_OPT_TIME_DLY,
    224                        (OS_ERR *)&err);
   \                     ??OSStatTaskCPUUsageInit_2: (+1)
   \   00000034   0x466A             MOV      R2,SP
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x.... 0x....      BL       OSTimeDly
    225              if (err != OS_ERR_NONE) {
   \   0000003E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??OSStatTaskCPUUsageInit_3
    226                 *p_err = err;
   \   00000046   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000004A   0x8020             STRH     R0,[R4, #+0]
    227                  return;
   \   0000004C   0xE039             B.N      ??OSStatTaskCPUUsageInit_1
    228              }
    229              CPU_CRITICAL_ENTER();
   \                     ??OSStatTaskCPUUsageInit_3: (+1)
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
    230              OSStatTaskCtr = 0u;                                         /* Clear idle counter                                   */
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x....             LDR.N    R2,??DataTable3_3
   \   00000058   0x6011             STR      R1,[R2, #+0]
    231              CPU_CRITICAL_EXIT();
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    232          
    233              dly = 0u;
   \   0000005E   0x2000             MOVS     R0,#+0
    234              if (OSCfg_TickRate_Hz > OSCfg_StatTaskRate_Hz) {
   \   00000060   0x....             LDR.N    R1,??DataTable3_4
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x....             LDR.N    R2,??DataTable3_5
   \   00000066   0x6812             LDR      R2,[R2, #+0]
   \   00000068   0x4291             CMP      R1,R2
   \   0000006A   0xD205             BCS.N    ??OSStatTaskCPUUsageInit_4
    235                  dly = (OS_TICK)(OSCfg_TickRate_Hz / OSCfg_StatTaskRate_Hz);
   \   0000006C   0x....             LDR.N    R0,??DataTable3_5
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x....             LDR.N    R1,??DataTable3_4
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    236              }
    237              if (dly == 0u) {
   \                     ??OSStatTaskCPUUsageInit_4: (+1)
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD104             BNE.N    ??OSStatTaskCPUUsageInit_5
    238                  dly =  (OSCfg_TickRate_Hz / 10u);
   \   0000007C   0x....             LDR.N    R0,??DataTable3_5
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x210A             MOVS     R1,#+10
   \   00000082   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    239              }
    240          
    241              OSTimeDly(dly,                                              /* Determine MAX. idle counter value                    */
    242                        OS_OPT_TIME_DLY,
    243                        &err);
   \                     ??OSStatTaskCPUUsageInit_5: (+1)
   \   00000086   0x466A             MOV      R2,SP
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x.... 0x....      BL       OSTimeDly
    244          
    245          #if ((OS_CFG_TMR_EN > 0u) && (OS_CFG_TASK_SUSPEND_EN > 0u))
    246              OSTaskResume(&OSTmrTaskTCB, &err);
   \   0000008E   0x4669             MOV      R1,SP
   \   00000090   0x....             LDR.N    R0,??DataTable3_2
   \   00000092   0x.... 0x....      BL       OSTaskResume
    247              if (err != OS_ERR_NONE) {
   \   00000096   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD003             BEQ.N    ??OSStatTaskCPUUsageInit_6
    248                 *p_err = err;
   \   0000009E   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000A2   0x8020             STRH     R0,[R4, #+0]
    249                  return;
   \   000000A4   0xE00D             B.N      ??OSStatTaskCPUUsageInit_1
    250              }
    251          #endif
    252          
    253              CPU_CRITICAL_ENTER();
   \                     ??OSStatTaskCPUUsageInit_6: (+1)
   \   000000A6   0x2040             MOVS     R0,#+64
   \   000000A8   0x.... 0x....      BL       CPU_SR_Save
    254          #if (OS_CFG_TS_EN > 0u)
    255              OSStatTaskTimeMax = 0u;
    256          #endif
    257          
    258              OSStatTaskCtrMax  = OSStatTaskCtr;                          /* Store maximum idle counter count                     */
   \   000000AC   0x....             LDR.N    R1,??DataTable3_3
   \   000000AE   0x6809             LDR      R1,[R1, #+0]
   \   000000B0   0x....             LDR.N    R2,??DataTable3_6
   \   000000B2   0x6011             STR      R1,[R2, #+0]
    259              OSStatTaskRdy     = OS_STATE_RDY;
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0x....             LDR.N    R2,??DataTable3_7
   \   000000B8   0x7011             STRB     R1,[R2, #+0]
    260              CPU_CRITICAL_EXIT();
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    261             *p_err             = OS_ERR_NONE;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x8020             STRH     R0,[R4, #+0]
    262          }
   \                     ??OSStatTaskCPUUsageInit_1: (+1)
   \   000000C2   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    263          
    264          
    265          /*
    266          ************************************************************************************************************************
    267          *                                                    STATISTICS TASK
    268          *
    269          * Description: This task is internal to uC/OS-III and is used to compute some statistics about the multitasking
    270          *              environment.  Specifically, OS_StatTask() computes the CPU usage.  CPU usage is determined by:
    271          *
    272          *                                                   OSStatTaskCtr
    273          *                 OSStatTaskCPUUsage = 100 * (1 - ------------------)     (units are in %)
    274          *                                                  OSStatTaskCtrMax
    275          *
    276          * Arguments  : p_arg     this pointer is not used at this time.
    277          *
    278          * Returns    : none
    279          *
    280          * Note(s)    : 1) This task runs at a priority level higher than the idle task.
    281          *
    282          *              2) You can disable this task by setting the configuration #define OS_CFG_STAT_TASK_EN to 0.
    283          *
    284          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the maximum value
    285          *                 for the idle counter.
    286          *
    287          *              4) This function is INTERNAL to uC/OS-III and your application should not call it.
    288          ************************************************************************************************************************
    289          */
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void  OS_StatTask (void  *p_arg)
    292          {
   \                     OS_StatTask: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    293          #if (OS_CFG_DBG_EN > 0u)
    294          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    295              OS_CPU_USAGE usage;
    296              OS_CYCLES    cycles_total;
    297              OS_CYCLES    cycles_div;
    298              OS_CYCLES    cycles_mult;
    299              OS_CYCLES    cycles_max;
    300          #endif
    301              OS_TCB      *p_tcb;
    302          #endif
    303              OS_TICK      ctr_max;
    304              OS_TICK      ctr_mult;
    305              OS_TICK      ctr_div;
    306              OS_ERR       err;
    307              OS_TICK      dly;
    308          #if (OS_CFG_TS_EN > 0u)
    309              CPU_TS       ts_start;
    310          #endif
    311          #if (OS_CFG_STAT_TASK_STK_CHK_EN > 0u) && (OS_CFG_ISR_STK_SIZE > 0u)
    312              CPU_STK     *p_stk;
    313              CPU_INT32U   free_stk;
    314              CPU_INT32U   size_stk;
    315          #endif
    316              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    317          
    318          
    319              (void)p_arg;                                                /* Prevent compiler warning for not using 'p_arg'       */
   \   00000004   0xE006             B.N      ??OS_StatTask_0
    320          
    321              while (OSStatTaskRdy != OS_TRUE) {
    322                  OSTimeDly(2u * OSCfg_StatTaskRate_Hz,                   /* Wait until statistic task is ready                   */
    323                            OS_OPT_TIME_DLY,
    324                            &err);
   \                     ??OS_StatTask_1: (+1)
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x....             LDR.N    R0,??DataTable3_4
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0040             LSLS     R0,R0,#+1
   \   00000010   0x.... 0x....      BL       OSTimeDly
    325              }
   \                     ??OS_StatTask_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable3_7
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD1F4             BNE.N    ??OS_StatTask_1
    326              OSStatReset(&err);                                          /* Reset statistics                                     */
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       OSStatReset
    327          
    328              dly = (OS_TICK)0;                                           /* Compute statistic task sleep delay                   */
   \   00000022   0x2400             MOVS     R4,#+0
    329              if (OSCfg_TickRate_Hz > OSCfg_StatTaskRate_Hz) {
   \   00000024   0x....             LDR.N    R0,??DataTable3_4
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x....             LDR.N    R1,??DataTable3_5
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD205             BCS.N    ??OS_StatTask_2
    330                  dly = (OSCfg_TickRate_Hz / OSCfg_StatTaskRate_Hz);
   \   00000030   0x....             LDR.N    R0,??DataTable3_5
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x....             LDR.N    R1,??DataTable3_4
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0xFBB0 0xF4F1      UDIV     R4,R0,R1
    331              }
    332              if (dly == 0u) {
   \                     ??OS_StatTask_2: (+1)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD122             BNE.N    ??OS_StatTask_3
    333                  dly =  (OSCfg_TickRate_Hz / 10u);
   \   00000040   0x....             LDR.N    R0,??DataTable3_5
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0xFBB0 0xF4F1      UDIV     R4,R0,R1
   \   0000004A   0xE01C             B.N      ??OS_StatTask_3
    334              }
    335          
    336              for (;;) {
    337          #if (OS_CFG_TS_EN > 0u)
    338                  ts_start        = OS_TS_GET();
    339          #ifdef  CPU_CFG_INT_DIS_MEAS_EN
    340                  OSIntDisTimeMax = CPU_IntDisMeasMaxGet();
    341          #endif
    342          #endif
    343          
    344                  CPU_CRITICAL_ENTER();                                   /* ---------------- OVERALL CPU USAGE ----------------- */
    345                  OSStatTaskCtrRun   = OSStatTaskCtr;                     /* Obtain the of the stat counter for the past .1 second*/
    346                  OSStatTaskCtr      = 0u;                                /* Reset the stat counter for the next .1 second        */
    347                  CPU_CRITICAL_EXIT();
    348          
    349                  if (OSStatTaskCtrMax > OSStatTaskCtrRun) {              /* Compute CPU Usage with best resolution               */
    350                      if (OSStatTaskCtrMax < 400000u) {                   /* 1 to       400,000                                   */
    351                          ctr_mult = 10000u;
    352                          ctr_div  =     1u;
    353                      } else if (OSStatTaskCtrMax <   4000000u) {         /* 400,000 to     4,000,000                             */
    354                          ctr_mult =  1000u;
    355                          ctr_div  =    10u;
    356                      } else if (OSStatTaskCtrMax <  40000000u) {         /* 4,000,000 to    40,000,000                           */
    357                          ctr_mult =   100u;
    358                          ctr_div  =   100u;
    359                      } else if (OSStatTaskCtrMax < 400000000u) {         /* 40,000,000 to   400,000,000                          */
    360                          ctr_mult =    10u;
    361                          ctr_div  =  1000u;
    362                      } else {                                            /* 400,000,000 and up                                   */
    363                          ctr_mult =     1u;
    364                          ctr_div  = 10000u;
    365                      }
    366                      ctr_max            = OSStatTaskCtrMax / ctr_div;
    367                      OSStatTaskCPUUsage = (OS_CPU_USAGE)((OS_TICK)10000u - ((ctr_mult * OSStatTaskCtrRun) / ctr_max));
    368                      if (OSStatTaskCPUUsageMax < OSStatTaskCPUUsage) {
    369                          OSStatTaskCPUUsageMax = OSStatTaskCPUUsage;
    370                      }
    371                  } else {
    372                      OSStatTaskCPUUsage = 0u;
    373                  }
    374          
    375                  OSStatTaskHook();                                       /* Invoke user definable hook                           */
    376          
    377          
    378          #if (OS_CFG_DBG_EN > 0u)
    379          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    380                  cycles_total = 0u;
    381          
    382                  CPU_CRITICAL_ENTER();
    383                  p_tcb = OSTaskDbgListPtr;
    384                  CPU_CRITICAL_EXIT();
    385                  while (p_tcb != (OS_TCB *)0) {                          /* ---------------- TOTAL CYCLES COUNT ---------------- */
    386                      CPU_CRITICAL_ENTER();
    387                      p_tcb->CyclesTotalPrev = p_tcb->CyclesTotal;        /* Save accumulated # cycles into a temp variable       */
    388                      p_tcb->CyclesTotal     = 0u;                        /* Reset total cycles for task for next run             */
    389                      CPU_CRITICAL_EXIT();
    390          
    391                      cycles_total          += p_tcb->CyclesTotalPrev;    /* Perform sum of all task # cycles                     */
    392          
    393                      CPU_CRITICAL_ENTER();
    394                      p_tcb                  = p_tcb->DbgNextPtr;
    395                      CPU_CRITICAL_EXIT();
    396                  }
    397          #endif
    398          
    399          
    400          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    401                                                                          /* ------------ INDIVIDUAL TASK CPU USAGE ------------- */
    402                  if (cycles_total > 0u) {                                /* 'cycles_total' scaling ...                           */
    403                      if (cycles_total < 400000u) {                       /* 1 to       400,000                                   */
    404                          cycles_mult = 10000u;
    405                          cycles_div  =     1u;
    406                      } else if (cycles_total <   4000000u) {             /* 400,000 to     4,000,000                             */
    407                          cycles_mult =  1000u;
    408                          cycles_div  =    10u;
    409                      } else if (cycles_total <  40000000u) {             /* 4,000,000 to    40,000,000                           */
    410                          cycles_mult =   100u;
    411                          cycles_div  =   100u;
    412                      } else if (cycles_total < 400000000u) {             /* 40,000,000 to   400,000,000                          */
    413                          cycles_mult =    10u;
    414                          cycles_div  =  1000u;
    415                      } else {                                            /* 400,000,000 and up                                   */
    416                          cycles_mult =     1u;
    417                          cycles_div  = 10000u;
    418                      }
    419                      cycles_max  = cycles_total / cycles_div;
    420                  } else {
    421                      cycles_mult = 0u;
    422                      cycles_max  = 1u;
    423                  }
    424          #endif
    425                  CPU_CRITICAL_ENTER();
    426                  p_tcb = OSTaskDbgListPtr;
    427                  CPU_CRITICAL_EXIT();
    428                  while (p_tcb != (OS_TCB *)0) {
    429          #if (OS_CFG_TASK_PROFILE_EN > 0u)                               /* Compute execution time of each task                  */
    430                      usage = (OS_CPU_USAGE)(cycles_mult * p_tcb->CyclesTotalPrev / cycles_max);
    431                      if (usage > 10000u) {
    432                          usage = 10000u;
    433                      }
    434                      p_tcb->CPUUsage = usage;
    435                      if (p_tcb->CPUUsageMax < usage) {                   /* Detect peak CPU usage                                */
    436                          p_tcb->CPUUsageMax = usage;
    437                      }
    438          #endif
    439          
    440          #if (OS_CFG_STAT_TASK_STK_CHK_EN > 0u)
    441                      OSTaskStkChk( p_tcb,                                /* Compute stack usage of active tasks only             */
    442                                   &p_tcb->StkFree,
    443                                   &p_tcb->StkUsed,
    444                                   &err);
    445          #endif
    446          
    447                      CPU_CRITICAL_ENTER();
    448                      p_tcb = p_tcb->DbgNextPtr;
    449                      CPU_CRITICAL_EXIT();
    450                  }
    451          #endif
    452          
    453                                                                          /*------------------ Check ISR Stack -------------------*/
    454          #if (OS_CFG_STAT_TASK_STK_CHK_EN > 0u) && (OS_CFG_ISR_STK_SIZE > 0u)
    455                  free_stk  = 0u;
    456          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    457                  p_stk     = OSCfg_ISRStkBasePtr;                        /*   Start at the lowest memory and go up               */
    458          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
    459                  p_stk    += OS_CFG_TASK_STK_REDZONE_DEPTH;
    460                  size_stk  = OSCfg_ISRStkSize - OS_CFG_TASK_STK_REDZONE_DEPTH;
    461          #else
    462                  size_stk  = OSCfg_ISRStkSize;
    463          #endif
    464                  while ((*p_stk == 0u) && (free_stk < size_stk)) {       /*   Compute the number of zero entries on the stk      */
    465                      p_stk++;
   \                     ??OS_StatTask_4: (+1)
   \   0000004C   0x1D09             ADDS     R1,R1,#+4
    466                      free_stk++;
   \   0000004E   0x1C52             ADDS     R2,R2,#+1
    467                  }
   \                     ??OS_StatTask_5: (+1)
   \   00000050   0x6808             LDR      R0,[R1, #+0]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD101             BNE.N    ??OS_StatTask_6
   \   00000056   0x429A             CMP      R2,R3
   \   00000058   0xD3F8             BCC.N    ??OS_StatTask_4
    468          #else
    469                  p_stk     = OSCfg_ISRStkBasePtr + OSCfg_ISRStkSize - 1u;/*   Start at the highest memory and go down            */
    470          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
    471                  p_stk    -= OS_CFG_TASK_STK_REDZONE_DEPTH;
    472                  size_stk  = OSCfg_ISRStkSize - OS_CFG_TASK_STK_REDZONE_DEPTH;
    473          #else
    474                  size_stk  = OSCfg_ISRStkSize;
    475          #endif
    476                  while ((*p_stk == 0u) && (free_stk < size_stk)) {       /*   Compute the number of zero entries on the stk      */
    477                      free_stk++;
    478                      p_stk--;
    479                  }
    480          #endif
    481                  OSISRStkFree = free_stk;
   \                     ??OS_StatTask_6: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable3_8
   \   0000005C   0x6002             STR      R2,[R0, #+0]
    482                  OSISRStkUsed = OSCfg_ISRStkSize - free_stk;
   \   0000005E   0x....             LDR.N    R0,??DataTable3_9
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x1A82             SUBS     R2,R0,R2
   \   00000064   0x....             LDR.N    R0,??DataTable3_10
   \   00000066   0x6002             STR      R2,[R0, #+0]
    483          #endif
    484          
    485                  if (OSStatResetFlag == OS_TRUE) {                       /* Check if need to reset statistics                    */
   \   00000068   0x....             LDR.N    R0,??DataTable3_11
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD105             BNE.N    ??OS_StatTask_7
    486                      OSStatResetFlag  = OS_FALSE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x....             LDR.N    R1,??DataTable3_11
   \   00000074   0x7008             STRB     R0,[R1, #+0]
    487                      OSStatReset(&err);
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x.... 0x....      BL       OSStatReset
    488                  }
    489          
    490          #if (OS_CFG_TS_EN > 0u)
    491                  OSStatTaskTime = OS_TS_GET() - ts_start;                /*----- Measure execution time of statistic task -------*/
    492                  if (OSStatTaskTimeMax < OSStatTaskTime) {
    493                      OSStatTaskTimeMax = OSStatTaskTime;
    494                  }
    495          #endif
    496          
    497                  OSTimeDly(dly,
    498                            OS_OPT_TIME_DLY,
    499                            &err);
   \                     ??OS_StatTask_7: (+1)
   \   0000007C   0x466A             MOV      R2,SP
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       OSTimeDly
   \                     ??OS_StatTask_3: (+1)
   \   00000086   0x2040             MOVS     R0,#+64
   \   00000088   0x.... 0x....      BL       CPU_SR_Save
   \   0000008C   0x....             LDR.N    R1,??DataTable3_3
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0x....             LDR.N    R2,??DataTable3_12
   \   00000092   0x6011             STR      R1,[R2, #+0]
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x....             LDR.N    R2,??DataTable3_3
   \   00000098   0x6011             STR      R1,[R2, #+0]
   \   0000009A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000009E   0x....             LDR.N    R0,??DataTable3_12
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x....             LDR.N    R1,??DataTable3_6
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD23E             BCS.N    ??OS_StatTask_8
   \   000000AA   0x....             LDR.N    R0,??DataTable3_6
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x....             LDR.N    R1,??DataTable3_13  ;; 0x61a80
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD203             BCS.N    ??OS_StatTask_9
   \   000000B4   0xF242 0x7210      MOVW     R2,#+10000
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE01C             B.N      ??OS_StatTask_10
   \                     ??OS_StatTask_9: (+1)
   \   000000BC   0x....             LDR.N    R0,??DataTable3_6
   \   000000BE   0x6800             LDR      R0,[R0, #+0]
   \   000000C0   0x....             LDR.N    R1,??DataTable3_14  ;; 0x3d0900
   \   000000C2   0x4288             CMP      R0,R1
   \   000000C4   0xD203             BCS.N    ??OS_StatTask_11
   \   000000C6   0xF44F 0x727A      MOV      R2,#+1000
   \   000000CA   0x200A             MOVS     R0,#+10
   \   000000CC   0xE013             B.N      ??OS_StatTask_10
   \                     ??OS_StatTask_11: (+1)
   \   000000CE   0x....             LDR.N    R0,??DataTable3_6
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x....             LDR.N    R1,??DataTable3_15  ;; 0x2625a00
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD202             BCS.N    ??OS_StatTask_12
   \   000000D8   0x2264             MOVS     R2,#+100
   \   000000DA   0x2064             MOVS     R0,#+100
   \   000000DC   0xE00B             B.N      ??OS_StatTask_10
   \                     ??OS_StatTask_12: (+1)
   \   000000DE   0x....             LDR.N    R0,??DataTable3_6
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x....             LDR.N    R1,??DataTable3_16  ;; 0x17d78400
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD203             BCS.N    ??OS_StatTask_13
   \   000000E8   0x220A             MOVS     R2,#+10
   \   000000EA   0xF44F 0x707A      MOV      R0,#+1000
   \   000000EE   0xE002             B.N      ??OS_StatTask_10
   \                     ??OS_StatTask_13: (+1)
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0xF242 0x7010      MOVW     R0,#+10000
   \                     ??OS_StatTask_10: (+1)
   \   000000F6   0x....             LDR.N    R1,??DataTable3_6
   \   000000F8   0x6809             LDR      R1,[R1, #+0]
   \   000000FA   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \   000000FE   0xF242 0x7310      MOVW     R3,#+10000
   \   00000102   0x....             LDR.N    R0,??DataTable3_12
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x4342             MULS     R2,R0,R2
   \   00000108   0xFBB2 0xF0F1      UDIV     R0,R2,R1
   \   0000010C   0x1A1B             SUBS     R3,R3,R0
   \   0000010E   0x....             LDR.N    R0,??DataTable3_17
   \   00000110   0x8003             STRH     R3,[R0, #+0]
   \   00000112   0x....             LDR.N    R0,??DataTable3
   \   00000114   0x8800             LDRH     R0,[R0, #+0]
   \   00000116   0x....             LDR.N    R1,??DataTable3_17
   \   00000118   0x8809             LDRH     R1,[R1, #+0]
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xD207             BCS.N    ??OS_StatTask_14
   \   0000011E   0x....             LDR.N    R0,??DataTable3_17
   \   00000120   0x8800             LDRH     R0,[R0, #+0]
   \   00000122   0x....             LDR.N    R1,??DataTable3
   \   00000124   0x8008             STRH     R0,[R1, #+0]
   \   00000126   0xE002             B.N      ??OS_StatTask_14
   \                     ??OS_StatTask_8: (+1)
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x....             LDR.N    R1,??DataTable3_17
   \   0000012C   0x8008             STRH     R0,[R1, #+0]
   \                     ??OS_StatTask_14: (+1)
   \   0000012E   0x.... 0x....      BL       OSStatTaskHook
   \   00000132   0x2200             MOVS     R2,#+0
   \   00000134   0x....             LDR.N    R0,??DataTable3_18
   \   00000136   0x6801             LDR      R1,[R0, #+0]
   \   00000138   0x....             LDR.N    R0,??DataTable3_9
   \   0000013A   0x6803             LDR      R3,[R0, #+0]
   \   0000013C   0xE788             B.N      ??OS_StatTask_5
    500              }
    501          }
    502          
    503          
    504          /*
    505          ************************************************************************************************************************
    506          *                                              INITIALIZE THE STATISTICS
    507          *
    508          * Description: This function is called by OSInit() to initialize the statistic task.
    509          *
    510          * Argument(s): p_err     is a pointer to a variable that will contain an error code returned by this function.
    511          *
    512          *                            OS_ERR_STAT_STK_INVALID       If you specified a NULL stack pointer during configuration
    513          *                            OS_ERR_STAT_STK_SIZE_INVALID  If you didn't specify a large enough stack.
    514          *                            OS_ERR_STAT_PRIO_INVALID      If you specified a priority for the statistic task equal to or
    515          *                                                          lower (i.e. higher number) than the idle task.
    516          *                            OS_ERR_xxx                    An error code returned by OSTaskCreate()
    517          *
    518          * Returns    : none
    519          *
    520          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    521          ************************************************************************************************************************
    522          */
    523          

   \                                 In section .text, align 2, keep-with-next
    524          void  OS_StatTaskInit (OS_ERR  *p_err)
    525          {
   \                     OS_StatTaskInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    526              OSStatTaskCtr    = 0u;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R2,??DataTable3_3
   \   00000008   0x6011             STR      R1,[R2, #+0]
    527              OSStatTaskCtrRun = 0u;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x....             LDR.N    R2,??DataTable3_12
   \   0000000E   0x6011             STR      R1,[R2, #+0]
    528              OSStatTaskCtrMax = 0u;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R2,??DataTable3_6
   \   00000014   0x6011             STR      R1,[R2, #+0]
    529              OSStatTaskRdy    = OS_STATE_NOT_RDY;                        /* Statistic task is not ready                          */
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x....             LDR.N    R2,??DataTable3_7
   \   0000001A   0x7011             STRB     R1,[R2, #+0]
    530              OSStatResetFlag  = OS_FALSE;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x....             LDR.N    R2,??DataTable3_11
   \   00000020   0x7011             STRB     R1,[R2, #+0]
    531          
    532          #if (OS_CFG_STAT_TASK_STK_CHK_EN > 0u) && (OS_CFG_ISR_STK_SIZE > 0u)
    533              OSISRStkFree     = 0u;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x....             LDR.N    R2,??DataTable3_8
   \   00000026   0x6011             STR      R1,[R2, #+0]
    534              OSISRStkUsed     = 0u;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x....             LDR.N    R2,??DataTable3_10
   \   0000002C   0x6011             STR      R1,[R2, #+0]
    535          #endif
    536                                                                          /* --------------- CREATE THE STAT TASK --------------- */
    537              if (OSCfg_StatTaskStkBasePtr == (CPU_STK *)0) {
   \   0000002E   0x....             LDR.N    R1,??DataTable3_19
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD103             BNE.N    ??OS_StatTaskInit_0
    538                 *p_err = OS_ERR_STAT_STK_INVALID;
   \   00000036   0xF646 0x612B      MOVW     R1,#+28203
   \   0000003A   0x8001             STRH     R1,[R0, #+0]
    539                  return;
   \   0000003C   0xE02C             B.N      ??OS_StatTaskInit_1
    540              }
    541          
    542              if (OSCfg_StatTaskStkSize < OSCfg_StkSizeMin) {
   \                     ??OS_StatTaskInit_0: (+1)
   \   0000003E   0x....             LDR.N    R1,??DataTable3_20
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x....             LDR.N    R2,??DataTable3_21
   \   00000044   0x6812             LDR      R2,[R2, #+0]
   \   00000046   0x4291             CMP      R1,R2
   \   00000048   0xD203             BCS.N    ??OS_StatTaskInit_2
    543                 *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
   \   0000004A   0xF646 0x612C      MOVW     R1,#+28204
   \   0000004E   0x8001             STRH     R1,[R0, #+0]
    544                  return;
   \   00000050   0xE022             B.N      ??OS_StatTaskInit_1
    545              }
    546          
    547              if (OSCfg_StatTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OS_StatTaskInit_2: (+1)
   \   00000052   0x....             LDR.N    R1,??DataTable3_22
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x293F             CMP      R1,#+63
   \   00000058   0xD303             BCC.N    ??OS_StatTaskInit_3
    548                 *p_err = OS_ERR_STAT_PRIO_INVALID;
   \   0000005A   0xF646 0x612A      MOVW     R1,#+28202
   \   0000005E   0x8001             STRH     R1,[R0, #+0]
    549                  return;
   \   00000060   0xE01A             B.N      ??OS_StatTaskInit_1
    550              }
    551          
    552              OSTaskCreate(&OSStatTaskTCB,
    553          #if  (OS_CFG_DBG_EN == 0u)
    554                           (CPU_CHAR   *)0,
    555          #else
    556                           (CPU_CHAR   *)"uC/OS-III Stat Task",
    557          #endif
    558                            OS_StatTask,
    559                           (void       *)0,
    560                            OSCfg_StatTaskPrio,
    561                            OSCfg_StatTaskStkBasePtr,
    562                            OSCfg_StatTaskStkLimit,
    563                            OSCfg_StatTaskStkSize,
    564                            0u,
    565                            0u,
    566                           (void       *)0,
    567                           (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
    568                            p_err);
   \                     ??OS_StatTaskInit_3: (+1)
   \   00000062   0x9008             STR      R0,[SP, #+32]
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0x9007             STR      R0,[SP, #+28]
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x9006             STR      R0,[SP, #+24]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x9005             STR      R0,[SP, #+20]
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x9004             STR      R0,[SP, #+16]
   \   00000074   0x....             LDR.N    R0,??DataTable3_20
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x9003             STR      R0,[SP, #+12]
   \   0000007A   0x....             LDR.N    R0,??DataTable3_23
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x9002             STR      R0,[SP, #+8]
   \   00000080   0x....             LDR.N    R0,??DataTable3_19
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x9001             STR      R0,[SP, #+4]
   \   00000086   0x....             LDR.N    R0,??DataTable3_22
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x2300             MOVS     R3,#+0
   \   0000008E   0x....             LDR.N    R2,??DataTable3_24
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x....             LDR.N    R0,??DataTable3_25
   \   00000094   0x.... 0x....      BL       OSTaskCreate
    569          }
   \                     ??OS_StatTaskInit_1: (+1)
   \   00000098   0xB009             ADD      SP,SP,#+36
   \   0000009A   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSStatTaskCPUUsageMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     OSTmrTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     OSStatTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     OSCfg_StatTaskRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     OSStatTaskCtrMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     OSStatTaskRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     OSISRStkFree

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x........         DC32     OSISRStkUsed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     OSStatResetFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     OSStatTaskCtrRun

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x00061A80         DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x02625A00         DC32     0x2625a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_16:
   \   00000000   0x17D78400         DC32     0x17d78400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_17:
   \   00000000   0x........         DC32     OSStatTaskCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_18:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_19:
   \   00000000   0x........         DC32     OSCfg_StatTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_20:
   \   00000000   0x........         DC32     OSCfg_StatTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_21:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_22:
   \   00000000   0x........         DC32     OSCfg_StatTaskPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_23:
   \   00000000   0x........         DC32     OSCfg_StatTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_24:
   \   00000000   0x........         DC32     OS_StatTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_25:
   \   00000000   0x........         DC32     OSStatTaskTCB
    570          
    571          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSStatReset
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
      16   OSStatTaskCPUUsageInit
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSTaskResume
        16   -> OSTaskSuspend
        16   -> OSTimeDly
      16   OS_StatTask
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSStatReset
        16   -> OSStatTaskHook
        16   -> OSTimeDly
      40   OS_StatTaskInit
        40   -> OSTaskCreate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_19
       4  ??DataTable3_2
       4  ??DataTable3_20
       4  ??DataTable3_21
       4  ??DataTable3_22
       4  ??DataTable3_23
       4  ??DataTable3_24
       4  ??DataTable3_25
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      28  OSStatReset
     196  OSStatTaskCPUUsageInit
     318  OS_StatTask
     156  OS_StatTaskInit

 
 802 bytes in section .text
 
 802 bytes of CODE memory

Errors: none
Warnings: none
