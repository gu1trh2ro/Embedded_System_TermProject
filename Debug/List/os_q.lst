###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_q.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3B6B.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_q.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_q.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_q.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_q.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                       MESSAGE QUEUE MANAGEMENT
     20          *
     21          * File    : os_q.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_q__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_Q_EN > 0u)
     35          /*
     36          ************************************************************************************************************************
     37          *                                               CREATE A MESSAGE QUEUE
     38          *
     39          * Description: This function is called by your application to create a message queue.  Message queues MUST be created
     40          *              before they can be used.
     41          *
     42          * Arguments  : p_q         is a pointer to the message queue
     43          *
     44          *              p_name      is a pointer to an ASCII string that will be used to name the message queue
     45          *
     46          *              max_qty     indicates the maximum size of the message queue (must be non-zero).  Note that it's also not
     47          *                          possible to have a size higher than the maximum number of OS_MSGs available.
     48          *
     49          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
     50          *
     51          *                              OS_ERR_NONE                    The call was successful
     52          *                              OS_ERR_CREATE_ISR              Can't create from an ISR
     53          *                              OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the Queue after you called
     54          *                                                               OSSafetyCriticalStart()
     55          *                              OS_ERR_OBJ_PTR_NULL            If you passed a NULL pointer for 'p_q'
     56          *                              OS_ERR_Q_SIZE                  If the size you specified is 0
     57          *                              OS_ERR_OBJ_CREATED             If the message queue was already created
     58          *
     59          * Returns    : none
     60          *
     61          * Note(s)    : none
     62          ************************************************************************************************************************
     63          */
     64          

   \                                 In section .text, align 2, keep-with-next
     65          void  OSQCreate (OS_Q        *p_q,
     66                           CPU_CHAR    *p_name,
     67                           OS_MSG_QTY   max_qty,
     68                           OS_ERR      *p_err)
     69          
     70          {
   \                     OSQCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
     71              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
     72          
     73          
     74          #ifdef OS_SAFETY_CRITICAL
     75              if (p_err == (OS_ERR *)0) {
     76                  OS_SAFETY_CRITICAL_EXCEPTION();
     77                  return;
     78              }
     79          #endif
     80          
     81          #ifdef OS_SAFETY_CRITICAL_IEC61508
     82              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     83                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     84                  return;
     85              }
     86          #endif
     87          
     88          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
     89              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSQCreate_0
     90                 *p_err = OS_ERR_CREATE_ISR;
   \   00000014   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
     91                  return;
   \   0000001A   0xE02E             B.N      ??OSQCreate_1
     92              }
     93          #endif
     94          
     95          #if (OS_CFG_ARG_CHK_EN > 0u)
     96              if (p_q == (OS_Q *)0) {                                     /* Validate arguments                                   */
   \                     ??OSQCreate_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD103             BNE.N    ??OSQCreate_2
     97                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8028             STRH     R0,[R5, #+0]
     98                  return;
   \   00000026   0xE028             B.N      ??OSQCreate_1
     99              }
    100              if (max_qty == 0u) {                                        /* Cannot specify a zero size queue                     */
   \                     ??OSQCreate_2: (+1)
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??OSQCreate_3
    101                 *p_err = OS_ERR_Q_SIZE;
   \   00000030   0xF246 0x5094      MOVW     R0,#+26004
   \   00000034   0x8028             STRH     R0,[R5, #+0]
    102                  return;
   \   00000036   0xE020             B.N      ??OSQCreate_1
    103              }
    104          #endif
    105          
    106              CPU_CRITICAL_ENTER();
   \                     ??OSQCreate_3: (+1)
   \   00000038   0x2040             MOVS     R0,#+64
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x0007             MOVS     R7,R0
    107          #if (OS_OBJ_TYPE_REQ > 0u)
    108          #if (OS_CFG_OBJ_CREATED_CHK_EN > 0u)
    109              if (p_q->Type == OS_OBJ_TYPE_Q) {
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x55455551
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD106             BNE.N    ??OSQCreate_4
    110                  CPU_CRITICAL_EXIT();
   \   0000004A   0x0038             MOVS     R0,R7
   \   0000004C   0x.... 0x....      BL       CPU_SR_Restore
    111                  *p_err = OS_ERR_OBJ_CREATED;
   \   00000050   0xF645 0x50C1      MOVW     R0,#+24001
   \   00000054   0x8028             STRH     R0,[R5, #+0]
    112                  return;
   \   00000056   0xE010             B.N      ??OSQCreate_1
    113              }
    114          #endif
    115              p_q->Type    = OS_OBJ_TYPE_Q;                               /* Mark the data structure as a message queue           */
   \                     ??OSQCreate_4: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0x55455551
   \   0000005C   0x6020             STR      R0,[R4, #+0]
    116          #endif
    117          #if (OS_CFG_DBG_EN > 0u)
    118              p_q->NamePtr = p_name;
    119          #else
    120              (void)p_name;
    121          #endif
    122              OS_MsgQInit(&p_q->MsgQ,                                     /* Initialize the queue                                 */
    123                          max_qty);
   \   0000005E   0x0031             MOVS     R1,R6
   \   00000060   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000062   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000066   0x.... 0x....      BL       OS_MsgQInit
    124              OS_PendListInit(&p_q->PendList);                            /* Initialize the waiting list                          */
   \   0000006A   0x1D20             ADDS     R0,R4,#+4
   \   0000006C   0x.... 0x....      BL       OS_PendListInit
    125          
    126          #if (OS_CFG_DBG_EN > 0u)
    127              OS_QDbgListAdd(p_q);
    128              OSQQty++;                                                   /* One more queue created                               */
    129          #endif
    130              OS_TRACE_Q_CREATE(p_q, p_name);
    131              CPU_CRITICAL_EXIT();
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    132             *p_err = OS_ERR_NONE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x8028             STRH     R0,[R5, #+0]
    133          }
   \                     ??OSQCreate_1: (+1)
   \   0000007A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    134          
    135          
    136          /*
    137          ************************************************************************************************************************
    138          *                                               DELETE A MESSAGE QUEUE
    139          *
    140          * Description: This function deletes a message queue and readies all tasks pending on the queue.
    141          *
    142          * Arguments  : p_q       is a pointer to the message queue you want to delete
    143          *
    144          *              opt       determines delete options as follows:
    145          *
    146          *                            OS_OPT_DEL_NO_PEND          Delete the queue ONLY if no task pending
    147          *                            OS_OPT_DEL_ALWAYS           Deletes the queue even if tasks are waiting.
    148          *                                                        In this case, all the tasks pending will be readied.
    149          *
    150          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    151          *
    152          *                            OS_ERR_NONE                    The call was successful and the queue was deleted
    153          *                            OS_ERR_DEL_ISR                 If you tried to delete the queue from an ISR
    154          *                            OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the message queue after you
    155          *                                                             called OSStart()
    156          *                            OS_ERR_OBJ_PTR_NULL            If you pass a NULL pointer for 'p_q'
    157          *                            OS_ERR_OBJ_TYPE                If the message queue was not created
    158          *                            OS_ERR_OPT_INVALID             An invalid option was specified
    159          *                            OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    160          *                            OS_ERR_TASK_WAITING            One or more tasks were waiting on the queue
    161          *
    162          * Returns    : == 0          if no tasks were waiting on the queue, or upon error.
    163          *              >  0          if one or more tasks waiting on the queue are now readied and informed.
    164          *
    165          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the queue MUST
    166          *                 check the return code of OSQPend().
    167          *
    168          *              2) Because ALL tasks pending on the queue will be readied, you MUST be careful in applications where the
    169          *                 queue is used for mutual exclusion because the resource(s) will no longer be guarded by the queue.
    170          ************************************************************************************************************************
    171          */
    172          
    173          #if (OS_CFG_Q_DEL_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    174          OS_OBJ_QTY  OSQDel (OS_Q    *p_q,
    175                              OS_OPT   opt,
    176                              OS_ERR  *p_err)
    177          {
   \                     OSQDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0015             MOVS     R5,R2
    178              OS_OBJ_QTY     nbr_tasks;
    179              OS_PEND_LIST  *p_pend_list;
    180              OS_TCB        *p_tcb;
    181              CPU_TS         ts;
    182              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    183          
    184          
    185          #ifdef OS_SAFETY_CRITICAL
    186              if (p_err == (OS_ERR *)0) {
    187                  OS_SAFETY_CRITICAL_EXCEPTION();
    188                  return (0u);
    189              }
    190          #endif
    191          
    192              OS_TRACE_Q_DEL_ENTER(p_q, opt);
    193          
    194          #ifdef OS_SAFETY_CRITICAL_IEC61508
    195              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    196                  OS_TRACE_Q_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    197                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    198                  return (0u);
    199              }
    200          #endif
    201          
    202          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    203              if (OSIntNestingCtr > 0u) {                                 /* Can't delete a message queue from an ISR             */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSQDel_0
    204                  OS_TRACE_Q_DEL_EXIT(OS_ERR_DEL_ISR);
    205                 *p_err = OS_ERR_DEL_ISR;
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    206                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE05F             B.N      ??OSQDel_1
    207              }
    208          #endif
    209          
    210          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    211              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSQDel_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD004             BEQ.N    ??OSQDel_2
    212                  OS_TRACE_Q_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    213                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002A   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    214                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE055             B.N      ??OSQDel_1
    215              }
    216          #endif
    217          
    218          #if (OS_CFG_ARG_CHK_EN > 0u)
    219              if (p_q == (OS_Q *)0) {                                     /* Validate 'p_q'                                       */
   \                     ??OSQDel_2: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD104             BNE.N    ??OSQDel_3
    220                  OS_TRACE_Q_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    221                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000038   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    222                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE04E             B.N      ??OSQDel_1
    223              }
    224          #endif
    225          
    226          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    227              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQDel_3: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x55455551
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD004             BEQ.N    ??OSQDel_4
    228                  OS_TRACE_Q_DEL_EXIT(OS_ERR_OBJ_TYPE);
    229                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000004C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000050   0x8028             STRH     R0,[R5, #+0]
    230                  return (0u);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE044             B.N      ??OSQDel_1
    231              }
    232          #endif
    233          
    234              CPU_CRITICAL_ENTER();
   \                     ??OSQDel_4: (+1)
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
   \   0000005C   0x0007             MOVS     R7,R0
    235              p_pend_list = &p_q->PendList;
   \   0000005E   0xF114 0x0804      ADDS     R8,R4,#+4
    236              nbr_tasks   = 0u;
   \   00000062   0x2600             MOVS     R6,#+0
    237              switch (opt) {
   \   00000064   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000068   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006C   0xD003             BEQ.N    ??OSQDel_5
   \   0000006E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000072   0xD014             BEQ.N    ??OSQDel_6
   \   00000074   0xE02C             B.N      ??OSQDel_7
    238                  case OS_OPT_DEL_NO_PEND:                                /* Delete message queue only if no task waiting         */
    239                       if (p_pend_list->HeadPtr == (OS_TCB *)0) {
   \                     ??OSQDel_5: (+1)
   \   00000076   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD108             BNE.N    ??OSQDel_8
    240          #if (OS_CFG_DBG_EN > 0u)
    241                           OS_QDbgListRemove(p_q);
    242                           OSQQty--;
    243          #endif
    244                           OS_TRACE_Q_DEL(p_q);
    245                           OS_QClr(p_q);
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       OS_QClr
    246                           CPU_CRITICAL_EXIT();
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    247                          *p_err = OS_ERR_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x8028             STRH     R0,[R5, #+0]
   \   0000008E   0xE005             B.N      ??OSQDel_9
    248                       } else {
    249                           CPU_CRITICAL_EXIT();
   \                     ??OSQDel_8: (+1)
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    250                          *p_err = OS_ERR_TASK_WAITING;
   \   00000096   0xF247 0x105F      MOVW     R0,#+29023
   \   0000009A   0x8028             STRH     R0,[R5, #+0]
    251                       }
    252                       break;
   \                     ??OSQDel_9: (+1)
   \   0000009C   0xE01E             B.N      ??OSQDel_10
    253          
    254                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the message queue                      */
    255          #if (OS_CFG_TS_EN > 0u)
    256                       ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
    257          #else
    258                       ts = 0u;
   \                     ??OSQDel_6: (+1)
   \   0000009E   0xF05F 0x0900      MOVS     R9,#+0
   \   000000A2   0xE006             B.N      ??OSQDel_11
    259          #endif
    260                       while (p_pend_list->HeadPtr != (OS_TCB *)0) {      /* Remove all tasks from the pend list                  */
    261                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSQDel_12: (+1)
   \   000000A4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
    262                           OS_PendAbort(p_tcb,
    263                                        ts,
    264                                        OS_STATUS_PEND_DEL);
   \   000000A8   0x2202             MOVS     R2,#+2
   \   000000AA   0x4649             MOV      R1,R9
   \   000000AC   0x.... 0x....      BL       OS_PendAbort
    265                           nbr_tasks++;
   \   000000B0   0x1C76             ADDS     R6,R6,#+1
    266                       }
   \                     ??OSQDel_11: (+1)
   \   000000B2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD1F4             BNE.N    ??OSQDel_12
    267          #if (OS_CFG_DBG_EN > 0u)
    268                       OS_QDbgListRemove(p_q);
    269                       OSQQty--;
    270          #endif
    271                       OS_TRACE_Q_DEL(p_q);
    272                       OS_QClr(p_q);
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       OS_QClr
    273                       CPU_CRITICAL_EXIT();
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    274                       OSSched();                                         /* Find highest priority task ready to run              */
   \   000000C6   0x.... 0x....      BL       OSSched
    275                      *p_err = OS_ERR_NONE;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    276                       break;
   \   000000CE   0xE005             B.N      ??OSQDel_10
    277          
    278                  default:
    279                       CPU_CRITICAL_EXIT();
   \                     ??OSQDel_7: (+1)
   \   000000D0   0x0038             MOVS     R0,R7
   \   000000D2   0x.... 0x....      BL       CPU_SR_Restore
    280                      *p_err = OS_ERR_OPT_INVALID;
   \   000000D6   0xF645 0x6025      MOVW     R0,#+24101
   \   000000DA   0x8028             STRH     R0,[R5, #+0]
    281                       break;
    282              }
    283              OS_TRACE_Q_DEL_EXIT(*p_err);
    284              return (nbr_tasks);
   \                     ??OSQDel_10: (+1)
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQDel_1: (+1)
   \   000000E0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    285          }
    286          #endif
    287          
    288          
    289          /*
    290          ************************************************************************************************************************
    291          *                                                     FLUSH QUEUE
    292          *
    293          * Description : This function is used to flush the contents of the message queue.
    294          *
    295          * Arguments   : p_q        is a pointer to the message queue to flush
    296          *
    297          *               p_err      is a pointer to a variable that will contain an error code returned by this function.
    298          *
    299          *                              OS_ERR_NONE              Upon success
    300          *                              OS_ERR_FLUSH_ISR         If you called this function from an ISR
    301          *                              OS_ERR_OBJ_PTR_NULL      If you passed a NULL pointer for 'p_q'
    302          *                              OS_ERR_OBJ_TYPE          If you didn't create the message queue
    303          *                              OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    304          *
    305          * Returns     : == 0       if no entries were freed, or upon error.
    306          *               >  0       the number of freed entries.
    307          *
    308          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    309          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    310          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    311          *                  likely, need to be de-allocated (i.e. freed).
    312          ************************************************************************************************************************
    313          */
    314          
    315          #if (OS_CFG_Q_FLUSH_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    316          OS_MSG_QTY  OSQFlush (OS_Q    *p_q,
    317                                OS_ERR  *p_err)
    318          {
   \                     OSQFlush: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    319              OS_MSG_QTY  entries;
    320              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    321          
    322          
    323          
    324          #ifdef OS_SAFETY_CRITICAL
    325              if (p_err == (OS_ERR *)0) {
    326                  OS_SAFETY_CRITICAL_EXCEPTION();
    327                  return (0u);
    328              }
    329          #endif
    330          
    331          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    332              if (OSIntNestingCtr > 0u) {                                 /* Can't flush a message queue from an ISR              */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSQFlush_0
    333                 *p_err = OS_ERR_FLUSH_ISR;
   \   00000012   0xF44F 0x506C      MOV      R0,#+15104
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    334                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE02A             B.N      ??OSQFlush_1
    335              }
    336          #endif
    337          
    338          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    339              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSQFlush_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSQFlush_2
    340                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    341                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE020             B.N      ??OSQFlush_1
    342              }
    343          #endif
    344          
    345          #if (OS_CFG_ARG_CHK_EN > 0u)
    346              if (p_q == (OS_Q *)0) {                                     /* Validate arguments                                   */
   \                     ??OSQFlush_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE.N    ??OSQFlush_3
    347                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    348                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE019             B.N      ??OSQFlush_1
    349              }
    350          #endif
    351          
    352          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    353              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQFlush_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x55455551
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD004             BEQ.N    ??OSQFlush_4
    354                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000048   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
    355                  return (0u);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00F             B.N      ??OSQFlush_1
    356              }
    357          #endif
    358          
    359              CPU_CRITICAL_ENTER();
   \                     ??OSQFlush_4: (+1)
   \   00000052   0x2040             MOVS     R0,#+64
   \   00000054   0x.... 0x....      BL       CPU_SR_Save
   \   00000058   0x0006             MOVS     R6,R0
    360              entries = OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the OS_MSG pool                */
   \   0000005A   0xF114 0x000C      ADDS     R0,R4,#+12
   \   0000005E   0x.... 0x....      BL       OS_MsgQFreeAll
   \   00000062   0x0004             MOVS     R4,R0
    361              CPU_CRITICAL_EXIT();
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
    362             *p_err   = OS_ERR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x8028             STRH     R0,[R5, #+0]
    363              return (entries);
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQFlush_1: (+1)
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    364          }
    365          #endif
    366          
    367          
    368          /*
    369          ************************************************************************************************************************
    370          *                                            PEND ON A QUEUE FOR A MESSAGE
    371          *
    372          * Description: This function waits for a message to be sent to a queue.
    373          *
    374          * Arguments  : p_q           is a pointer to the message queue
    375          *
    376          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    377          *                            message to arrive at the queue up to the amount of time specified by this argument.  If you
    378          *                            specify 0, however, your task will wait forever at the specified queue or, until a message
    379          *                            arrives.
    380          *
    381          *              opt           determines whether the user wants to block if the queue is empty or not:
    382          *
    383          *                                OS_OPT_PEND_BLOCKING
    384          *                                OS_OPT_PEND_NON_BLOCKING
    385          *
    386          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    387          *
    388          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    389          *                            received, pend aborted or the message queue deleted,  If you pass a NULL pointer (i.e.
    390          *                            (CPU_TS *)0) then you will not get the timestamp.  In other words, passing a NULL pointer
    391          *                            is valid and indicates that you don't need the timestamp.
    392          *
    393          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    394          *
    395          *                                OS_ERR_NONE               The call was successful and your task received a message
    396          *                                OS_ERR_OBJ_DEL            If 'p_q' was deleted
    397          *                                OS_ERR_OBJ_PTR_NULL       If you pass a NULL pointer for 'p_q'
    398          *                                OS_ERR_OBJ_TYPE           If the message queue was not created
    399          *                                OS_ERR_OPT_INVALID        You specified an invalid option
    400          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    401          *                                OS_ERR_PEND_ABORT         The pend was aborted
    402          *                                OS_ERR_PEND_ISR           If you called this function from an ISR
    403          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    404          *                                OS_ERR_PTR_INVALID        If you passed a NULL pointer of 'p_msg_size'
    405          *                                OS_ERR_SCHED_LOCKED       The scheduler is locked
    406          *                                OS_ERR_STATUS_INVALID     If the pend status has an invalid value
    407          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    408          *                                                          would lead to a suspension.
    409          *                                OS_ERR_TICK_DISABLED      If kernel ticks are disabled and a timeout is specified
    410          *
    411          * Returns    : != (void *)0  is a pointer to the message received
    412          *              == (void *)0  if you received a NULL pointer message or,
    413          *                            if no message was received or,
    414          *                            if 'p_q' is a NULL pointer or,
    415          *                            if you didn't pass a pointer to a queue.
    416          *
    417          * Note(s)    : This API 'MUST NOT' be called from a timer callback function.
    418          ************************************************************************************************************************
    419          */
    420          

   \                                 In section .text, align 2, keep-with-next
    421          void  *OSQPend (OS_Q         *p_q,
    422                          OS_TICK       timeout,
    423                          OS_OPT        opt,
    424                          OS_MSG_SIZE  *p_msg_size,
    425                          CPU_TS       *p_ts,
    426                          OS_ERR       *p_err)
    427          {
   \                     OSQPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0xF8DD 0x9024      LDR      R9,[SP, #+36]
    428              void  *p_void;
    429              CPU_SR_ALLOC();
   \   0000000E   0x2000             MOVS     R0,#+0
    430          
    431          
    432          #ifdef OS_SAFETY_CRITICAL
    433              if (p_err == (OS_ERR *)0) {
    434                  OS_SAFETY_CRITICAL_EXCEPTION();
    435                  return ((void *)0);
    436              }
    437          #endif
    438          
    439              OS_TRACE_Q_PEND_ENTER(p_q, timeout, opt, p_msg_size, p_ts);
    440          
    441          #if (OS_CFG_TICK_EN == 0u)
    442              if (timeout != 0u) {
    443                 *p_err = OS_ERR_TICK_DISABLED;
    444                  OS_TRACE_Q_PEND_FAILED(p_q);
    445                  OS_TRACE_Q_PEND_EXIT(OS_ERR_TICK_DISABLED);
    446                  return ((void *)0);
    447              }
    448          #endif
    449          
    450          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    451              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD009             BEQ.N    ??OSQPend_0
    452                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != OS_OPT_PEND_NON_BLOCKING) {
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0xD405             BMI.N    ??OSQPend_0
    453                      OS_TRACE_Q_PEND_FAILED(p_q);
    454                      OS_TRACE_Q_PEND_EXIT(OS_ERR_PEND_ISR);
    455                     *p_err = OS_ERR_PEND_ISR;
   \   00000022   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000026   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    456                      return ((void *)0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE0B1             B.N      ??OSQPend_1
    457                  }
    458              }
    459          #endif
    460          
    461          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    462              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSQPend_0: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD005             BEQ.N    ??OSQPend_2
    463                  OS_TRACE_Q_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    464                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000038   0xF645 0x6089      MOVW     R0,#+24201
   \   0000003C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    465                  return ((void *)0);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE0A6             B.N      ??OSQPend_1
    466              }
    467          #endif
    468          
    469          #if (OS_CFG_ARG_CHK_EN > 0u)
    470              if (p_q == (OS_Q *)0) {                                     /* Validate arguments                                   */
   \                     ??OSQPend_2: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD105             BNE.N    ??OSQPend_3
    471                  OS_TRACE_Q_PEND_FAILED(p_q);
    472                  OS_TRACE_Q_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    473                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000048   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000004C   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    474                  return ((void *)0);
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xE09E             B.N      ??OSQPend_1
    475              }
   \                     ??OSQPend_3: (+1)
   \   00000054   0x001C             MOVS     R4,R3
    476              if (p_msg_size == (OS_MSG_SIZE *)0) {
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD105             BNE.N    ??OSQPend_4
    477                  OS_TRACE_Q_PEND_FAILED(p_q);
    478                  OS_TRACE_Q_PEND_EXIT(OS_ERR_PTR_INVALID);
    479                 *p_err = OS_ERR_PTR_INVALID;
   \   0000005A   0xF246 0x20D5      MOVW     R0,#+25301
   \   0000005E   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    480                  return ((void *)0);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE095             B.N      ??OSQPend_1
    481              }
    482              switch (opt) {
   \                     ??OSQPend_4: (+1)
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD002             BEQ.N    ??OSQPend_5
   \   0000006E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000072   0xD11E             BNE.N    ??OSQPend_6
    483                  case OS_OPT_PEND_BLOCKING:
    484                  case OS_OPT_PEND_NON_BLOCKING:
    485                       break;
    486          
    487                  default:
    488                       OS_TRACE_Q_PEND_FAILED(p_q);
    489                       OS_TRACE_Q_PEND_EXIT(OS_ERR_OPT_INVALID);
    490                      *p_err = OS_ERR_OPT_INVALID;
    491                       return ((void *)0);
    492              }
    493          #endif
    494          
    495          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    496              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQPend_5: (+1)
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x55455551
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD11F             BNE.N    ??OSQPend_7
   \   0000007E   0x9E08             LDR      R6,[SP, #+32]
    497                  OS_TRACE_Q_PEND_FAILED(p_q);
    498                  OS_TRACE_Q_PEND_EXIT(OS_ERR_OBJ_TYPE);
    499                 *p_err = OS_ERR_OBJ_TYPE;
    500                  return ((void *)0);
    501              }
    502          #endif
    503          
    504              if (p_ts != (CPU_TS *)0) {
   \   00000080   0x2E00             CMP      R6,#+0
   \   00000082   0xD001             BEQ.N    ??OSQPend_8
    505                 *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x6030             STR      R0,[R6, #+0]
    506              }
    507          
    508              CPU_CRITICAL_ENTER();
   \                     ??OSQPend_8: (+1)
   \   00000088   0x2040             MOVS     R0,#+64
   \   0000008A   0x.... 0x....      BL       CPU_SR_Save
   \   0000008E   0x4682             MOV      R10,R0
    509              p_void = OS_MsgQGet(&p_q->MsgQ,                             /* Any message waiting in the message queue?            */
    510                                  p_msg_size,
    511                                  p_ts,
    512                                  p_err);
   \   00000090   0x464B             MOV      R3,R9
   \   00000092   0x0032             MOVS     R2,R6
   \   00000094   0x0021             MOVS     R1,R4
   \   00000096   0xF115 0x000C      ADDS     R0,R5,#+12
   \   0000009A   0x.... 0x....      BL       OS_MsgQGet
   \   0000009E   0x0006             MOVS     R6,R0
    513              if (*p_err == OS_ERR_NONE) {
   \   000000A0   0xF8B9 0x0000      LDRH     R0,[R9, #+0]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD110             BNE.N    ??OSQPend_9
    514                  OS_TRACE_Q_PEND(p_q);
    515                  CPU_CRITICAL_EXIT();
   \   000000A8   0x4650             MOV      R0,R10
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    516                  OS_TRACE_Q_PEND_EXIT(OS_ERR_NONE);
    517                  return (p_void);                                        /* Yes, Return message received                         */
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0xE06F             B.N      ??OSQPend_1
    518              }
   \                     ??OSQPend_6: (+1)
   \   000000B2   0xF645 0x6025      MOVW     R0,#+24101
   \   000000B6   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE069             B.N      ??OSQPend_1
   \                     ??OSQPend_7: (+1)
   \   000000BE   0xF645 0x50C4      MOVW     R0,#+24004
   \   000000C2   0xF8A9 0x0000      STRH     R0,[R9, #+0]
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xE063             B.N      ??OSQPend_1
    519          
    520              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSQPend_9: (+1)
   \   000000CA   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000CE   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   000000D2   0xD508             BPL.N    ??OSQPend_10
    521                  CPU_CRITICAL_EXIT();
   \   000000D4   0x4650             MOV      R0,R10
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
    522                  OS_TRACE_Q_PEND_FAILED(p_q);
    523                  OS_TRACE_Q_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    524                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \   000000DA   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000DE   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    525                  return ((void *)0);
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xE055             B.N      ??OSQPend_1
    526              } else {
    527                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSQPend_10: (+1)
   \   000000E6   0x....             LDR.N    R0,??DataTable6_3
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD008             BEQ.N    ??OSQPend_11
    528                      CPU_CRITICAL_EXIT();
   \   000000EE   0x4650             MOV      R0,R10
   \   000000F0   0x.... 0x....      BL       CPU_SR_Restore
    529                      OS_TRACE_Q_PEND_FAILED(p_q);
    530                      OS_TRACE_Q_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    531                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000F4   0xF646 0x5063      MOVW     R0,#+28003
   \   000000F8   0xF8A9 0x0000      STRH     R0,[R9, #+0]
    532                      return ((void *)0);
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xE048             B.N      ??OSQPend_1
    533                  }
    534              }
    535          
    536              OS_Pend((OS_PEND_OBJ *)((void *)p_q),                       /* Block task pending on Message Queue                  */
    537                      OSTCBCurPtr,
    538                      OS_TASK_PEND_ON_Q,
    539                      timeout);
   \                     ??OSQPend_11: (+1)
   \   00000100   0x003B             MOVS     R3,R7
   \   00000102   0x2205             MOVS     R2,#+5
   \   00000104   0x....             LDR.N    R0,??DataTable6_4
   \   00000106   0x6801             LDR      R1,[R0, #+0]
   \   00000108   0x0028             MOVS     R0,R5
   \   0000010A   0x.... 0x....      BL       OS_Pend
    540              CPU_CRITICAL_EXIT();
   \   0000010E   0x4650             MOV      R0,R10
   \   00000110   0x.... 0x....      BL       CPU_SR_Restore
    541              OS_TRACE_Q_PEND_BLOCK(p_q);
    542              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   00000114   0x.... 0x....      BL       OSSched
    543          
    544              CPU_CRITICAL_ENTER();
   \   00000118   0x2040             MOVS     R0,#+64
   \   0000011A   0x.... 0x....      BL       CPU_SR_Save
    545              switch (OSTCBCurPtr->PendStatus) {
   \   0000011E   0x....             LDR.N    R1,??DataTable6_4
   \   00000120   0x6809             LDR      R1,[R1, #+0]
   \   00000122   0xF891 0x102D      LDRB     R1,[R1, #+45]
   \   00000126   0x2900             CMP      R1,#+0
   \   00000128   0xD005             BEQ.N    ??OSQPend_12
   \   0000012A   0x2902             CMP      R1,#+2
   \   0000012C   0xD01F             BEQ.N    ??OSQPend_13
   \   0000012E   0xD30E             BCC.N    ??OSQPend_14
   \   00000130   0x2903             CMP      R1,#+3
   \   00000132   0xD014             BEQ.N    ??OSQPend_15
   \   00000134   0xE023             B.N      ??OSQPend_16
    546                  case OS_STATUS_PEND_OK:                                 /* Extract message from TCB (Put there by Post)         */
    547                       p_void     = OSTCBCurPtr->MsgPtr;
   \                     ??OSQPend_12: (+1)
   \   00000136   0x....             LDR.N    R1,??DataTable6_4
   \   00000138   0x6809             LDR      R1,[R1, #+0]
   \   0000013A   0x6D4D             LDR      R5,[R1, #+84]
    548                      *p_msg_size = OSTCBCurPtr->MsgSize;
   \   0000013C   0x....             LDR.N    R1,??DataTable6_4
   \   0000013E   0x6809             LDR      R1,[R1, #+0]
   \   00000140   0xF8B1 0x1058      LDRH     R1,[R1, #+88]
   \   00000144   0x8021             STRH     R1,[R4, #+0]
    549          #if (OS_CFG_TS_EN > 0u)
    550                       if (p_ts  != (CPU_TS *)0) {
    551                          *p_ts  =  OSTCBCurPtr->TS;
    552                       }
    553          #endif
    554                       OS_TRACE_Q_PEND(p_q);
    555                      *p_err      = OS_ERR_NONE;
   \   00000146   0x2100             MOVS     R1,#+0
   \   00000148   0xF8A9 0x1000      STRH     R1,[R9, #+0]
    556                       break;
   \   0000014C   0xE01E             B.N      ??OSQPend_17
    557          
    558                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    559                       p_void     = (void *)0;
   \                     ??OSQPend_14: (+1)
   \   0000014E   0x2500             MOVS     R5,#+0
    560                      *p_msg_size =         0u;
   \   00000150   0x2100             MOVS     R1,#+0
   \   00000152   0x8021             STRH     R1,[R4, #+0]
    561          #if (OS_CFG_TS_EN > 0u)
    562                       if (p_ts  != (CPU_TS *)0) {
    563                          *p_ts  =  OSTCBCurPtr->TS;
    564                       }
    565          #endif
    566                       OS_TRACE_Q_PEND_FAILED(p_q);
    567                      *p_err      = OS_ERR_PEND_ABORT;
   \   00000154   0xF246 0x11A9      MOVW     R1,#+25001
   \   00000158   0xF8A9 0x1000      STRH     R1,[R9, #+0]
    568                       break;
   \   0000015C   0xE016             B.N      ??OSQPend_17
    569          
    570                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get event within TO          */
    571                       p_void     = (void *)0;
   \                     ??OSQPend_15: (+1)
   \   0000015E   0x2500             MOVS     R5,#+0
    572                      *p_msg_size =         0u;
   \   00000160   0x2100             MOVS     R1,#+0
   \   00000162   0x8021             STRH     R1,[R4, #+0]
    573                       OS_TRACE_Q_PEND_FAILED(p_q);
    574                      *p_err      = OS_ERR_TIMEOUT;
   \   00000164   0xF247 0x21D9      MOVW     R1,#+29401
   \   00000168   0xF8A9 0x1000      STRH     R1,[R9, #+0]
    575                       break;
   \   0000016C   0xE00E             B.N      ??OSQPend_17
    576          
    577                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    578                       p_void     = (void *)0;
   \                     ??OSQPend_13: (+1)
   \   0000016E   0x2500             MOVS     R5,#+0
    579                      *p_msg_size =         0u;
   \   00000170   0x2100             MOVS     R1,#+0
   \   00000172   0x8021             STRH     R1,[R4, #+0]
    580          #if (OS_CFG_TS_EN > 0u)
    581                       if (p_ts  != (CPU_TS *)0) {
    582                          *p_ts  =  OSTCBCurPtr->TS;
    583                       }
    584          #endif
    585                       OS_TRACE_Q_PEND_FAILED(p_q);
    586                      *p_err      = OS_ERR_OBJ_DEL;
   \   00000174   0xF645 0x51C2      MOVW     R1,#+24002
   \   00000178   0xF8A9 0x1000      STRH     R1,[R9, #+0]
    587                       break;
   \   0000017C   0xE006             B.N      ??OSQPend_17
    588          
    589                  default:
    590                       p_void     = (void *)0;
   \                     ??OSQPend_16: (+1)
   \   0000017E   0x2500             MOVS     R5,#+0
    591                      *p_msg_size =         0u;
   \   00000180   0x2100             MOVS     R1,#+0
   \   00000182   0x8021             STRH     R1,[R4, #+0]
    592                       OS_TRACE_Q_PEND_FAILED(p_q);
    593                      *p_err      = OS_ERR_STATUS_INVALID;
   \   00000184   0xF646 0x612E      MOVW     R1,#+28206
   \   00000188   0xF8A9 0x1000      STRH     R1,[R9, #+0]
    594                       break;
    595              }
    596              CPU_CRITICAL_EXIT();
   \                     ??OSQPend_17: (+1)
   \   0000018C   0x.... 0x....      BL       CPU_SR_Restore
    597              OS_TRACE_Q_PEND_EXIT(*p_err);
    598              return (p_void);
   \   00000190   0x0028             MOVS     R0,R5
   \                     ??OSQPend_1: (+1)
   \   00000192   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    599          }
    600          
    601          
    602          /*
    603          ************************************************************************************************************************
    604          *                                             ABORT WAITING ON A MESSAGE QUEUE
    605          *
    606          * Description: This function aborts & readies any tasks currently waiting on a queue.  This function should be used to
    607          *              fault-abort the wait on the queue, rather than to normally signal the queue via OSQPost().
    608          *
    609          * Arguments  : p_q       is a pointer to the message queue
    610          *
    611          *              opt       determines the type of ABORT performed:
    612          *
    613          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the queue
    614          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the queue
    615          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    616          *
    617          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    618          *
    619          *                            OS_ERR_NONE                  At least one task waiting on the queue was readied and
    620          *                                                         informed of the aborted wait; check return value for the
    621          *                                                         number of tasks whose wait on the queue was aborted
    622          *                            OS_ERR_OBJ_PTR_NULL          If you pass a NULL pointer for 'p_q'
    623          *                            OS_ERR_OBJ_TYPE              If the message queue was not created
    624          *                            OS_ERR_OPT_INVALID           You specified an invalid option
    625          *                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    626          *                            OS_ERR_PEND_ABORT_ISR        If this function was called from an ISR
    627          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    628          *
    629          * Returns    : == 0      if no tasks were waiting on the queue, or upon error.
    630          *              >  0      if one or more tasks waiting on the queue are now readied and informed.
    631          *
    632          * Note(s)    : none
    633          ************************************************************************************************************************
    634          */
    635          
    636          #if (OS_CFG_Q_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    637          OS_OBJ_QTY  OSQPendAbort (OS_Q    *p_q,
    638                                    OS_OPT   opt,
    639                                    OS_ERR  *p_err)
    640          {
   \                     OSQPendAbort: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    641              OS_PEND_LIST  *p_pend_list;
    642              OS_TCB        *p_tcb;
    643              CPU_TS         ts;
    644              OS_OBJ_QTY     nbr_tasks;
    645              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    646          
    647          
    648          #ifdef OS_SAFETY_CRITICAL
    649              if (p_err == (OS_ERR *)0) {
    650                  OS_SAFETY_CRITICAL_EXCEPTION();
    651                  return (0u);
    652              }
    653          #endif
    654          
    655          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    656              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000C   0x....             LDR.N    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSQPendAbort_0
    657                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    658                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE059             B.N      ??OSQPendAbort_1
    659              }
    660          #endif
    661          
    662          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    663              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSQPendAbort_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable6_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSQPendAbort_2
    664                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    665                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE050             B.N      ??OSQPendAbort_1
    666              }
    667          #endif
    668          
    669          #if (OS_CFG_ARG_CHK_EN > 0u)
    670              if (p_q == (OS_Q *)0) {                                     /* Validate 'p_q'                                       */
   \                     ??OSQPendAbort_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE.N    ??OSQPendAbort_3
    671                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    672                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE049             B.N      ??OSQPendAbort_1
    673              }
    674              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSQPendAbort_3: (+1)
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD008             BEQ.N    ??OSQPendAbort_4
   \   00000046   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004A   0xD005             BEQ.N    ??OSQPendAbort_4
   \   0000004C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000050   0xD002             BEQ.N    ??OSQPendAbort_4
   \   00000052   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000056   0xD113             BNE.N    ??OSQPendAbort_5
    675                  case OS_OPT_PEND_ABORT_1:
    676                  case OS_OPT_PEND_ABORT_ALL:
    677                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    678                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    679                       break;
    680          
    681                  default:
    682                      *p_err =  OS_ERR_OPT_INVALID;
    683                       return (0u);
    684              }
    685          #endif
    686          
    687          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    688              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure queue was created                          */
   \                     ??OSQPendAbort_4: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x55455551
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD114             BNE.N    ??OSQPendAbort_6
    689                 *p_err =  OS_ERR_OBJ_TYPE;
    690                  return (0u);
    691              }
    692          #endif
    693          
    694              CPU_CRITICAL_ENTER();
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x.... 0x....      BL       CPU_SR_Save
   \   00000066   0x0007             MOVS     R7,R0
    695              p_pend_list = &p_q->PendList;
   \   00000068   0x1D24             ADDS     R4,R4,#+4
    696              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on queue?                           */
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD111             BNE.N    ??OSQPendAbort_7
    697                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    698                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000076   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000007A   0x8028             STRH     R0,[R5, #+0]
    699                  return (0u);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE028             B.N      ??OSQPendAbort_1
    700              }
   \                     ??OSQPendAbort_5: (+1)
   \   00000080   0xF645 0x6025      MOVW     R0,#+24101
   \   00000084   0x8028             STRH     R0,[R5, #+0]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE023             B.N      ??OSQPendAbort_1
   \                     ??OSQPendAbort_6: (+1)
   \   0000008A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE01E             B.N      ??OSQPendAbort_1
    701          
    702              nbr_tasks = 0u;
   \                     ??OSQPendAbort_7: (+1)
   \   00000094   0xF05F 0x0900      MOVS     R9,#+0
    703          #if (OS_CFG_TS_EN > 0u)
    704              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
    705          #else
    706              ts        = 0u;
   \   00000098   0xF05F 0x0800      MOVS     R8,#+0
    707          #endif
    708              while (p_pend_list->HeadPtr != (OS_TCB *)0) {
   \                     ??OSQPendAbort_8: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD00B             BEQ.N    ??OSQPendAbort_9
    709                  p_tcb = p_pend_list->HeadPtr;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
    710                  OS_PendAbort(p_tcb,
    711                               ts,
    712                               OS_STATUS_PEND_ABORT);
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0x4641             MOV      R1,R8
   \   000000A8   0x.... 0x....      BL       OS_PendAbort
    713                  nbr_tasks++;
   \   000000AC   0xF119 0x0901      ADDS     R9,R9,#+1
    714                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000B8   0xD0F0             BEQ.N    ??OSQPendAbort_8
    715                      break;                                              /* No                                                   */
    716                  }
    717              }
    718              CPU_CRITICAL_EXIT();
   \                     ??OSQPendAbort_9: (+1)
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    719          
    720              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000C0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C2   0x0430             LSLS     R0,R6,#+16
   \   000000C4   0xD401             BMI.N    ??OSQPendAbort_10
    721                  OSSched();                                              /* Run the scheduler                                    */
   \   000000C6   0x.... 0x....      BL       OSSched
    722              }
    723          
    724             *p_err = OS_ERR_NONE;
   \                     ??OSQPendAbort_10: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    725              return (nbr_tasks);
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSQPendAbort_1: (+1)
   \   000000D2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    726          }
    727          #endif
    728          
    729          
    730          /*
    731          ************************************************************************************************************************
    732          *                                               POST MESSAGE TO A QUEUE
    733          *
    734          * Description: This function sends a message to a queue.  With the 'opt' argument, you can specify whether the message
    735          *              is broadcast to all waiting tasks and/or whether you post the message to the front of the queue (LIFO)
    736          *              or normally (FIFO) at the end of the queue.
    737          *
    738          * Arguments  : p_q           is a pointer to a message queue that must have been created by OSQCreate().
    739          *
    740          *              p_void        is a pointer to the message to send.
    741          *
    742          *              msg_size      specifies the size of the message (in bytes)
    743          *
    744          *              opt           determines the type of POST performed:
    745          *
    746          *                                OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the queue.  This option
    747          *                                                         can be added to either OS_OPT_POST_FIFO or OS_OPT_POST_LIFO
    748          *                                OS_OPT_POST_FIFO         POST message to end of queue (FIFO) and wake up a single
    749          *                                                         waiting task.
    750          *                                OS_OPT_POST_LIFO         POST message to the front of the queue (LIFO) and wake up
    751          *                                                         a single waiting task.
    752          *                                OS_OPT_POST_NO_SCHED     Do not call the scheduler
    753          *
    754          *                            Note(s): 1) OS_OPT_POST_NO_SCHED can be added (or OR'd) with one of the other options.
    755          *                                     2) OS_OPT_POST_ALL      can be added (or OR'd) with one of the other options.
    756          *                                     3) Possible combination of options are:
    757          *
    758          *                                        OS_OPT_POST_FIFO
    759          *                                        OS_OPT_POST_LIFO
    760          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL
    761          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL
    762          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_NO_SCHED
    763          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_NO_SCHED
    764          *                                        OS_OPT_POST_FIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    765          *                                        OS_OPT_POST_LIFO + OS_OPT_POST_ALL + OS_OPT_POST_NO_SCHED
    766          *
    767          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    768          *
    769          *                                OS_ERR_NONE              The call was successful and the message was sent
    770          *                                OS_ERR_MSG_POOL_EMPTY    If there are no more OS_MSGs to use to place the message into
    771          *                                OS_ERR_OBJ_PTR_NULL      If 'p_q' is a NULL pointer
    772          *                                OS_ERR_OBJ_TYPE          If the message queue was not initialized
    773          *                                OS_ERR_OPT_INVALID       You specified an invalid option
    774          *                                OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    775          *                                OS_ERR_Q_MAX             If the queue is full
    776          *
    777          * Returns    : None
    778          *
    779          * Note(s)    : none
    780          ************************************************************************************************************************
    781          */
    782          

   \                                 In section .text, align 2, keep-with-next
    783          void  OSQPost (OS_Q         *p_q,
    784                         void         *p_void,
    785                         OS_MSG_SIZE   msg_size,
    786                         OS_OPT        opt,
    787                         OS_ERR       *p_err)
    788          {
   \                     OSQPost: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xF8DD 0x8030      LDR      R8,[SP, #+48]
    789              OS_OPT         post_type;
    790              OS_PEND_LIST  *p_pend_list;
    791              OS_TCB        *p_tcb;
    792              OS_TCB        *p_tcb_next;
    793              CPU_TS         ts;
    794              CPU_SR_ALLOC();
   \   00000008   0x2400             MOVS     R4,#+0
    795          
    796          
    797          #ifdef OS_SAFETY_CRITICAL
    798              if (p_err == (OS_ERR *)0) {
    799                  OS_SAFETY_CRITICAL_EXCEPTION();
    800                  return;
    801              }
    802          #endif
    803          
    804              OS_TRACE_Q_POST_ENTER(p_q, p_void, msg_size, opt);
    805          
    806          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    807              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   0000000A   0x....             LDR.N    R4,??DataTable6_2
   \   0000000C   0x7824             LDRB     R4,[R4, #+0]
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??OSQPost_0
    808                  OS_TRACE_Q_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    809                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000012   0xF645 0x6089      MOVW     R0,#+24201
   \   00000016   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    810                  return;
   \   0000001A   0xE070             B.N      ??OSQPost_1
    811              }
   \                     ??OSQPost_0: (+1)
   \   0000001C   0x0004             MOVS     R4,R0
    812          #endif
    813          
    814          #if (OS_CFG_ARG_CHK_EN > 0u)
    815              if (p_q == (OS_Q *)0) {                                     /* Validate 'p_q'                                       */
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD104             BNE.N    ??OSQPost_2
    816                  OS_TRACE_Q_POST_FAILED(p_q);
    817                  OS_TRACE_Q_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    818                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    819                  return;
   \   0000002A   0xE068             B.N      ??OSQPost_1
    820              }
   \                     ??OSQPost_2: (+1)
   \   0000002C   0x001F             MOVS     R7,R3
    821              switch (opt) {                                              /* Validate 'opt'                                       */
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD015             BEQ.N    ??OSQPost_3
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD013             BEQ.N    ??OSQPost_3
   \   0000003A   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000003E   0xD010             BEQ.N    ??OSQPost_3
   \   00000040   0xF5B0 0x7F04      CMP      R0,#+528
   \   00000044   0xD00D             BEQ.N    ??OSQPost_3
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xD00A             BEQ.N    ??OSQPost_3
   \   0000004C   0xF248 0x0310      MOVW     R3,#+32784
   \   00000050   0x4298             CMP      R0,R3
   \   00000052   0xD006             BEQ.N    ??OSQPost_3
   \   00000054   0xF5B0 0x4F02      CMP      R0,#+33280
   \   00000058   0xD003             BEQ.N    ??OSQPost_3
   \   0000005A   0xF248 0x2310      MOVW     R3,#+33296
   \   0000005E   0x4298             CMP      R0,R3
   \   00000060   0xD114             BNE.N    ??OSQPost_4
    822                  case OS_OPT_POST_FIFO:
    823                  case OS_OPT_POST_LIFO:
    824                  case OS_OPT_POST_FIFO | OS_OPT_POST_ALL:
    825                  case OS_OPT_POST_LIFO | OS_OPT_POST_ALL:
    826                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
    827                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
    828                  case OS_OPT_POST_FIFO | (OS_OPT)(OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED):
    829                  case OS_OPT_POST_LIFO | (OS_OPT)(OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED):
    830                       break;
    831          
    832                  default:
    833                       OS_TRACE_Q_POST_FAILED(p_q);
    834                       OS_TRACE_Q_POST_EXIT(OS_ERR_OPT_INVALID);
    835                      *p_err =  OS_ERR_OPT_INVALID;
    836                       return;
    837              }
    838          #endif
    839          
    840          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    841              if (p_q->Type != OS_OBJ_TYPE_Q) {                           /* Make sure message queue was created                  */
   \                     ??OSQPost_3: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x....             LDR.N    R3,??DataTable6_1  ;; 0x55455551
   \   00000066   0x4298             CMP      R0,R3
   \   00000068   0xD115             BNE.N    ??OSQPost_5
   \   0000006A   0x0016             MOVS     R6,R2
   \   0000006C   0x000D             MOVS     R5,R1
    842                  OS_TRACE_Q_POST_FAILED(p_q);
    843                  OS_TRACE_Q_POST_EXIT(OS_ERR_OBJ_TYPE);
    844                 *p_err = OS_ERR_OBJ_TYPE;
    845                  return;
    846              }
    847          #endif
    848          #if (OS_CFG_TS_EN > 0u)
    849              ts = OS_TS_GET();                                           /* Get timestamp                                        */
    850          #else
    851              ts = 0u;
   \   0000006E   0xF05F 0x0900      MOVS     R9,#+0
    852          #endif
    853          
    854              OS_TRACE_Q_POST(p_q);
    855          
    856              CPU_CRITICAL_ENTER();
   \   00000072   0x2040             MOVS     R0,#+64
   \   00000074   0x.... 0x....      BL       CPU_SR_Save
   \   00000078   0x4682             MOV      R10,R0
    857              p_pend_list = &p_q->PendList;
   \   0000007A   0x1D21             ADDS     R1,R4,#+4
    858              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on message queue?                   */
   \   0000007C   0x6808             LDR      R0,[R1, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD11F             BNE.N    ??OSQPost_6
    859                  if ((opt & OS_OPT_POST_LIFO) == 0u) {                   /* Determine whether we post FIFO or LIFO               */
   \   00000082   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000084   0x06F8             LSLS     R0,R7,#+27
   \   00000086   0xD40B             BMI.N    ??OSQPost_7
    860                      post_type = OS_OPT_POST_FIFO;
   \   00000088   0x2300             MOVS     R3,#+0
   \   0000008A   0xE00A             B.N      ??OSQPost_8
    861                  } else {
   \                     ??OSQPost_4: (+1)
   \   0000008C   0xF645 0x6025      MOVW     R0,#+24101
   \   00000090   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000094   0xE033             B.N      ??OSQPost_1
   \                     ??OSQPost_5: (+1)
   \   00000096   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000009A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000009E   0xE02E             B.N      ??OSQPost_1
    862                      post_type = OS_OPT_POST_LIFO;
   \                     ??OSQPost_7: (+1)
   \   000000A0   0x2310             MOVS     R3,#+16
    863                  }
    864                  OS_MsgQPut(&p_q->MsgQ,                                  /* Place message in the message queue                   */
    865                             p_void,
    866                             msg_size,
    867                             post_type,
    868                             ts,
    869                             p_err);
   \                     ??OSQPost_8: (+1)
   \   000000A2   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000A6   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000AA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000AC   0x0032             MOVS     R2,R6
   \   000000AE   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000B0   0x0029             MOVS     R1,R5
   \   000000B2   0xF114 0x000C      ADDS     R0,R4,#+12
   \   000000B6   0x.... 0x....      BL       OS_MsgQPut
    870                  CPU_CRITICAL_EXIT();
   \   000000BA   0x4650             MOV      R0,R10
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    871                  OS_TRACE_Q_POST_EXIT(*p_err);
    872                  return;
   \   000000C0   0xE01D             B.N      ??OSQPost_1
    873              }
    874          
    875              p_tcb = p_pend_list->HeadPtr;
   \                     ??OSQPost_6: (+1)
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0xE000             B.N      ??OSQPost_9
    876              while (p_tcb != (OS_TCB *)0) {
    877                  p_tcb_next = p_tcb->PendNextPtr;
    878                  OS_Post((OS_PEND_OBJ *)((void *)p_q),
    879                          p_tcb,
    880                          p_void,
    881                          msg_size,
    882                          ts);
    883                  if ((opt & OS_OPT_POST_ALL) == 0u)  {                   /* Post message to all tasks waiting?                   */
    884                      break;                                              /* No                                                   */
    885                  }
    886                  p_tcb = p_tcb_next;
   \                     ??OSQPost_10: (+1)
   \   000000C6   0x4659             MOV      R1,R11
   \                     ??OSQPost_9: (+1)
   \   000000C8   0x2900             CMP      R1,#+0
   \   000000CA   0xD00D             BEQ.N    ??OSQPost_11
   \   000000CC   0xF8D1 0xB020      LDR      R11,[R1, #+32]
   \   000000D0   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000D4   0x0033             MOVS     R3,R6
   \   000000D6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000D8   0x002A             MOVS     R2,R5
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       OS_Post
   \   000000E0   0x0038             MOVS     R0,R7
   \   000000E2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E4   0x0580             LSLS     R0,R0,#+22
   \   000000E6   0xD4EE             BMI.N    ??OSQPost_10
    887              }
    888          
    889              CPU_CRITICAL_EXIT();
   \                     ??OSQPost_11: (+1)
   \   000000E8   0x4650             MOV      R0,R10
   \   000000EA   0x.... 0x....      BL       CPU_SR_Restore
    890          
    891              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000EE   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000F0   0x0438             LSLS     R0,R7,#+16
   \   000000F2   0xD401             BMI.N    ??OSQPost_12
    892                  OSSched();                                              /* Run the scheduler                                    */
   \   000000F4   0x.... 0x....      BL       OSSched
    893              }
    894          
    895             *p_err = OS_ERR_NONE;
   \                     ??OSQPost_12: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    896              OS_TRACE_Q_POST_EXIT(*p_err);
    897          }
   \                     ??OSQPost_1: (+1)
   \   000000FE   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    898          
    899          
    900          /*
    901          ************************************************************************************************************************
    902          *                                        CLEAR THE CONTENTS OF A MESSAGE QUEUE
    903          *
    904          * Description: This function is called by OSQDel() to clear the contents of a message queue
    905          *
    906          
    907          * Argument(s): p_q      is a pointer to the queue to clear
    908          *              ---
    909          *
    910          * Returns    : none
    911          *
    912          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    913          ************************************************************************************************************************
    914          */
    915          

   \                                 In section .text, align 2, keep-with-next
    916          void  OS_QClr (OS_Q  *p_q)
    917          {
   \                     OS_QClr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    918              (void)OS_MsgQFreeAll(&p_q->MsgQ);                           /* Return all OS_MSGs to the free list                  */
   \   00000004   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000008   0x.... 0x....      BL       OS_MsgQFreeAll
    919          #if (OS_OBJ_TYPE_REQ > 0u)
    920              p_q->Type    =  OS_OBJ_TYPE_NONE;                           /* Mark the data structure as a NONE                    */
   \   0000000C   0x....             LDR.N    R0,??DataTable6_5  ;; 0x454e4f4e
   \   0000000E   0x6020             STR      R0,[R4, #+0]
    921          #endif
    922          #if (OS_CFG_DBG_EN > 0u)
    923              p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
    924          #endif
    925              OS_MsgQInit(&p_q->MsgQ,                                     /* Initialize the list of OS_MSGs                       */
    926                          0u);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xF114 0x000C      ADDS     R0,R4,#+12
   \   00000016   0x.... 0x....      BL       OS_MsgQInit
    927              OS_PendListInit(&p_q->PendList);                            /* Initialize the waiting list                          */
   \   0000001A   0x1D20             ADDS     R0,R4,#+4
   \   0000001C   0x.... 0x....      BL       OS_PendListInit
    928          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x55455551         DC32     0x55455551

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e
    929          
    930          
    931          /*
    932          ************************************************************************************************************************
    933          *                                      ADD/REMOVE MESSAGE QUEUE TO/FROM DEBUG LIST
    934          *
    935          * Description: These functions are called by uC/OS-III to add or remove a message queue to/from a message queue debug
    936          *              list.
    937          *
    938          * Arguments  : p_q     is a pointer to the message queue to add/remove
    939          *
    940          * Returns    : none
    941          *
    942          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    943          ************************************************************************************************************************
    944          */
    945          
    946          #if (OS_CFG_DBG_EN > 0u)
    947          void  OS_QDbgListAdd (OS_Q  *p_q)
    948          {
    949              p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    950              p_q->DbgPrevPtr               = (OS_Q *)0;
    951              if (OSQDbgListPtr == (OS_Q *)0) {
    952                  p_q->DbgNextPtr           = (OS_Q *)0;
    953              } else {
    954                  p_q->DbgNextPtr           =  OSQDbgListPtr;
    955                  OSQDbgListPtr->DbgPrevPtr =  p_q;
    956              }
    957              OSQDbgListPtr                 =  p_q;
    958          }
    959          
    960          
    961          void  OS_QDbgListRemove (OS_Q  *p_q)
    962          {
    963              OS_Q  *p_q_next;
    964              OS_Q  *p_q_prev;
    965          
    966          
    967              p_q_prev = p_q->DbgPrevPtr;
    968              p_q_next = p_q->DbgNextPtr;
    969          
    970              if (p_q_prev == (OS_Q *)0) {
    971                  OSQDbgListPtr = p_q_next;
    972                  if (p_q_next != (OS_Q *)0) {
    973                      p_q_next->DbgPrevPtr = (OS_Q *)0;
    974                  }
    975                  p_q->DbgNextPtr = (OS_Q *)0;
    976          
    977              } else if (p_q_next == (OS_Q *)0) {
    978                  p_q_prev->DbgNextPtr = (OS_Q *)0;
    979                  p_q->DbgPrevPtr      = (OS_Q *)0;
    980          
    981              } else {
    982                  p_q_prev->DbgNextPtr =  p_q_next;
    983                  p_q_next->DbgPrevPtr =  p_q_prev;
    984                  p_q->DbgNextPtr      = (OS_Q *)0;
    985                  p_q->DbgPrevPtr      = (OS_Q *)0;
    986              }
    987          }
    988          #endif
    989          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSQCreate
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_MsgQInit
        24   -> OS_PendListInit
      32   OSQDel
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
        32   -> OS_QClr
      16   OSQFlush
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_MsgQFreeAll
      32   OSQPend
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_MsgQGet
        32   -> OS_Pend
      32   OSQPendAbort
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      48   OSQPost
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OS_MsgQPut
        48   -> OS_Post
       8   OS_QClr
         8   -> OS_MsgQFreeAll
         8   -> OS_MsgQInit
         8   -> OS_PendListInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
     124  OSQCreate
     228  OSQDel
     116  OSQFlush
     406  OSQPend
     214  OSQPendAbort
     258  OSQPost
      34  OS_QClr

 
 1 404 bytes in section .text
 
 1 404 bytes of CODE memory

Errors: none
Warnings: none
