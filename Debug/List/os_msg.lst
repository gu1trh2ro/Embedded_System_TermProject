###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  11:44:50
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_msg.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW2937.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_msg.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_msg.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_msg.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_msg.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                       MESSAGE HANDLING SERVICES
     20          *
     21          * File    : os_msg.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_msg__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_MSG_EN > 0u)
     35          
     36          /*
     37          ************************************************************************************************************************
     38          *                                            INITIALIZE THE POOL OF 'OS_MSG'
     39          *
     40          * Description: This function is called by OSInit() to initialize the free list of OS_MSGs.
     41          *
     42          * Argument(s): p_err     is a pointer to a variable that will contain an error code returned by this function.
     43          *
     44          *                            OS_ERR_MSG_POOL_NULL_PTR
     45          *                            OS_ERR_MSG_POOL_EMPTY
     46          *                            OS_ERR_NONE
     47          *
     48          * Returns    : none
     49          *
     50          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
     51          ************************************************************************************************************************
     52          */
     53          

   \                                 In section .text, align 2, keep-with-next
     54          void  OS_MsgPoolInit (OS_ERR  *p_err)
     55          {
   \                     OS_MsgPoolInit: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
     56              OS_MSG      *p_msg1;
     57              OS_MSG      *p_msg2;
     58              OS_MSG_QTY   i;
     59              OS_MSG_QTY   loops;
     60          
     61          
     62          #if (OS_CFG_ARG_CHK_EN > 0u)
     63              if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
   \   00000002   0x....             LDR.N    R1,??DataTable3
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE.N    ??OS_MsgPoolInit_0
     64                 *p_err = OS_ERR_MSG_POOL_NULL_PTR;
   \   0000000A   0xF245 0x711E      MOVW     R1,#+22302
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
     65                  return;
   \   00000010   0xE032             B.N      ??OS_MsgPoolInit_1
     66              }
     67              if (OSCfg_MsgPoolSize == 0u) {
   \                     ??OS_MsgPoolInit_0: (+1)
   \   00000012   0x....             LDR.N    R1,??DataTable3_1
   \   00000014   0x8809             LDRH     R1,[R1, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD103             BNE.N    ??OS_MsgPoolInit_2
     68                 *p_err = OS_ERR_MSG_POOL_EMPTY;
   \   0000001A   0xF245 0x711D      MOVW     R1,#+22301
   \   0000001E   0x8001             STRH     R1,[R0, #+0]
     69                  return;
   \   00000020   0xE02A             B.N      ??OS_MsgPoolInit_1
     70              }
     71          #endif
     72          
     73              p_msg1 = OSCfg_MsgPoolBasePtr;
   \                     ??OS_MsgPoolInit_2: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable3
   \   00000024   0x6809             LDR      R1,[R1, #+0]
     74              p_msg2 = OSCfg_MsgPoolBasePtr;
   \   00000026   0x....             LDR.N    R2,??DataTable3
   \   00000028   0x6812             LDR      R2,[R2, #+0]
     75              p_msg2++;
   \   0000002A   0x320C             ADDS     R2,R2,#+12
     76              loops  = OSCfg_MsgPoolSize - 1u;
   \   0000002C   0x....             LDR.N    R3,??DataTable3_1
   \   0000002E   0x881B             LDRH     R3,[R3, #+0]
   \   00000030   0x1E5C             SUBS     R4,R3,#+1
     77              for (i = 0u; i < loops; i++) {                              /* Init. list of free OS_MSGs                           */
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0xE007             B.N      ??OS_MsgPoolInit_3
     78                  p_msg1->NextPtr = p_msg2;
   \                     ??OS_MsgPoolInit_4: (+1)
   \   00000036   0x600A             STR      R2,[R1, #+0]
     79                  p_msg1->MsgPtr  = (void *)0;
   \   00000038   0x2500             MOVS     R5,#+0
   \   0000003A   0x604D             STR      R5,[R1, #+4]
     80                  p_msg1->MsgSize =         0u;
   \   0000003C   0x2500             MOVS     R5,#+0
   \   0000003E   0x810D             STRH     R5,[R1, #+8]
     81          #if (OS_CFG_TS_EN > 0u)
     82                  p_msg1->MsgTS   =         0u;
     83          #endif
     84                  p_msg1++;
   \   00000040   0x310C             ADDS     R1,R1,#+12
     85                  p_msg2++;
   \   00000042   0x320C             ADDS     R2,R2,#+12
     86              }
   \   00000044   0x1C5B             ADDS     R3,R3,#+1
   \                     ??OS_MsgPoolInit_3: (+1)
   \   00000046   0x001D             MOVS     R5,R3
   \   00000048   0x0026             MOVS     R6,R4
   \   0000004A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000004E   0x42B5             CMP      R5,R6
   \   00000050   0xD3F1             BCC.N    ??OS_MsgPoolInit_4
     87              p_msg1->NextPtr = (OS_MSG *)0;                              /* Last OS_MSG                                          */
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x600A             STR      R2,[R1, #+0]
     88              p_msg1->MsgPtr  = (void   *)0;
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x604A             STR      R2,[R1, #+4]
     89              p_msg1->MsgSize =           0u;
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x810A             STRH     R2,[R1, #+8]
     90          #if (OS_CFG_TS_EN > 0u)
     91              p_msg1->MsgTS   =           0u;
     92          #endif
     93          
     94              OSMsgPool.NextPtr    = OSCfg_MsgPoolBasePtr;
   \   0000005E   0x....             LDR.N    R1,??DataTable3
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x....             LDR.N    R2,??DataTable3_2
   \   00000064   0x6011             STR      R1,[R2, #+0]
     95              OSMsgPool.NbrFree    = OSCfg_MsgPoolSize;
   \   00000066   0x....             LDR.N    R1,??DataTable3_1
   \   00000068   0x8809             LDRH     R1,[R1, #+0]
   \   0000006A   0x....             LDR.N    R2,??DataTable3_2
   \   0000006C   0x8091             STRH     R1,[R2, #+4]
     96              OSMsgPool.NbrUsed    = 0u;
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x....             LDR.N    R2,??DataTable3_2
   \   00000072   0x80D1             STRH     R1,[R2, #+6]
     97          #if (OS_CFG_DBG_EN > 0u)
     98              OSMsgPool.NbrUsedMax = 0u;
     99          #endif
    100             *p_err                = OS_ERR_NONE;
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x8001             STRH     R1,[R0, #+0]
    101          }
   \                     ??OS_MsgPoolInit_1: (+1)
   \   00000078   0xBC70             POP      {R4-R6}
   \   0000007A   0x4770             BX       LR               ;; return
    102          
    103          
    104          /*
    105          ************************************************************************************************************************
    106          *                                        RELEASE ALL MESSAGE IN MESSAGE QUEUE
    107          *
    108          * Description: This function returns all the messages in a message queue to the free list.
    109          *
    110          * Arguments  : p_msg_q       is a pointer to the OS_MSG_Q structure containing messages to free.
    111          *              -------
    112          *
    113          * Returns    : the number of OS_MSGs returned to the free list
    114          *
    115          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    116          ************************************************************************************************************************
    117          */
    118          

   \                                 In section .text, align 2, keep-with-next
    119          OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
    120          {
    121              OS_MSG      *p_msg;
    122              OS_MSG_QTY   qty;
    123          
    124          
    125          
    126              qty = p_msg_q->NbrEntries;                                  /* Get the number of OS_MSGs being freed                */
   \                     OS_MsgQFreeAll: (+1)
   \   00000000   0x8941             LDRH     R1,[R0, #+10]
    127              if (p_msg_q->NbrEntries > 0u) {
   \   00000002   0x8942             LDRH     R2,[R0, #+10]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD018             BEQ.N    ??OS_MsgQFreeAll_0
    128                  p_msg                   = p_msg_q->InPtr;               /* Point to end of message chain                        */
   \   00000008   0x6802             LDR      R2,[R0, #+0]
    129                  p_msg->NextPtr          = OSMsgPool.NextPtr;
   \   0000000A   0x....             LDR.N    R3,??DataTable3_2
   \   0000000C   0x681B             LDR      R3,[R3, #+0]
   \   0000000E   0x6013             STR      R3,[R2, #+0]
    130                  OSMsgPool.NextPtr       = p_msg_q->OutPtr;              /* Point to beginning of message chain                  */
   \   00000010   0x6842             LDR      R2,[R0, #+4]
   \   00000012   0x....             LDR.N    R3,??DataTable3_2
   \   00000014   0x601A             STR      R2,[R3, #+0]
    131                  OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;          /* Update statistics for free list of messages          */
   \   00000016   0x....             LDR.N    R2,??DataTable3_2
   \   00000018   0x88D3             LDRH     R3,[R2, #+6]
   \   0000001A   0x8942             LDRH     R2,[R0, #+10]
   \   0000001C   0x1A9B             SUBS     R3,R3,R2
   \   0000001E   0x....             LDR.N    R2,??DataTable3_2
   \   00000020   0x80D3             STRH     R3,[R2, #+6]
    132                  OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
   \   00000022   0x....             LDR.N    R2,??DataTable3_2
   \   00000024   0x8893             LDRH     R3,[R2, #+4]
   \   00000026   0x8942             LDRH     R2,[R0, #+10]
   \   00000028   0x18D3             ADDS     R3,R2,R3
   \   0000002A   0x....             LDR.N    R2,??DataTable3_2
   \   0000002C   0x8093             STRH     R3,[R2, #+4]
    133                  p_msg_q->NbrEntries     =           0u;                 /* Flush the message queue                              */
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x8142             STRH     R2,[R0, #+10]
    134          #if (OS_CFG_DBG_EN > 0u)
    135                  p_msg_q->NbrEntriesMax  =           0u;
    136          #endif
    137                  p_msg_q->InPtr          = (OS_MSG *)0;
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x6002             STR      R2,[R0, #+0]
    138                  p_msg_q->OutPtr         = (OS_MSG *)0;
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x6042             STR      R2,[R0, #+4]
    139              }
    140              return (qty);
   \                     ??OS_MsgQFreeAll_0: (+1)
   \   0000003A   0x0008             MOVS     R0,R1
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x4770             BX       LR               ;; return
    141          }
    142          
    143          
    144          /*
    145          ************************************************************************************************************************
    146          *                                               INITIALIZE A MESSAGE QUEUE
    147          *
    148          * Description: This function is called to initialize a message queue
    149          *
    150          * Arguments  : p_msg_q      is a pointer to the message queue to initialize
    151          *              -------
    152          *
    153          *              size          is the maximum number of entries that a message queue can have.
    154          *
    155          * Returns    : none
    156          *
    157          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    158          ************************************************************************************************************************
    159          */
    160          

   \                                 In section .text, align 2, keep-with-next
    161          void  OS_MsgQInit (OS_MSG_Q    *p_msg_q,
    162                             OS_MSG_QTY   size)
    163          {
    164              p_msg_q->NbrEntriesSize = size;
   \                     OS_MsgQInit: (+1)
   \   00000000   0x8101             STRH     R1,[R0, #+8]
    165              p_msg_q->NbrEntries     =           0u;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8141             STRH     R1,[R0, #+10]
    166          #if (OS_CFG_DBG_EN > 0u)
    167              p_msg_q->NbrEntriesMax  =           0u;
    168          #endif
    169              p_msg_q->InPtr          = (OS_MSG *)0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
    170              p_msg_q->OutPtr         = (OS_MSG *)0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    171          }
   \   0000000E   0x4770             BX       LR               ;; return
    172          
    173          
    174          /*
    175          ************************************************************************************************************************
    176          *                                           RETRIEVE MESSAGE FROM MESSAGE QUEUE
    177          *
    178          * Description: This function retrieves a message from a message queue
    179          *
    180          * Arguments  : p_msg_q     is a pointer to the message queue where we want to extract the message from
    181          *              -------
    182          *
    183          *              p_msg_size  is a pointer to where the size (in bytes) of the message will be placed
    184          *
    185          *              p_ts        is a pointer to where the time stamp will be placed
    186          *
    187          *              p_err       is a pointer to an error code that will be returned from this call.
    188          *
    189          *                              OS_ERR_Q_EMPTY
    190          *                              OS_ERR_NONE
    191          *
    192          * Returns    : The message (a pointer)
    193          *
    194          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    195          ************************************************************************************************************************
    196          */
    197          

   \                                 In section .text, align 2, keep-with-next
    198          void  *OS_MsgQGet (OS_MSG_Q     *p_msg_q,
    199                             OS_MSG_SIZE  *p_msg_size,
    200                             CPU_TS       *p_ts,
    201                             OS_ERR       *p_err)
    202          {
   \                     OS_MsgQGet: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    203              OS_MSG  *p_msg;
    204              void    *p_void;
    205          
    206          
    207          #if (OS_CFG_TS_EN == 0u)
    208              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
    209          #endif
    210          
    211              if (p_msg_q->NbrEntries == 0u) {                            /* Is the queue empty?                                  */
   \   00000002   0x8942             LDRH     R2,[R0, #+10]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD106             BNE.N    ??OS_MsgQGet_0
    212                 *p_msg_size = 0u;                                        /* Yes                                                  */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x8008             STRH     R0,[R1, #+0]
    213          #if (OS_CFG_TS_EN > 0u)
    214                  if (p_ts != (CPU_TS *)0) {
    215                     *p_ts = 0u;
    216                  }
    217          #endif
    218                 *p_err = OS_ERR_Q_EMPTY;
   \   0000000C   0xF246 0x5092      MOVW     R0,#+26002
   \   00000010   0x8018             STRH     R0,[R3, #+0]
    219                  return ((void *)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE022             B.N      ??OS_MsgQGet_1
    220              }
    221          
    222              p_msg           = p_msg_q->OutPtr;                          /* No, get the next message to extract from the queue   */
   \                     ??OS_MsgQGet_0: (+1)
   \   00000016   0x6844             LDR      R4,[R0, #+4]
    223              p_void          = p_msg->MsgPtr;
   \   00000018   0x6862             LDR      R2,[R4, #+4]
    224             *p_msg_size      = p_msg->MsgSize;
   \   0000001A   0x8925             LDRH     R5,[R4, #+8]
   \   0000001C   0x800D             STRH     R5,[R1, #+0]
    225          #if (OS_CFG_TS_EN > 0u)
    226              if (p_ts != (CPU_TS *)0) {
    227                 *p_ts = p_msg->MsgTS;
    228              }
    229          #endif
    230          
    231              p_msg_q->OutPtr = p_msg->NextPtr;                           /* Point to next message to extract                     */
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x6041             STR      R1,[R0, #+4]
    232          
    233              if (p_msg_q->OutPtr == (OS_MSG *)0) {                       /* Are there any more messages in the queue?            */
   \   00000022   0x6841             LDR      R1,[R0, #+4]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD104             BNE.N    ??OS_MsgQGet_2
    234                  p_msg_q->InPtr      = (OS_MSG *)0;                      /* No                                                   */
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    235                  p_msg_q->NbrEntries =           0u;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x8141             STRH     R1,[R0, #+10]
   \   00000030   0xE002             B.N      ??OS_MsgQGet_3
    236              } else {
    237                  p_msg_q->NbrEntries--;                                  /* Yes, One less message in the queue                   */
   \                     ??OS_MsgQGet_2: (+1)
   \   00000032   0x8941             LDRH     R1,[R0, #+10]
   \   00000034   0x1E49             SUBS     R1,R1,#+1
   \   00000036   0x8141             STRH     R1,[R0, #+10]
    238              }
    239          
    240              p_msg->NextPtr    = OSMsgPool.NextPtr;                      /* Return message control block to free list            */
   \                     ??OS_MsgQGet_3: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable3_2
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x6020             STR      R0,[R4, #+0]
    241              OSMsgPool.NextPtr = p_msg;
   \   0000003E   0x....             LDR.N    R0,??DataTable3_2
   \   00000040   0x6004             STR      R4,[R0, #+0]
    242              OSMsgPool.NbrFree++;
   \   00000042   0x....             LDR.N    R0,??DataTable3_2
   \   00000044   0x8880             LDRH     R0,[R0, #+4]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable3_2
   \   0000004A   0x8088             STRH     R0,[R1, #+4]
    243              OSMsgPool.NbrUsed--;
   \   0000004C   0x....             LDR.N    R0,??DataTable3_2
   \   0000004E   0x88C0             LDRH     R0,[R0, #+6]
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x....             LDR.N    R1,??DataTable3_2
   \   00000054   0x80C8             STRH     R0,[R1, #+6]
    244          
    245             *p_err             = OS_ERR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x8018             STRH     R0,[R3, #+0]
    246              return (p_void);
   \   0000005A   0x0010             MOVS     R0,R2
   \                     ??OS_MsgQGet_1: (+1)
   \   0000005C   0xBC30             POP      {R4,R5}
   \   0000005E   0x4770             BX       LR               ;; return
    247          }
    248          
    249          
    250          /*
    251          ************************************************************************************************************************
    252          *                                           DEPOSIT MESSAGE IN MESSAGE QUEUE
    253          *
    254          * Description: This function places a message in a message queue
    255          *
    256          * Arguments  : p_msg_q     is a pointer to the OS_TCB of the task to post the message to
    257          *              -------
    258          *
    259          *              p_void      is a pointer to the message to send.
    260          *
    261          *              msg_size    is the size of the message (in bytes)
    262          *
    263          *              opt         specifies whether the message will be posted in FIFO or LIFO order
    264          *
    265          *                              OS_OPT_POST_FIFO
    266          *                              OS_OPT_POST_LIFO
    267          *
    268          *              ts          is a timestamp as to when the message was posted
    269          *
    270          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    271          *
    272          *                              OS_ERR_Q_MAX           if the queue is full
    273          *                              OS_ERR_MSG_POOL_EMPTY  if we no longer have any OS_MSG to use
    274          *                              OS_ERR_NONE            the message was deposited in the queue
    275          *
    276          * Returns    : none
    277          *
    278          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    279          ************************************************************************************************************************
    280          */
    281          

   \                                 In section .text, align 2, keep-with-next
    282          void  OS_MsgQPut (OS_MSG_Q     *p_msg_q,
    283                            void         *p_void,
    284                            OS_MSG_SIZE   msg_size,
    285                            OS_OPT        opt,
    286                            CPU_TS        ts,
    287                            OS_ERR       *p_err)
    288          {
   \                     OS_MsgQPut: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9D05             LDR      R5,[SP, #+20]
    289              OS_MSG  *p_msg;
    290              OS_MSG  *p_msg_in;
    291          
    292          
    293          #if (OS_CFG_TS_EN == 0u)
    294              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
    295          #endif
    296          
    297              if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) {
   \   00000004   0x8944             LDRH     R4,[R0, #+10]
   \   00000006   0x8906             LDRH     R6,[R0, #+8]
   \   00000008   0x42B4             CMP      R4,R6
   \   0000000A   0xD303             BCC.N    ??OS_MsgQPut_0
    298                 *p_err = OS_ERR_Q_MAX;                                   /* Message queue cannot accept any more messages        */
   \   0000000C   0xF246 0x5093      MOVW     R0,#+26003
   \   00000010   0x8028             STRH     R0,[R5, #+0]
    299                  return;
   \   00000012   0xE032             B.N      ??OS_MsgQPut_1
    300              }
    301          
    302              if (OSMsgPool.NbrFree == 0u) {
   \                     ??OS_MsgQPut_0: (+1)
   \   00000014   0x....             LDR.N    R4,??DataTable3_2
   \   00000016   0x88A4             LDRH     R4,[R4, #+4]
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD103             BNE.N    ??OS_MsgQPut_2
    303                 *p_err = OS_ERR_MSG_POOL_EMPTY;                          /* No more OS_MSG to use                                */
   \   0000001C   0xF245 0x701D      MOVW     R0,#+22301
   \   00000020   0x8028             STRH     R0,[R5, #+0]
    304                  return;
   \   00000022   0xE02A             B.N      ??OS_MsgQPut_1
    305              }
    306          
    307              p_msg = OSMsgPool.NextPtr;                                  /* Remove message control block from free list          */
   \                     ??OS_MsgQPut_2: (+1)
   \   00000024   0x....             LDR.N    R4,??DataTable3_2
   \   00000026   0x6826             LDR      R6,[R4, #+0]
    308              OSMsgPool.NextPtr = p_msg->NextPtr;
   \   00000028   0x6834             LDR      R4,[R6, #+0]
   \   0000002A   0x....             LDR.N    R7,??DataTable3_2
   \   0000002C   0x603C             STR      R4,[R7, #+0]
    309              OSMsgPool.NbrFree--;
   \   0000002E   0x....             LDR.N    R4,??DataTable3_2
   \   00000030   0x88A4             LDRH     R4,[R4, #+4]
   \   00000032   0x1E64             SUBS     R4,R4,#+1
   \   00000034   0x....             LDR.N    R7,??DataTable3_2
   \   00000036   0x80BC             STRH     R4,[R7, #+4]
    310              OSMsgPool.NbrUsed++;
   \   00000038   0x....             LDR.N    R4,??DataTable3_2
   \   0000003A   0x88E4             LDRH     R4,[R4, #+6]
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \   0000003E   0x....             LDR.N    R7,??DataTable3_2
   \   00000040   0x80FC             STRH     R4,[R7, #+6]
    311          
    312          #if (OS_CFG_DBG_EN > 0u)
    313              if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
    314                  OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
    315              }
    316          #endif
    317          
    318              if (p_msg_q->NbrEntries == 0u) {                            /* Is this first message placed in the queue?           */
   \   00000042   0x8944             LDRH     R4,[R0, #+10]
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD106             BNE.N    ??OS_MsgQPut_3
    319                  p_msg_q->InPtr         = p_msg;                         /* Yes                                                  */
   \   00000048   0x6006             STR      R6,[R0, #+0]
    320                  p_msg_q->OutPtr        = p_msg;
   \   0000004A   0x6046             STR      R6,[R0, #+4]
    321                  p_msg_q->NbrEntries    =           1u;
   \   0000004C   0x2301             MOVS     R3,#+1
   \   0000004E   0x8143             STRH     R3,[R0, #+10]
    322                  p_msg->NextPtr         = (OS_MSG *)0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6030             STR      R0,[R6, #+0]
   \   00000054   0xE00D             B.N      ??OS_MsgQPut_4
    323              } else {                                                    /* No                                                   */
    324                  if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) {     /* Is it FIFO or LIFO?                                  */
   \                     ??OS_MsgQPut_3: (+1)
   \   00000056   0x06DB             LSLS     R3,R3,#+27
   \   00000058   0xD405             BMI.N    ??OS_MsgQPut_5
    325                      p_msg_in           = p_msg_q->InPtr;                /* FIFO, add to the head                                */
   \   0000005A   0x6803             LDR      R3,[R0, #+0]
    326                      p_msg_in->NextPtr  = p_msg;
   \   0000005C   0x601E             STR      R6,[R3, #+0]
    327                      p_msg_q->InPtr     = p_msg;
   \   0000005E   0x6006             STR      R6,[R0, #+0]
    328                      p_msg->NextPtr     = (OS_MSG *)0;
   \   00000060   0x2300             MOVS     R3,#+0
   \   00000062   0x6033             STR      R3,[R6, #+0]
   \   00000064   0xE002             B.N      ??OS_MsgQPut_6
    329                  } else {
    330                      p_msg->NextPtr     = p_msg_q->OutPtr;               /* LIFO, add to the tail                                */
   \                     ??OS_MsgQPut_5: (+1)
   \   00000066   0x6843             LDR      R3,[R0, #+4]
   \   00000068   0x6033             STR      R3,[R6, #+0]
    331                      p_msg_q->OutPtr    = p_msg;
   \   0000006A   0x6046             STR      R6,[R0, #+4]
    332                  }
    333                  p_msg_q->NbrEntries++;
   \                     ??OS_MsgQPut_6: (+1)
   \   0000006C   0x8943             LDRH     R3,[R0, #+10]
   \   0000006E   0x1C5B             ADDS     R3,R3,#+1
   \   00000070   0x8143             STRH     R3,[R0, #+10]
    334              }
    335          
    336          #if (OS_CFG_DBG_EN > 0u)
    337              if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {
    338                  p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
    339              }
    340          #endif
    341          
    342              p_msg->MsgPtr  = p_void;                                    /* Deposit message in the message queue entry           */
   \                     ??OS_MsgQPut_4: (+1)
   \   00000072   0x6071             STR      R1,[R6, #+4]
    343              p_msg->MsgSize = msg_size;
   \   00000074   0x8132             STRH     R2,[R6, #+8]
    344          #if (OS_CFG_TS_EN > 0u)
    345              p_msg->MsgTS   = ts;
    346          #endif
    347             *p_err          = OS_ERR_NONE;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x8028             STRH     R0,[R5, #+0]
    348          }
   \                     ??OS_MsgQPut_1: (+1)
   \   0000007A   0xBCF0             POP      {R4-R7}
   \   0000007C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     OSCfg_MsgPoolBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     OSCfg_MsgPoolSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     OSMsgPool
    349          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   OS_MsgPoolInit
       0   OS_MsgQFreeAll
       8   OS_MsgQGet
       0   OS_MsgQInit
      16   OS_MsgQPut


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
     124  OS_MsgPoolInit
      64  OS_MsgQFreeAll
      96  OS_MsgQGet
      16  OS_MsgQInit
     126  OS_MsgQPut

 
 438 bytes in section .text
 
 438 bytes of CODE memory

Errors: none
Warnings: none
