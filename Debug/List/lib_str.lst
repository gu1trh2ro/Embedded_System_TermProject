###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:36
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\lib_str.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW367D.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\lib_str.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\lib_str.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\lib_str.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\lib_str.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/LIB
      4          *                                       Custom Library Modules
      5          *
      6          *                    Copyright 2004-2021 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *
     20          *                                       ASCII STRING MANAGEMENT
     21          *
     22          * Filename  : lib_str.c
     23          * Version   : V1.39.01
     24          *********************************************************************************************************
     25          * Note(s)   : (1) NO compiler-supplied standard library functions are used in library or product software.
     26          *
     27          *                 (a) ALL standard library functions are implemented in the custom library modules :
     28          *
     29          *                     (1) \<Custom Library Directory>\lib_*.*
     30          *
     31          *                     (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     32          *
     33          *                           where
     34          *                                   <Custom Library Directory>      directory path for custom library software
     35          *                                   <cpu>                           directory name for specific processor (CPU)
     36          *                                   <compiler>                      directory name for specific compiler
     37          *
     38          *                 (b) Product-specific library functions are implemented in individual products.
     39          *
     40          *********************************************************************************************************
     41          * Notice(s) : (1) The Institute of Electrical and Electronics Engineers and The Open Group, have given
     42          *                 us permission to reprint portions of their documentation.  Portions of this text are
     43          *                 reprinted and reproduced in electronic form from the IEEE Std 1003.1, 2004 Edition,
     44          *                 Standard for Information Technology -- Portable Operating System Interface (POSIX),
     45          *                 The Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute
     46          *                 of Electrical and Electronics Engineers, Inc and The Open Group.  In the event of any
     47          *                 discrepancy between these versions and the original IEEE and The Open Group Standard,
     48          *                 the original IEEE and The Open Group Standard is the referee document.  The original
     49          *                 Standard can be obtained online at http://www.opengroup.org/unix/online.html.
     50          *********************************************************************************************************
     51          */
     52          
     53          /*
     54          *********************************************************************************************************
     55          *                                            INCLUDE FILES
     56          *********************************************************************************************************
     57          */
     58          
     59          #define    MICRIUM_SOURCE
     60          #define    LIB_STR_MODULE
     61          #include  <lib_str.h>
     62          
     63          
     64          /*
     65          *********************************************************************************************************
     66          *                                            LOCAL DEFINES
     67          *********************************************************************************************************
     68          */
     69          
     70          
     71          /*
     72          *********************************************************************************************************
     73          *                                           LOCAL CONSTANTS
     74          *********************************************************************************************************
     75          */
     76          
     77          
     78          /*
     79          *********************************************************************************************************
     80          *                                          LOCAL DATA TYPES
     81          *********************************************************************************************************
     82          */
     83          
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                            LOCAL TABLES
     88          *********************************************************************************************************
     89          */
     90          

   \                                 In section .rodata, align 4
     91          static  const  CPU_INT32U  Str_MultOvfThTbl_Int32U[] = {
   \                     Str_MultOvfThTbl_Int32U:
   \   00000000   0xFFFFFFFF         DC32 4294967295, 4294967295, 2147483647, 1431655765, 1073741823
   \              0xFFFFFFFF   
   \              0x7FFFFFFF   
   \              0x55555555   
   \              0x3FFFFFFF   
   \   00000014   0x33333333         DC32 858993459, 715827882, 613566756, 536870911, 477218588, 429496729
   \              0x2AAAAAAA   
   \              0x24924924   
   \              0x1FFFFFFF   
   \              0x1C71C71C   
   \              0x19999999   
   \   0000002C   0x1745D174         DC32 390451572, 357913941, 330382099, 306783378, 286331153, 268435455
   \              0x15555555   
   \              0x13B13B13   
   \              0x12492492   
   \              0x11111111   
   \              0x0FFFFFFF   
   \   00000044   0x0F0F0F0F         DC32 252645135, 238609294, 226050910, 214748364, 204522252, 195225786
   \              0x0E38E38E   
   \              0x0D79435E   
   \              0x0CCCCCCC   
   \              0x0C30C30C   
   \              0x0BA2E8BA   
   \   0000005C   0x0B21642C         DC32 186737708, 178956970, 171798691, 165191049, 159072862, 153391689
   \              0x0AAAAAAA   
   \              0x0A3D70A3   
   \              0x09D89D89   
   \              0x097B425E   
   \              0x09249249   
   \   00000074   0x08D3DCB0         DC32 148102320, 143165576, 138547332, 134217727, 130150524, 126322567
   \              0x08888888   
   \              0x08421084   
   \              0x07FFFFFF   
   \              0x07C1F07C   
   \              0x07878787   
   \   0000008C   0x07507507         DC32 122713351, 119304647
   \              0x071C71C7   
     92             (CPU_INT32U) DEF_INT_32U_MAX_VAL,                /*                Invalid base  0.  */
     93             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  1u),         /*                Invalid base  1.  */
     94             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  2u),         /* 32-bit mult ovf th for base  2.  */
     95             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  3u),         /* 32-bit mult ovf th for base  3.  */
     96             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  4u),         /* 32-bit mult ovf th for base  4.  */
     97             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  5u),         /* 32-bit mult ovf th for base  5.  */
     98             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  6u),         /* 32-bit mult ovf th for base  6.  */
     99             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  7u),         /* 32-bit mult ovf th for base  7.  */
    100             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  8u),         /* 32-bit mult ovf th for base  8.  */
    101             (CPU_INT32U)(DEF_INT_32U_MAX_VAL /  9u),         /* 32-bit mult ovf th for base  9.  */
    102             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 10u),         /* 32-bit mult ovf th for base 10.  */
    103             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 11u),         /* 32-bit mult ovf th for base 11.  */
    104             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 12u),         /* 32-bit mult ovf th for base 12.  */
    105             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 13u),         /* 32-bit mult ovf th for base 13.  */
    106             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 14u),         /* 32-bit mult ovf th for base 14.  */
    107             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 15u),         /* 32-bit mult ovf th for base 15.  */
    108             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 16u),         /* 32-bit mult ovf th for base 16.  */
    109             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 17u),         /* 32-bit mult ovf th for base 17.  */
    110             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 18u),         /* 32-bit mult ovf th for base 18.  */
    111             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 19u),         /* 32-bit mult ovf th for base 19.  */
    112             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 20u),         /* 32-bit mult ovf th for base 20.  */
    113             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 21u),         /* 32-bit mult ovf th for base 21.  */
    114             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 22u),         /* 32-bit mult ovf th for base 22.  */
    115             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 23u),         /* 32-bit mult ovf th for base 23.  */
    116             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 24u),         /* 32-bit mult ovf th for base 24.  */
    117             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 25u),         /* 32-bit mult ovf th for base 25.  */
    118             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 26u),         /* 32-bit mult ovf th for base 26.  */
    119             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 27u),         /* 32-bit mult ovf th for base 27.  */
    120             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 28u),         /* 32-bit mult ovf th for base 28.  */
    121             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 29u),         /* 32-bit mult ovf th for base 29.  */
    122             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 30u),         /* 32-bit mult ovf th for base 30.  */
    123             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 31u),         /* 32-bit mult ovf th for base 31.  */
    124             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 32u),         /* 32-bit mult ovf th for base 32.  */
    125             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 33u),         /* 32-bit mult ovf th for base 33.  */
    126             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 34u),         /* 32-bit mult ovf th for base 34.  */
    127             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 35u),         /* 32-bit mult ovf th for base 35.  */
    128             (CPU_INT32U)(DEF_INT_32U_MAX_VAL / 36u)          /* 32-bit mult ovf th for base 36.  */
    129          };
    130          
    131          
    132          /*
    133          *********************************************************************************************************
    134          *                                       LOCAL GLOBAL VARIABLES
    135          *********************************************************************************************************
    136          */
    137          
    138          
    139          /*
    140          *********************************************************************************************************
    141          *                                      LOCAL FUNCTION PROTOTYPES
    142          *********************************************************************************************************
    143          */
    144          
    145          static  CPU_CHAR    *Str_FmtNbr_Int32  (       CPU_INT32U     nbr,
    146                                                         CPU_INT08U     nbr_dig,
    147                                                         CPU_INT08U     nbr_base,
    148                                                         CPU_BOOLEAN    nbr_neg,
    149                                                         CPU_CHAR       lead_char,
    150                                                         CPU_BOOLEAN    lower_case,
    151                                                         CPU_BOOLEAN    nul,
    152                                                         CPU_CHAR      *pstr);
    153          
    154          static  CPU_INT32U   Str_ParseNbr_Int32(const  CPU_CHAR      *pstr,
    155                                                         CPU_CHAR     **pstr_next,
    156                                                         CPU_INT08U     nbr_base,
    157                                                         CPU_BOOLEAN    nbr_signed,
    158                                                         CPU_BOOLEAN   *pnbr_neg);
    159          
    160          
    161          /*
    162          *********************************************************************************************************
    163          *                                     LOCAL CONFIGURATION ERRORS
    164          *********************************************************************************************************
    165          */
    166          
    167          
    168          /*
    169          *********************************************************************************************************
    170          *                                              Str_Len()
    171          *
    172          * Description : Calculate length of a string.
    173          *
    174          * Argument(s) : pstr        Pointer to string (see Note #1).
    175          *
    176          * Return(s)   : Length of string; number of characters in string before terminating NULL character
    177          *                   (see Note #2b1).
    178          *
    179          * Caller(s)   : Application.
    180          *
    181          * Note(s)     : (1) String buffer NOT modified.
    182          *
    183          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    184          *
    185          *                       (1) "The strlen() function shall compute the number of bytes in the string to
    186          *                            which 's' ('pstr') points," ...
    187          *                       (2) "not including the terminating null byte."
    188          *
    189          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    190          *
    191          *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
    192          *                       (2) "no return value shall be reserved to indicate an error."
    193          *
    194          *               (3) String length calculation terminates when :
    195          *
    196          *                   (a) String pointer points to NULL.
    197          *                       (1) String buffer overlaps with NULL address.
    198          *                       (2) String length calculated for string up to but NOT beyond or including
    199          *                           the NULL address.
    200          *
    201          *                   (b) Terminating NULL character found.
    202          *                       (1) String length calculated for string up to but NOT           including
    203          *                           the NULL character (see Note #2a2).
    204          *********************************************************************************************************
    205          */
    206          

   \                                 In section .text, align 2, keep-with-next
    207          CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
    208          {
   \                     Str_Len: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    209              CPU_SIZE_T  len;
    210          
    211          
    212              len = Str_Len_N(pstr,
    213                              DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000006   0x.... 0x....      BL       Str_Len_N
    214          
    215              return (len);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    216          }
    217          
    218          
    219          /*
    220          *********************************************************************************************************
    221          *                                             Str_Len_N()
    222          *
    223          * Description : Calculate length of a string, up to a maximum number of characters.
    224          *
    225          * Argument(s) : pstr        Pointer to string (see Note #1).
    226          *
    227          *               len_max     Maximum number of characters to search (see Note #3c).
    228          *
    229          * Return(s)   : Length of string; number of characters in string before terminating NULL character,
    230          *                   if terminating NULL character     found (see Note #2b1).
    231          *
    232          *               Requested maximum number of characters to search,
    233          *                   if terminating NULL character NOT found (see Note #3c).
    234          *
    235          * Caller(s)   : Application.
    236          *
    237          * Note(s)     : (1) String buffer NOT modified.
    238          *
    239          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : DESCRIPTION' states that :
    240          *
    241          *                       (1) "The strlen() function shall compute the number of bytes in the string to
    242          *                            which 's' ('pstr') points," ...
    243          *                       (2) "not including the terminating null byte."
    244          *
    245          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strlen() : RETURN VALUE' states that :
    246          *
    247          *                       (1) "The strlen() function shall return the length of 's' ('pstr');" ...
    248          *                       (2) "no return value shall be reserved to indicate an error."
    249          *
    250          *               (3) String length calculation terminates when :
    251          *
    252          *                   (a) String pointer points to NULL.
    253          *                       (1) String buffer overlaps with NULL address.
    254          *                       (2) String length calculated for string up to but NOT beyond or including
    255          *                           the NULL address.
    256          *
    257          *                   (b) Terminating NULL character found.
    258          *                       (1) String length calculated for string up to but NOT           including
    259          *                           the NULL character (see Note #2a2).
    260          *
    261          *                   (c) 'len_max' number of characters searched.
    262          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character.
    263          *********************************************************************************************************
    264          */
    265          

   \                                 In section .text, align 2, keep-with-next
    266          CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
    267                                        CPU_SIZE_T   len_max)
    268          {
   \                     Str_Len_N: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    269              const  CPU_CHAR    *pstr_len;
    270                     CPU_SIZE_T   len;
    271          
    272          
    273              pstr_len = pstr;
    274              len      = 0u;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE001             B.N      ??Str_Len_N_0
    275              while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
    276                     (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
    277                     ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
    278                  pstr_len++;
   \                     ??Str_Len_N_1: (+1)
   \   00000006   0x1C52             ADDS     R2,R2,#+1
    279                  len++;
   \   00000008   0x1C40             ADDS     R0,R0,#+1
    280              }
   \                     ??Str_Len_N_0: (+1)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD004             BEQ.N    ??Str_Len_N_2
   \   0000000E   0x7813             LDRB     R3,[R2, #+0]
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD001             BEQ.N    ??Str_Len_N_2
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD3F6             BCC.N    ??Str_Len_N_1
    281          
    282              return (len);                                               /* Rtn str len (see Note #3b1).                         */
   \                     ??Str_Len_N_2: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    283          }
    284          
    285          
    286          /*
    287          *********************************************************************************************************
    288          *                                             Str_Copy()
    289          *
    290          * Description : Copy source string to destination string buffer.
    291          *
    292          * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
    293          *
    294          *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
    295          *
    296          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    297          *
    298          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    299          *
    300          * Caller(s)   : Application.
    301          *
    302          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    303          *
    304          *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
    305          *                           string size including the terminating NULL character.
    306          *
    307          *                   (b) Source buffer NOT modified.
    308          *
    309          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that :
    310          *
    311          *                       (1) "The strcpy() function shall copy the string pointed to by 's2' ('pstr_src')
    312          *                            ... into the array pointed to by 's1' ('pstr_dest')" ...
    313          *                       (2) "(including the terminating null byte)."
    314          *
    315          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : RETURN VALUE' states that :
    316          *
    317          *                       (1) "The strcpy() function shall return 's1' ('pstr_dest');" ...
    318          *                       (2) "no return value is reserved to indicate an error."
    319          *                           (A) #### This requirement is intentionally NOT implemented in order to return
    320          *                               NULL for any error(s).
    321          *
    322          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcpy() : DESCRIPTION' states that "if
    323          *                       copying takes place between objects that overlap, the behavior is undefined".
    324          *
    325          *               (3) String copy terminates when :
    326          *
    327          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    328          *                       (1) No string copy performed; NULL pointer returned.
    329          *
    330          *                   (b) Destination/Source string pointer(s) point to NULL.
    331          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    332          *
    333          *                   (c) Source string's terminating NULL character found.
    334          *                       (1) Entire source string copied into destination string buffer (see Note #2a).
    335          *********************************************************************************************************
    336          */
    337          

   \                                 In section .text, align 2, keep-with-next
    338          CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
    339                               const  CPU_CHAR  *pstr_src)
    340          {
   \                     Str_Copy: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    341              CPU_CHAR  *pstr_rtn;
    342          
    343          
    344              pstr_rtn = Str_Copy_N(pstr_dest,
    345                                    pstr_src,
    346                                    DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Copy_N
    347          
    348              return (pstr_rtn);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    349          }
    350          
    351          
    352          /*
    353          *********************************************************************************************************
    354          *                                            Str_Copy_N()
    355          *
    356          * Description : Copy source string to destination string buffer, up to a maximum number of characters.
    357          *
    358          * Argument(s) : pstr_dest   Pointer to destination string buffer to receive source string copy   (see Note #1a).
    359          *
    360          *               pstr_src    Pointer to source      string to copy into destination string buffer (see Note #1b).
    361          *
    362          *               len_max     Maximum number of characters  to copy (see Notes #2a2 & #3d).
    363          *
    364          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    365          *
    366          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    367          *
    368          * Caller(s)   : Application.
    369          *
    370          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    371          *
    372          *                       (1) Destination buffer size MUST be large enough to accommodate the entire source
    373          *                           string size including the terminating NULL character.
    374          *
    375          *                   (b) Source string buffer NOT modified.
    376          *
    377          *               (2) (a) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that :
    378          *
    379          *                           (A) "The strncpy() function shall copy ... the array pointed to by 's2'
    380          *                               ('pstr_src') to the array pointed to by 's1' ('pstr_dest')"; ...
    381          *                           (B)  but "not more than 'n' ('len_max') bytes"                   ...
    382          *                           (C)  &   "(bytes that follow a null byte are not copied)".
    383          *
    384          *                       (2) (A) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' adds that
    385          *                              "if the array pointed to by 's2' ('pstr_src') is a string that is shorter
    386          *                               than 'n' ('len_max') bytes, null bytes shall be appended to the copy in
    387          *                               the array pointed to by 's1' ('pstr_dest'), until 'n' ('len_max') bytes
    388          *                               in all are written."
    389          *
    390          *                               (1) #### Since Str_Copy() limits the maximum number of characters to copy
    391          *                                   via Str_Copy_N() by the CPU's maximum number of addressable characters,
    392          *                                   this requirement is intentionally NOT implemented to avoid appending
    393          *                                   a potentially large number of unnecessary terminating NULL characters.
    394          *
    395          *                           (B) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : APPLICATION USAGE' also
    396          *                               states that "if there is no null byte in the first 'n' ('len_max') bytes of
    397          *                               the array pointed to by 's2' ('pstr_src'), the result is not null-terminated".
    398          *
    399          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : RETURN VALUE' states that :
    400          *
    401          *                       (1) "The strncpy() function shall return 's1' ('pstr_dest');" ...
    402          *                       (2) "no return value is reserved to indicate an error."
    403          *                           (A) #### This requirement is intentionally ignored in order to return NULL
    404          *                               for any error(s).
    405          *
    406          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncpy() : DESCRIPTION' states that "if
    407          *                       copying takes place between objects that overlap, the behavior is undefined".
    408          *
    409          *               (3) String copy terminates when :
    410          *
    411          *                   (a) Destination/Source string pointer(s) are passed NULL pointers.
    412          *                       (1) No string copy performed; NULL pointer returned.
    413          *
    414          *                   (b) Destination/Source string pointer(s) point to NULL.
    415          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    416          *
    417          *                   (c) Source string's terminating NULL character found.
    418          *                       (1) Entire source string copied into destination string buffer (see Note #2a1A).
    419          *
    420          *                   (d) 'len_max' number of characters copied.
    421          *                       (1) 'len_max' number of characters MAY include the terminating NULL character
    422          *                           (see Note #2a1C).
    423          *                       (2) Null copies allowed (i.e. zero-length copies).
    424          *                           (A) No string copy performed; destination string returned  (see Note #2b1).
    425          *********************************************************************************************************
    426          */
    427          

   \                                 In section .text, align 2, keep-with-next
    428          CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
    429                                 const  CPU_CHAR    *pstr_src,
    430                                        CPU_SIZE_T   len_max)
    431          {
   \                     Str_Copy_N: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    432                     CPU_CHAR    *pstr_copy_dest;
    433              const  CPU_CHAR    *pstr_copy_src;
    434                     CPU_SIZE_T   len_copy;
    435          
    436                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    437              if (pstr_dest == (CPU_CHAR *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Copy_N_0
    438                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE01E             B.N      ??Str_Copy_N_1
    439              }
    440              if (pstr_src  == (const CPU_CHAR *)0) {
   \                     ??Str_Copy_N_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Copy_N_2
    441                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE01A             B.N      ??Str_Copy_N_1
    442              }
    443          
    444          
    445              pstr_copy_dest = pstr_dest;
   \                     ??Str_Copy_N_2: (+1)
   \   00000012   0x0003             MOVS     R3,R0
    446              pstr_copy_src  = pstr_src;
    447              len_copy       = 0u;
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xE004             B.N      ??Str_Copy_N_3
    448          
    449              while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
    450                     ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
    451                     (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
    452                     ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
    453                 *pstr_copy_dest = *pstr_copy_src;
   \                     ??Str_Copy_N_4: (+1)
   \   00000018   0x780C             LDRB     R4,[R1, #+0]
   \   0000001A   0x701C             STRB     R4,[R3, #+0]
    454                  pstr_copy_dest++;
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
    455                  pstr_copy_src++;
   \   0000001E   0x1C49             ADDS     R1,R1,#+1
    456                  len_copy++;
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
    457              }
   \                     ??Str_Copy_N_3: (+1)
   \   00000022   0x2B00             CMP      R3,#+0
   \   00000024   0xD006             BEQ.N    ??Str_Copy_N_5
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??Str_Copy_N_5
   \   0000002A   0x780C             LDRB     R4,[R1, #+0]
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD001             BEQ.N    ??Str_Copy_N_5
   \   00000030   0x4295             CMP      R5,R2
   \   00000032   0xD3F1             BCC.N    ??Str_Copy_N_4
    458          
    459                                                                          /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
    460              if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
    461                  (pstr_copy_src  == (const CPU_CHAR *)0)) {
   \                     ??Str_Copy_N_5: (+1)
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD001             BEQ.N    ??Str_Copy_N_6
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD101             BNE.N    ??Str_Copy_N_7
    462                   return ((CPU_CHAR *)0);
   \                     ??Str_Copy_N_6: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE003             B.N      ??Str_Copy_N_1
    463              }
    464          
    465              if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
   \                     ??Str_Copy_N_7: (+1)
   \   00000040   0x4295             CMP      R5,R2
   \   00000042   0xD201             BCS.N    ??Str_Copy_N_8
    466                 *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x7019             STRB     R1,[R3, #+0]
    467              }
    468          
    469          
    470              return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
   \                     ??Str_Copy_N_8: (+1)
   \                     ??Str_Copy_N_1: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    471          }
    472          
    473          
    474          /*
    475          *********************************************************************************************************
    476          *                                              Str_Cat()
    477          *
    478          * Description : Append concatenation string to destination string.
    479          *
    480          * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
    481          *
    482          *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
    483          *
    484          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    485          *
    486          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    487          *
    488          * Caller(s)   : Application.
    489          *
    490          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    491          *
    492          *                       (1) Destination buffer size MUST be large enough to accommodate the entire
    493          *                           concatenated string size including the terminating NULL character.
    494          *
    495          *                   (b) Concatenation string buffer NOT modified.
    496          *
    497          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that :
    498          *
    499          *                       (1) "The strcat() function shall append a copy of the string pointed to by 's2'
    500          *                           ('pstr_cat') ... to the end of the string pointed to by 's1' ('pstr_dest')."
    501          *
    502          *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
    503          *                                end of 's1' ('pstr_dest')."
    504          *                           (B)  A "terminating null byte" is appended at the end of the concatenated
    505          *                                destination strings.
    506          *
    507          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : RETURN VALUE' states that :
    508          *
    509          *                       (1) "The strcat() function shall return 's1' ('pstr_dest');" ...
    510          *                       (2) "no return value shall be reserved to indicate an error."
    511          *                           (A) #### This requirement is intentionally NOT implemented in order to return
    512          *                               NULL for any error(s).
    513          *
    514          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strcat() : DESCRIPTION' states that "if
    515          *                       copying takes place between objects that overlap, the behavior is undefined."
    516          *
    517          *               (3) String concatenation terminates when :
    518          *
    519          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    520          *                       (1) No string concatenation performed; NULL pointer returned.
    521          *
    522          *                   (b) Destination/Concatenation string pointer(s) point to NULL.
    523          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    524          *
    525          *                   (c) Concatenation string's terminating NULL character found.
    526          *                       (1) Entire concatenation string appended to destination string (see Note #2a1).
    527          *********************************************************************************************************
    528          */
    529          

   \                                 In section .text, align 2, keep-with-next
    530          CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
    531                              const  CPU_CHAR  *pstr_cat)
    532          {
   \                     Str_Cat: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    533              CPU_CHAR  *pstr_rtn;
    534          
    535          
    536              pstr_rtn = Str_Cat_N(pstr_dest,
    537                                   pstr_cat,
    538                                   DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Cat_N
    539          
    540              return (pstr_rtn);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    541          }
    542          
    543          
    544          /*
    545          *********************************************************************************************************
    546          *                                             Str_Cat_N()
    547          *
    548          * Description : Append concatenation string to destination string, up to a maximum number of characters.
    549          *
    550          * Argument(s) : pstr_dest   Pointer to destination   string to append concatenation  string (see Note #1a).
    551          *
    552          *               pstr_cat    Pointer to concatenation string to append to destination string (see Note #1b).
    553          *
    554          *               len_max     Maximum number of characters to concatenate (see Notes #2a1B & #3d).
    555          *
    556          * Return(s)   : Pointer to destination string, if NO error(s) [see Note #2b1].
    557          *
    558          *               Pointer to NULL,               otherwise      (see Note #2b2A).
    559          *
    560          * Caller(s)   : Application.
    561          *
    562          * Note(s)     : (1) (a) Destination buffer size NOT validated; buffer overruns MUST be prevented by caller.
    563          *
    564          *                       (1) Destination buffer size MUST be large enough to accommodate the entire
    565          *                           concatenated string size including the terminating NULL character.
    566          *
    567          *                   (b) Concatenation string buffer NOT modified.
    568          *
    569          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that :
    570          *
    571          *                       (1) (A) "The strncat() function shall append ... the array pointed to by 's2'
    572          *                               ('pstr_cat') to the end of the string pointed to by 's1' ('pstr_dest')" ...
    573          *                           (B)  but "not more than 'n' ('len_max') bytes".
    574          *
    575          *                       (2) (A) "The initial byte of 's2' ('pstr_cat') overwrites the null byte at the
    576          *                                end of 's1' ('pstr_dest')."
    577          *                           (B) "(a null byte and bytes that follow it are not appended)."
    578          *                           (C) "A terminating null byte is always appended to the result."
    579          *
    580          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : RETURN VALUE' states that :
    581          *
    582          *                       (1) "The strncat() function shall return 's1' ('pstr_dest');" ...
    583          *                       (2) "no return value shall be reserved to indicate an error."
    584          *                           (A) #### This requirement is intentionally NOT implemented in order to return
    585          *                               NULL for any error(s).
    586          *
    587          *                   (c) IEEE Std 1003.1, 2004 Edition, Section 'strncat() : DESCRIPTION' states that "if
    588          *                       copying takes place between objects that overlap, the behavior is undefined."
    589          *
    590          *               (3) String concatenation terminates when :
    591          *
    592          *                   (a) Destination/Concatenation string pointer(s) are passed NULL pointers.
    593          *                       (1) No string concatenation performed; NULL pointer returned.
    594          *
    595          *                   (b) Destination/Concatenation string pointer(s) point to NULL.
    596          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
    597          *
    598          *                   (c) Concatenation string's terminating NULL character found.
    599          *                       (1) Entire concatenation string appended to destination string (see Note #2a1A).
    600          *
    601          *                   (d) 'len_max' number of characters concatenated.
    602          *
    603          *                       (1) 'len_max' number of characters does NOT include the terminating NULL character
    604          *                           (see Note #2a2).
    605          *
    606          *                       (2) Null concatenations allowed (i.e. zero-length concatenations).
    607          *                           (A) No string concatenation performed; destination string returned
    608          *                               (see Note #2b1).
    609          *********************************************************************************************************
    610          */
    611          

   \                                 In section .text, align 2, keep-with-next
    612          CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
    613                                const  CPU_CHAR    *pstr_cat,
    614                                       CPU_SIZE_T   len_max)
    615          {
   \                     Str_Cat_N: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    616                     CPU_CHAR    *pstr_cat_dest;
    617              const  CPU_CHAR    *pstr_cat_src;
    618                     CPU_SIZE_T   len_cat;
    619          
    620                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    621              if (pstr_dest == (CPU_CHAR *)0) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Cat_N_0
    622                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE029             B.N      ??Str_Cat_N_1
    623              }
    624              if (pstr_cat  == (const CPU_CHAR *)0) {
   \                     ??Str_Cat_N_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Cat_N_2
    625                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE025             B.N      ??Str_Cat_N_1
    626              }
    627          
    628              if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
   \                     ??Str_Cat_N_2: (+1)
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD023             BEQ.N    ??Str_Cat_N_1
    629                  return ((CPU_CHAR *)pstr_dest);
    630              }
    631          
    632          
    633              pstr_cat_dest = pstr_dest;
   \                     ??Str_Cat_N_3: (+1)
   \   00000016   0x0003             MOVS     R3,R0
   \   00000018   0xE000             B.N      ??Str_Cat_N_4
    634              while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
    635                     (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
    636                  pstr_cat_dest++;
   \                     ??Str_Cat_N_5: (+1)
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
    637              }
   \                     ??Str_Cat_N_4: (+1)
   \   0000001C   0x2B00             CMP      R3,#+0
   \   0000001E   0xD002             BEQ.N    ??Str_Cat_N_6
   \   00000020   0x781C             LDRB     R4,[R3, #+0]
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD1F9             BNE.N    ??Str_Cat_N_5
    638          
    639              if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
   \                     ??Str_Cat_N_6: (+1)
   \   00000026   0x2B00             CMP      R3,#+0
   \   00000028   0xD101             BNE.N    ??Str_Cat_N_7
    640                  return ((CPU_CHAR *)0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE017             B.N      ??Str_Cat_N_1
    641              }
    642          
    643              pstr_cat_src = pstr_cat;
    644              len_cat      = 0u;
   \                     ??Str_Cat_N_7: (+1)
   \   0000002E   0x2500             MOVS     R5,#+0
   \   00000030   0xE004             B.N      ??Str_Cat_N_8
    645          
    646              while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
    647                     ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
    648                     (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
    649                     ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
    650                 *pstr_cat_dest = *pstr_cat_src;
   \                     ??Str_Cat_N_9: (+1)
   \   00000032   0x780C             LDRB     R4,[R1, #+0]
   \   00000034   0x701C             STRB     R4,[R3, #+0]
    651                  pstr_cat_dest++;
   \   00000036   0x1C5B             ADDS     R3,R3,#+1
    652                  pstr_cat_src++;
   \   00000038   0x1C49             ADDS     R1,R1,#+1
    653                  len_cat++;
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
    654              }
   \                     ??Str_Cat_N_8: (+1)
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD006             BEQ.N    ??Str_Cat_N_10
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD004             BEQ.N    ??Str_Cat_N_10
   \   00000044   0x780C             LDRB     R4,[R1, #+0]
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD001             BEQ.N    ??Str_Cat_N_10
   \   0000004A   0x4295             CMP      R5,R2
   \   0000004C   0xD3F1             BCC.N    ??Str_Cat_N_9
    655          
    656                                                                          /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    657              if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
    658                  (pstr_cat_src  == (const CPU_CHAR *)0)) {
   \                     ??Str_Cat_N_10: (+1)
   \   0000004E   0x2B00             CMP      R3,#+0
   \   00000050   0xD001             BEQ.N    ??Str_Cat_N_11
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD101             BNE.N    ??Str_Cat_N_12
    659                   return ((CPU_CHAR *)0);
   \                     ??Str_Cat_N_11: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE001             B.N      ??Str_Cat_N_1
    660              }
    661          
    662             *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
   \                     ??Str_Cat_N_12: (+1)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x7019             STRB     R1,[R3, #+0]
    663          
    664          
    665              return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
   \                     ??Str_Cat_N_1: (+1)
   \   0000005E   0xBC30             POP      {R4,R5}
   \   00000060   0x4770             BX       LR               ;; return
    666          }
    667          
    668          
    669          /*
    670          *********************************************************************************************************
    671          *                                              Str_Cmp()
    672          *
    673          * Description : Determine if two strings are identical.
    674          *
    675          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    676          *
    677          *               p2_str      Pointer to second string (see Note #1).
    678          *
    679          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
    680          *
    681          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    682          *
    683          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    684          *
    685          *               See also Note #2b.
    686          *
    687          * Caller(s)   : Application.
    688          *
    689          * Note(s)     : (1) String buffers NOT modified.
    690          *
    691          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' states that "the
    692          *                       strcmp() function shall compare the string pointed to by 's1' ('p1_str') to the
    693          *                       string pointed to by 's2' ('p2_str)".
    694          *
    695          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : RETURN VALUE' states that
    696          *                          "upon successful completion, strcmp() shall return an integer greater than,
    697          *                           equal to, or less than 0".
    698          *
    699          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    700          *                           sign of a non-zero return value shall be determined by the sign of the difference
    701          *                           between the values of the first pair of bytes ... that differ in the strings
    702          *                           being compared".
    703          *
    704          *               (3) String comparison terminates when :
    705          *
    706          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    707          *                               (1) NULL strings identical; 0 returned.
    708          *
    709          *                           (B) (1) 'p1_str' passed a NULL pointer.
    710          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    711          *
    712          *                               (2) 'p2_str' passed a NULL pointer.
    713          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    714          *
    715          *                       (2) (A) BOTH strings point to NULL.
    716          *                               (1) Strings overlap with NULL address.
    717          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    718          *                                   0 returned.
    719          *
    720          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    721          *                                   (a) 'p1_str' overlaps with NULL address.
    722          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    723          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
    724          *
    725          *                               (2) 'p2_str_cmp_next' points to NULL.
    726          *                                   (a) 'p2_str' overlaps with NULL address.
    727          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    728          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
    729          *
    730          *                   (b) Terminating NULL character found in both strings.
    731          *                       (1) Strings identical; 0 returned.
    732          *                       (2) Only one NULL character test required in conditional since previous condition
    733          *                           tested character equality.
    734          *
    735          *                   (c) Non-matching characters found.
    736          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    737          *                           from the character pointed to by 'p1_str'.
    738          *
    739          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    740          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    741          *********************************************************************************************************
    742          */
    743          

   \                                 In section .text, align 2, keep-with-next
    744          CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
    745                               const  CPU_CHAR  *p2_str)
    746          {
   \                     Str_Cmp: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    747              CPU_INT16S  cmp_val;
    748          
    749          
    750              cmp_val = Str_Cmp_N(p1_str,
    751                                  p2_str,
    752                                  DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Cmp_N
    753          
    754              return (cmp_val);
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    755          }
    756          
    757          
    758          /*
    759          *********************************************************************************************************
    760          *                                             Str_Cmp_N()
    761          *
    762          * Description : Determine if two strings are identical for up to a maximum number of characters.
    763          *
    764          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    765          *
    766          *               p2_str      Pointer to second string (see Note #1).
    767          *
    768          *               len_max     Maximum number of characters to compare  (see Note  #3d).
    769          *
    770          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
    771          *
    772          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    773          *
    774          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    775          *
    776          *               See also Note #2b.
    777          *
    778          * Caller(s)   : Application.
    779          *
    780          * Note(s)     : (1) String buffers NOT modified.
    781          *
    782          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' states that :
    783          *
    784          *                       (1) "The strncmp() function shall compare ... the array pointed to by 's1' ('p1_str')
    785          *                            to the array pointed to by 's2' ('p2_str)" ...
    786          *                       (2)  but "not more than 'n' ('len_max') bytes" of either array.
    787          *
    788          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : RETURN VALUE' states that
    789          *                          "upon successful completion, strncmp() shall return an integer greater than,
    790          *                           equal to, or less than 0".
    791          *
    792          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strncmp() : DESCRIPTION' adds that
    793          *                          "the sign of a non-zero return value is determined by the sign of the difference
    794          *                           between the values of the first pair of bytes ... that differ in the strings
    795          *                           being compared".
    796          *
    797          *               (3) String comparison terminates when :
    798          *
    799          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    800          *                               (1) NULL strings identical; 0 returned.
    801          *
    802          *                           (B) (1) 'p1_str' passed a NULL pointer.
    803          *                                   (a) Return negative value of character pointed to by 'p2_str'.
    804          *
    805          *                               (2) 'p2_str' passed a NULL pointer.
    806          *                                   (a) Return positive value of character pointed to by 'p1_str'.
    807          *
    808          *                       (2) (A) BOTH strings point to NULL.
    809          *                               (1) Strings overlap with NULL address.
    810          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    811          *                                   0 returned.
    812          *
    813          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    814          *                                   (a) 'p1_str' overlaps with NULL address.
    815          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    816          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next'.
    817          *
    818          *                               (2) 'p2_str_cmp_next' points to NULL.
    819          *                                   (a) 'p2_str' overlaps with NULL address.
    820          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    821          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next'.
    822          *
    823          *                   (b) Terminating NULL character found in both strings.
    824          *                       (1) Strings identical; 0 returned.
    825          *                       (2) Only one NULL character test required in conditional since previous condition
    826          *                           tested character equality.
    827          *
    828          *                   (c) Non-matching characters found.
    829          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str'
    830          *                           from the character pointed to by 'p1_str'.
    831          *
    832          *                   (d) (1) 'len_max' passed a zero length.
    833          *                           (A) Zero-length strings identical; 0 returned.
    834          *
    835          *                       (2) First 'len_max' number of characters identical.
    836          *                           (A) Strings identical; 0 returned.
    837          *
    838          *                       See also Note #2a2.
    839          *
    840          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
    841          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
    842          *********************************************************************************************************
    843          */
    844          

   \                                 In section .text, align 2, keep-with-next
    845          CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
    846                                 const  CPU_CHAR    *p2_str,
    847                                        CPU_SIZE_T   len_max)
    848          {
   \                     Str_Cmp_N: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    849              const  CPU_CHAR    *p1_str_cmp;
    850              const  CPU_CHAR    *p2_str_cmp;
    851              const  CPU_CHAR    *p1_str_cmp_next;
    852              const  CPU_CHAR    *p2_str_cmp_next;
    853                     CPU_INT16S   cmp_val;
    854                     CPU_SIZE_T   cmp_len;
    855          
    856          
    857              if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??Str_Cmp_N_0
    858                  return (0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE040             B.N      ??Str_Cmp_N_1
    859              }
    860          
    861              if (p1_str == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_0: (+1)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD107             BNE.N    ??Str_Cmp_N_2
    862                  if (p2_str == (const CPU_CHAR *)0) {
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD101             BNE.N    ??Str_Cmp_N_3
    863                      return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE03A             B.N      ??Str_Cmp_N_1
    864                  }
    865                  cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str));
   \                     ??Str_Cmp_N_3: (+1)
   \   00000016   0x7808             LDRB     R0,[R1, #+0]
   \   00000018   0x4240             RSBS     R0,R0,#+0
    866                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   0000001A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000001C   0xE036             B.N      ??Str_Cmp_N_1
    867              }
    868              if (p2_str == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_2: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD102             BNE.N    ??Str_Cmp_N_4
    869                  cmp_val = (CPU_INT16S)(*p1_str);
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
    870                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   00000024   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000026   0xE031             B.N      ??Str_Cmp_N_1
    871              }
    872          
    873          
    874              p1_str_cmp      = p1_str;
    875              p2_str_cmp      = p2_str;
    876              p1_str_cmp_next = p1_str_cmp;
    877              p2_str_cmp_next = p2_str_cmp;
    878              p1_str_cmp_next++;
   \                     ??Str_Cmp_N_4: (+1)
   \   00000028   0x1C44             ADDS     R4,R0,#+1
    879              p2_str_cmp_next++;
   \   0000002A   0x1C4B             ADDS     R3,R1,#+1
    880              cmp_len         = 0u;
   \   0000002C   0x2600             MOVS     R6,#+0
   \   0000002E   0xE004             B.N      ??Str_Cmp_N_5
    881          
    882              while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
    883                     (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
    884                     ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
    885                     ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
    886                     ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
    887                  p1_str_cmp++;
   \                     ??Str_Cmp_N_6: (+1)
   \   00000030   0x1C40             ADDS     R0,R0,#+1
    888                  p2_str_cmp++;
   \   00000032   0x1C49             ADDS     R1,R1,#+1
    889                  p1_str_cmp_next++;
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    890                  p2_str_cmp_next++;
   \   00000036   0x1C5B             ADDS     R3,R3,#+1
    891                  cmp_len++;
   \   00000038   0x1C76             ADDS     R6,R6,#+1
    892              }
   \                     ??Str_Cmp_N_5: (+1)
   \   0000003A   0x7805             LDRB     R5,[R0, #+0]
   \   0000003C   0x780F             LDRB     R7,[R1, #+0]
   \   0000003E   0x42BD             CMP      R5,R7
   \   00000040   0xD108             BNE.N    ??Str_Cmp_N_7
   \   00000042   0x7805             LDRB     R5,[R0, #+0]
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD005             BEQ.N    ??Str_Cmp_N_7
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD003             BEQ.N    ??Str_Cmp_N_7
   \   0000004C   0x2B00             CMP      R3,#+0
   \   0000004E   0xD001             BEQ.N    ??Str_Cmp_N_7
   \   00000050   0x4296             CMP      R6,R2
   \   00000052   0xD3ED             BCC.N    ??Str_Cmp_N_6
    893          
    894          
    895              if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
   \                     ??Str_Cmp_N_7: (+1)
   \   00000054   0x4296             CMP      R6,R2
   \   00000056   0xD101             BNE.N    ??Str_Cmp_N_8
    896                  return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE017             B.N      ??Str_Cmp_N_1
    897              }
    898          
    899              if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
   \                     ??Str_Cmp_N_8: (+1)
   \   0000005C   0x7802             LDRB     R2,[R0, #+0]
   \   0000005E   0x780D             LDRB     R5,[R1, #+0]
   \   00000060   0x42AA             CMP      R2,R5
   \   00000062   0xD003             BEQ.N    ??Str_Cmp_N_9
    900                                                                          /* ... calc & rtn char diff  (see Note #3c1).           */
    901                   cmp_val = (CPU_INT16S)((CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp));
   \   00000064   0x7802             LDRB     R2,[R0, #+0]
   \   00000066   0x7808             LDRB     R0,[R1, #+0]
   \   00000068   0x1A10             SUBS     R0,R2,R0
   \   0000006A   0xE00E             B.N      ??Str_Cmp_N_10
    902          
    903              } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
   \                     ??Str_Cmp_N_9: (+1)
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD101             BNE.N    ??Str_Cmp_N_11
    904                   cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE009             B.N      ??Str_Cmp_N_10
    905          
    906              } else {
    907                  if (p1_str_cmp_next == (const CPU_CHAR *)0) {
   \                     ??Str_Cmp_N_11: (+1)
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD106             BNE.N    ??Str_Cmp_N_12
    908                      if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
   \   0000007A   0x2B00             CMP      R3,#+0
   \   0000007C   0xD101             BNE.N    ??Str_Cmp_N_13
    909                          cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE003             B.N      ??Str_Cmp_N_10
    910                      } else {                                            /* If p1_str_cmp_next NULL, ...                         */
    911                                                                          /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
    912                          cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next));
   \                     ??Str_Cmp_N_13: (+1)
   \   00000082   0x7818             LDRB     R0,[R3, #+0]
   \   00000084   0x4240             RSBS     R0,R0,#+0
   \   00000086   0xE000             B.N      ??Str_Cmp_N_10
    913                      }
    914                  } else {                                                /* If p2_str_cmp_next NULL, ...                         */
    915                      cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
   \                     ??Str_Cmp_N_12: (+1)
   \   00000088   0x7820             LDRB     R0,[R4, #+0]
    916                  }
    917              }
    918          
    919          
    920              return (cmp_val);
   \                     ??Str_Cmp_N_10: (+1)
   \   0000008A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_Cmp_N_1: (+1)
   \   0000008C   0xBCF0             POP      {R4-R7}
   \   0000008E   0x4770             BX       LR               ;; return
    921          }
    922          
    923          
    924          /*
    925          *********************************************************************************************************
    926          *                                         Str_CmpIgnoreCase()
    927          *
    928          * Description : Determine if two strings are identical, ignoring case.
    929          *
    930          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
    931          *
    932          *               p2_str      Pointer to second string (see Note #1).
    933          *
    934          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, & #3b).
    935          *
    936          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
    937          *
    938          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
    939          *
    940          *               See also Note #2b.
    941          *
    942          * Caller(s)   : Application.
    943          *
    944          * Note(s)     : (1) String buffers NOT modified.
    945          *
    946          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : DESCRIPTION' states that :
    947          *
    948          *                       (1) (A) "The strcasecmp() function shall compare ... the string pointed to by 's1'
    949          *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
    950          *                           (B) "ignoring differences in case".
    951          *
    952          *                       (2) "strcasecmp() ... shall behave as if the strings had been converted to lowercase
    953          *                            and then a byte comparison performed."
    954          *
    955          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strcasecmp() : RETURN VALUE' states that
    956          *                          "upon successful completion, strcasecmp() shall return an integer greater than,
    957          *                           equal to, or less than 0".
    958          *
    959          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
    960          *                           sign of a non-zero return value shall be determined by the sign of the difference
    961          *                           between the values of the first pair of bytes ... that differ in the strings
    962          *                           being compared".
    963          *
    964          *               (3) String comparison terminates when :
    965          *
    966          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
    967          *                               (1) NULL strings identical; 0 returned.
    968          *
    969          *                           (B) (1) 'p1_str' passed a NULL pointer.
    970          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
    971          *                                       to lower case (see Note #2a2).
    972          *
    973          *                               (2) 'p2_str' passed a NULL pointer.
    974          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
    975          *                                       to lower case (see Note #2a2).
    976          *
    977          *                       (2) (A) BOTH strings point to NULL.
    978          *                               (1) Strings overlap with NULL address.
    979          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
    980          *                                   0 returned.
    981          *
    982          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
    983          *                                   (a) 'p1_str' overlaps with NULL address.
    984          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    985          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
    986          *                                       converted to lower case (see Note #2a2).
    987          *
    988          *                               (2) 'p2_str_cmp_next' points to NULL.
    989          *                                   (a) 'p2_str' overlaps with NULL address.
    990          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
    991          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
    992          *                                       converted to lower case (see Note #2a2).
    993          *
    994          *                   (b) Terminating NULL character found in both strings.
    995          *                       (1) Strings identical; 0 returned.
    996          *                       (2) Only one NULL character test required in conditional since previous condition
    997          *                           tested character equality.
    998          *
    999          *                   (c) Non-matching characters found.
   1000          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
   1001          *                           converted to lower case, from the character pointed to by 'p1_str', converted
   1002          *                           to lower case.
   1003          *
   1004          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1005          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1006          *********************************************************************************************************
   1007          */
   1008          

   \                                 In section .text, align 2, keep-with-next
   1009          CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
   1010                                         const  CPU_CHAR  *p2_str)
   1011          {
   \                     Str_CmpIgnoreCase: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1012              CPU_INT16S  cmp_val;
   1013          
   1014          
   1015              cmp_val = Str_CmpIgnoreCase_N(p1_str,
   1016                                            p2_str,
   1017                                            DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_CmpIgnoreCase_N
   1018          
   1019              return (cmp_val);
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
   1020          }
   1021          
   1022          
   1023          /*
   1024          *********************************************************************************************************
   1025          *                                        Str_CmpIgnoreCase_N()
   1026          *
   1027          * Description : Determine if two strings are identical for up to a maximum number of characters,
   1028          *                   ignoring case.
   1029          *
   1030          * Argument(s) : p1_str      Pointer to first  string (see Note #1).
   1031          *
   1032          *               p2_str      Pointer to second string (see Note #1).
   1033          *
   1034          *               len_max     Maximum number of characters to compare  (see Note  #3d).
   1035          *
   1036          * Return(s)   : 0,              if strings are identical             (see Notes #3a1A, #3a2A, #3b, & #3d).
   1037          *
   1038          *               Negative value, if 'p1_str' is less    than 'p2_str' (see Notes #3a1B1, #3a2B1, & #3c).
   1039          *
   1040          *               Positive value, if 'p1_str' is greater than 'p2_str' (see Notes #3a1B2, #3a2B2, & #3c).
   1041          *
   1042          *               See also Note #2b.
   1043          *
   1044          * Caller(s)   : Application.
   1045          *
   1046          * Note(s)     : (1) String buffers NOT modified.
   1047          *
   1048          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : DESCRIPTION' states that :
   1049          *
   1050          *                       (1) (A) "The strncasecmp() function shall compare ... the string pointed to by 's1'
   1051          *                                ('p1_str') to the string pointed to by 's2' ('p2_str')" ...
   1052          *                           (B) "ignoring differences in case"                           ...
   1053          *                           (C)  but "not more than 'n' ('len_max') bytes" of either string.
   1054          *
   1055          *                       (2) "strncasecmp() shall behave as if the strings had been converted to lowercase
   1056          *                            and then a byte comparison performed."
   1057          *
   1058          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strncasecmp() : RETURN VALUE' states that
   1059          *                          "upon successful completion, strncasecmp() shall return an integer greater than,
   1060          *                           equal to, or less than 0".
   1061          *
   1062          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strcmp() : DESCRIPTION' adds that "the
   1063          *                           sign of a non-zero return value shall be determined by the sign of the difference
   1064          *                           between the values of the first pair of bytes ... that differ in the strings
   1065          *                           being compared".
   1066          *
   1067          *               (3) String comparison terminates when :
   1068          *
   1069          *                   (a) (1) (A) BOTH string pointer(s) are passed NULL pointers.
   1070          *                               (1) NULL strings identical; 0 returned.
   1071          *
   1072          *                           (B) (1) 'p1_str' passed a NULL pointer.
   1073          *                                   (a) Return negative value of character pointed to by 'p2_str', converted
   1074          *                                       to lower case (see Note #2a2).
   1075          *
   1076          *                               (2) 'p2_str' passed a NULL pointer.
   1077          *                                   (a) Return positive value of character pointed to by 'p1_str', converted
   1078          *                                       to lower case (see Note #2a2).
   1079          *
   1080          *                       (2) (A) BOTH strings point to NULL.
   1081          *                               (1) Strings overlap with NULL address.
   1082          *                               (2) Strings identical up to but NOT beyond or including the NULL address;
   1083          *                                   0 returned.
   1084          *
   1085          *                           (B) (1) 'p1_str_cmp_next' points to NULL.
   1086          *                                   (a) 'p1_str' overlaps with NULL address.
   1087          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1088          *                                   (c) Return negative value of character pointed to by 'p2_str_cmp_next',
   1089          *                                       converted to lower case (see Note #2a2).
   1090          *
   1091          *                               (2) 'p2_str_cmp_next' points to NULL.
   1092          *                                   (a) 'p2_str' overlaps with NULL address.
   1093          *                                   (b) Strings compared up to but NOT beyond or including the NULL address.
   1094          *                                   (c) Return positive value of character pointed to by 'p1_str_cmp_next',
   1095          *                                       converted to lower case (see Note #2a2).
   1096          *
   1097          *                   (b) Terminating NULL character found in both strings.
   1098          *                       (1) Strings identical; 0 returned.
   1099          *                       (2) Only one NULL character test required in conditional since previous condition
   1100          *                           tested character equality.
   1101          *
   1102          *                   (c) Non-matching characters found.
   1103          *                       (1) Return signed-integer difference of the character pointed to by 'p2_str',
   1104          *                           converted to lower case, from the character pointed to by 'p1_str', converted
   1105          *                           to lower case.
   1106          *
   1107          *                   (d) (1) 'len_max' passed a zero length.
   1108          *                           (A) Zero-length strings identical; 0 returned.
   1109          *
   1110          *                       (2) First 'len_max' number of characters identical.
   1111          *                           (A) Strings identical; 0 returned.
   1112          *
   1113          *                       See also Note #2a1C.
   1114          *
   1115          *               (4) Since 16-bit signed arithmetic is performed to calculate a non-identical comparison
   1116          *                   return value, 'CPU_CHAR' native data type size MUST be 8-bit.
   1117          *********************************************************************************************************
   1118          */
   1119          

   \                                 In section .text, align 2, keep-with-next
   1120          CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
   1121                                           const  CPU_CHAR    *p2_str,
   1122                                                  CPU_SIZE_T   len_max)
   1123          {
   \                     Str_CmpIgnoreCase_N: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   1124              const  CPU_CHAR    *p1_str_cmp;
   1125              const  CPU_CHAR    *p2_str_cmp;
   1126              const  CPU_CHAR    *p1_str_cmp_next;
   1127              const  CPU_CHAR    *p2_str_cmp_next;
   1128                     CPU_CHAR     char_1;
   1129                     CPU_CHAR     char_2;
   1130                     CPU_INT16S   cmp_val;
   1131                     CPU_SIZE_T   cmp_len;
   1132          
   1133          
   1134              if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
   \   0000000A   0x2F00             CMP      R7,#+0
   \   0000000C   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_0
   1135                  return (0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE075             B.N      ??Str_CmpIgnoreCase_N_1
   1136              }
   1137          
   1138              if (p1_str == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_0: (+1)
   \   00000012   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000016   0xD10A             BNE.N    ??Str_CmpIgnoreCase_N_2
   1139                  if (p2_str == (const CPU_CHAR *)0) {
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_3
   1140                      return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE06E             B.N      ??Str_CmpIgnoreCase_N_1
   1141                  }
   1142                  char_2  =  ASCII_ToLower(*p2_str);
   \                     ??Str_CmpIgnoreCase_N_3: (+1)
   \   00000020   0x7830             LDRB     R0,[R6, #+0]
   \   00000022   0x.... 0x....      BL       ASCII_ToLower
   1143                  cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x4240             RSBS     R0,R0,#+0
   1144                  return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
   \   0000002A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002C   0xE067             B.N      ??Str_CmpIgnoreCase_N_1
   1145              }
   1146              if (p2_str == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_2: (+1)
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD106             BNE.N    ??Str_CmpIgnoreCase_N_4
   1147                  char_1  =  ASCII_ToLower(*p1_str);
   \   00000032   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000036   0x.... 0x....      BL       ASCII_ToLower
   1148                  cmp_val = (CPU_INT16S)char_1;
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   1149                  return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
   \   0000003C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000003E   0xE05E             B.N      ??Str_CmpIgnoreCase_N_1
   1150              }
   1151          
   1152          
   1153              p1_str_cmp      = p1_str;
   1154              p2_str_cmp      = p2_str;
   1155              p1_str_cmp_next = p1_str_cmp;
   1156              p2_str_cmp_next = p2_str_cmp;
   1157              p1_str_cmp_next++;
   \                     ??Str_CmpIgnoreCase_N_4: (+1)
   \   00000040   0xF119 0x0401      ADDS     R4,R9,#+1
   1158              p2_str_cmp_next++;
   \   00000044   0x1C75             ADDS     R5,R6,#+1
   1159              char_1          = ASCII_ToLower(*p1_str_cmp);
   \   00000046   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000004A   0x.... 0x....      BL       ASCII_ToLower
   \   0000004E   0x4680             MOV      R8,R0
   1160              char_2          = ASCII_ToLower(*p2_str_cmp);
   \   00000050   0x7830             LDRB     R0,[R6, #+0]
   \   00000052   0x.... 0x....      BL       ASCII_ToLower
   \   00000056   0x0001             MOVS     R1,R0
   1161              cmp_len         = 0u;
   \   00000058   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000005C   0xE00F             B.N      ??Str_CmpIgnoreCase_N_5
   1162          
   1163              while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
   1164                     (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
   1165                     ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
   1166                     ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
   1167                     ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
   1168                  p1_str_cmp++;
   \                     ??Str_CmpIgnoreCase_N_6: (+1)
   \   0000005E   0xF119 0x0901      ADDS     R9,R9,#+1
   1169                  p2_str_cmp++;
   \   00000062   0x1C76             ADDS     R6,R6,#+1
   1170                  p1_str_cmp_next++;
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   1171                  p2_str_cmp_next++;
   \   00000066   0x1C6D             ADDS     R5,R5,#+1
   1172                  cmp_len++;
   \   00000068   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1173                  char_1 = ASCII_ToLower(*p1_str_cmp);
   \   0000006C   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   00000070   0x.... 0x....      BL       ASCII_ToLower
   \   00000074   0x4680             MOV      R8,R0
   1174                  char_2 = ASCII_ToLower(*p2_str_cmp);
   \   00000076   0x7830             LDRB     R0,[R6, #+0]
   \   00000078   0x.... 0x....      BL       ASCII_ToLower
   \   0000007C   0x0001             MOVS     R1,R0
   1175              }
   \                     ??Str_CmpIgnoreCase_N_5: (+1)
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x000A             MOVS     R2,R1
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000086   0x4290             CMP      R0,R2
   \   00000088   0xD109             BNE.N    ??Str_CmpIgnoreCase_N_7
   \   0000008A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD005             BEQ.N    ??Str_CmpIgnoreCase_N_7
   \   00000092   0x2C00             CMP      R4,#+0
   \   00000094   0xD003             BEQ.N    ??Str_CmpIgnoreCase_N_7
   \   00000096   0x2D00             CMP      R5,#+0
   \   00000098   0xD001             BEQ.N    ??Str_CmpIgnoreCase_N_7
   \   0000009A   0x45BA             CMP      R10,R7
   \   0000009C   0xD3DF             BCC.N    ??Str_CmpIgnoreCase_N_6
   1176          
   1177          
   1178              if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
   \                     ??Str_CmpIgnoreCase_N_7: (+1)
   \   0000009E   0x45BA             CMP      R10,R7
   \   000000A0   0xD101             BNE.N    ??Str_CmpIgnoreCase_N_8
   1179                  return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xE02B             B.N      ??Str_CmpIgnoreCase_N_1
   1180              }
   1181          
   1182              if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
   \                     ??Str_CmpIgnoreCase_N_8: (+1)
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x000A             MOVS     R2,R1
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000AE   0x4290             CMP      R0,R2
   \   000000B0   0xD005             BEQ.N    ??Str_CmpIgnoreCase_N_9
   1183                                                                          /* ... calc & rtn char diff  (see Note #3c1).           */
   1184                   cmp_val = (CPU_INT16S)((CPU_INT16S)char_1 - (CPU_INT16S)char_2);
   \   000000B2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000B8   0xEBB8 0x0801      SUBS     R8,R8,R1
   \   000000BC   0xE01D             B.N      ??Str_CmpIgnoreCase_N_10
   1185          
   1186              } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
   \                     ??Str_CmpIgnoreCase_N_9: (+1)
   \   000000BE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000C6   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_11
   1187                   cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
   \   000000C8   0xF05F 0x0800      MOVS     R8,#+0
   \   000000CC   0xE015             B.N      ??Str_CmpIgnoreCase_N_10
   1188          
   1189              } else {
   1190                  if (p1_str_cmp_next == (const CPU_CHAR *)0) {
   \                     ??Str_CmpIgnoreCase_N_11: (+1)
   \   000000CE   0x2C00             CMP      R4,#+0
   \   000000D0   0xD10D             BNE.N    ??Str_CmpIgnoreCase_N_12
   1191                      if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
   \   000000D2   0x2D00             CMP      R5,#+0
   \   000000D4   0xD102             BNE.N    ??Str_CmpIgnoreCase_N_13
   1192                          cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
   \   000000D6   0xF05F 0x0800      MOVS     R8,#+0
   \   000000DA   0xE00E             B.N      ??Str_CmpIgnoreCase_N_10
   1193                      } else {                                            /* If p1_str_cmp_next NULL, ...                         */
   1194                          char_2  =  ASCII_ToLower(*p2_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_13: (+1)
   \   000000DC   0x7828             LDRB     R0,[R5, #+0]
   \   000000DE   0x.... 0x....      BL       ASCII_ToLower
   \   000000E2   0x4680             MOV      R8,R0
   1195                                                                          /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
   1196                          cmp_val = (CPU_INT16S)((CPU_INT16S)0 - (CPU_INT16S)char_2);
   \   000000E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E8   0xF1D8 0x0800      RSBS     R8,R8,#+0
   \   000000EC   0xE005             B.N      ??Str_CmpIgnoreCase_N_10
   1197                      }
   1198                  } else {                                                /* If p2_str_cmp_next NULL, ...                         */
   1199                      char_1  =  ASCII_ToLower(*p1_str_cmp_next);
   \                     ??Str_CmpIgnoreCase_N_12: (+1)
   \   000000EE   0x7820             LDRB     R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       ASCII_ToLower
   \   000000F4   0x4680             MOV      R8,R0
   1200                      cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
   \   000000F6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   1201                  }
   1202              }
   1203          
   1204          
   1205              return (cmp_val);
   \                     ??Str_CmpIgnoreCase_N_10: (+1)
   \   000000FA   0x4640             MOV      R0,R8
   \   000000FC   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??Str_CmpIgnoreCase_N_1: (+1)
   \   000000FE   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1206          }
   1207          
   1208          
   1209          /*
   1210          *********************************************************************************************************
   1211          *                                             Str_Char()
   1212          *
   1213          * Description : Search string for first occurrence of specific character.
   1214          *
   1215          * Argument(s) : pstr            Pointer to string (see Note #1).
   1216          *
   1217          *               srch_char       Search character.
   1218          *
   1219          * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
   1220          *
   1221          *               Pointer to NULL,                                           otherwise (see Note #2b2).
   1222          *
   1223          * Caller(s)   : Application.
   1224          *
   1225          * Note(s)     : (1) String buffer NOT modified.
   1226          *
   1227          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
   1228          *
   1229          *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
   1230          *                            ... in the string pointed to by 's' ('pstr')."
   1231          *                       (2) "The terminating null byte is considered to be part of the string."
   1232          *
   1233          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
   1234          *                       "upon completion, strchr() shall return" :
   1235          *
   1236          *                       (1) "a pointer to the byte," ...
   1237          *                       (2) "or a null pointer if the byte was not found."
   1238          *                           (A) #### Although NO strchr() specification states to return NULL for
   1239          *                               any other reason(s), NULL is also returned for any error(s).
   1240          *
   1241          *               (3) String search terminates when :
   1242          *
   1243          *                   (a) String pointer passed a NULL pointer.
   1244          *                       (1) No string search performed; NULL pointer returned.
   1245          *
   1246          *                   (b) String pointer points to NULL.
   1247          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1248          *
   1249          *                   (c) String's terminating NULL character found.
   1250          *                       (1) Search character NOT found in search string; NULL pointer returned
   1251          *                           (see Note #2b2).
   1252          *                       (2) Applicable even if search character is the terminating NULL character
   1253          *                           (see Note #2a2).
   1254          *
   1255          *                   (d) Search character found.
   1256          *                       (1) Return pointer to first occurrence of search character in search string
   1257          *                           (see Note #2a1).
   1258          *********************************************************************************************************
   1259          */
   1260          

   \                                 In section .text, align 2, keep-with-next
   1261          CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
   1262                                      CPU_CHAR   srch_char)
   1263          {
   \                     Str_Char: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x000A             MOVS     R2,R1
   1264              CPU_CHAR  *pstr_rtn;
   1265          
   1266          
   1267              pstr_rtn = Str_Char_N(pstr,
   1268                                    DEF_INT_CPU_U_MAX_VAL,
   1269                                    srch_char);
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x.... 0x....      BL       Str_Char_N
   1270          
   1271              return (pstr_rtn);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1272          }
   1273          
   1274          
   1275          /*
   1276          *********************************************************************************************************
   1277          *                                            Str_Char_N()
   1278          *
   1279          * Description : Search string for first occurrence of specific character, up to a maximum number
   1280          *                   of characters.
   1281          *
   1282          * Argument(s) : pstr            Pointer to string (see Note #1).
   1283          *
   1284          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1285          *
   1286          *               srch_char       Search character.
   1287          *
   1288          * Return(s)   : Pointer to first occurrence of search character in string, if any    (see Note #2b1).
   1289          *
   1290          *               Pointer to NULL,                                           otherwise (see Note #2b2).
   1291          *
   1292          * Caller(s)   : Application.
   1293          *
   1294          * Note(s)     : (1) String buffer NOT modified.
   1295          *
   1296          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : DESCRIPTION' states that :
   1297          *
   1298          *                       (1) "The strchr() function shall locate the first occurrence of 'c' ('srch_char')
   1299          *                            ... in the string pointed to by 's' ('pstr')."
   1300          *                       (2) "The terminating null byte is considered to be part of the string."
   1301          *
   1302          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strchr() : RETURN VALUE' states that
   1303          *                       "upon completion, strchr() shall return" :
   1304          *
   1305          *                       (1) "a pointer to the byte," ...
   1306          *                       (2) "or a null pointer if the byte was not found."
   1307          *                           (A) #### Although NO strchr() specification states to return NULL for
   1308          *                               any other reason(s), NULL is also returned for any error(s).
   1309          *
   1310          *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
   1311          *                       argument list for consistency with all other custom string library functions.
   1312          *                       However, the 'len_max' argument is sequentially ordered as the second argument
   1313          *                       to comply with most standard library's strnchr() argument list.
   1314          *
   1315          *               (3) String search terminates when :
   1316          *
   1317          *                   (a) String pointer passed a NULL pointer.
   1318          *                       (1) No string search performed; NULL pointer returned.
   1319          *
   1320          *                   (b) String pointer points to NULL.
   1321          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1322          *
   1323          *                   (c) String's terminating NULL character found.
   1324          *                       (1) Search character NOT found in search string; NULL pointer returned
   1325          *                           (see Note #2b2).
   1326          *                       (2) Applicable even if search character is the terminating NULL character
   1327          *                           (see Note #2a2).
   1328          *
   1329          *                   (d) Search character found.
   1330          *                       (1) Return pointer to first occurrence of search character in search string
   1331          *                           (see Note #2a1).
   1332          *
   1333          *                   (e) 'len_max' number of characters searched.
   1334          *                       (1) Search character NOT found in search string within first 'len_max' number
   1335          *                           of characters; NULL pointer returned.
   1336          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1337          *                           (see Note #2a2).
   1338          *********************************************************************************************************
   1339          */
   1340          

   \                                 In section .text, align 2, keep-with-next
   1341          CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
   1342                                        CPU_SIZE_T   len_max,
   1343                                        CPU_CHAR     srch_char)
   1344          {
   \                     Str_Char_N: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   1345              const  CPU_CHAR    *pstr_char;
   1346                     CPU_SIZE_T   len_srch;
   1347          
   1348          
   1349              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Char_N_0
   1350                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE021             B.N      ??Str_Char_N_1
   1351              }
   1352          
   1353              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
   \                     ??Str_Char_N_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Char_N_2
   1354                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE01D             B.N      ??Str_Char_N_1
   1355              }
   1356          
   1357          
   1358              pstr_char = pstr;
   1359              len_srch  = 0u;
   \                     ??Str_Char_N_2: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0xE001             B.N      ??Str_Char_N_3
   1360          
   1361              while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
   1362                     (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
   1363                     (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
   1364                     ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
   1365                  pstr_char++;
   \                     ??Str_Char_N_4: (+1)
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   1366                  len_srch++;
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   1367              }
   \                     ??Str_Char_N_3: (+1)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD009             BEQ.N    ??Str_Char_N_5
   \   0000001E   0x7803             LDRB     R3,[R0, #+0]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD006             BEQ.N    ??Str_Char_N_5
   \   00000024   0x7803             LDRB     R3,[R0, #+0]
   \   00000026   0x0015             MOVS     R5,R2
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x42AB             CMP      R3,R5
   \   0000002C   0xD001             BEQ.N    ??Str_Char_N_5
   \   0000002E   0x428C             CMP      R4,R1
   \   00000030   0xD3F1             BCC.N    ??Str_Char_N_4
   1368          
   1369              if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
   \                     ??Str_Char_N_5: (+1)
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD101             BNE.N    ??Str_Char_N_6
   1370                  return ((CPU_CHAR *)0);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE009             B.N      ??Str_Char_N_1
   1371              }
   1372          
   1373              if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
   \                     ??Str_Char_N_6: (+1)
   \   0000003A   0x428C             CMP      R4,R1
   \   0000003C   0xD301             BCC.N    ??Str_Char_N_7
   1374                  return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE005             B.N      ??Str_Char_N_1
   1375              }
   1376          
   1377              if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
   \                     ??Str_Char_N_7: (+1)
   \   00000042   0x7801             LDRB     R1,[R0, #+0]
   \   00000044   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000046   0x4291             CMP      R1,R2
   \   00000048   0xD001             BEQ.N    ??Str_Char_N_8
   1378                   return ((CPU_CHAR *)0);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE7FF             B.N      ??Str_Char_N_1
   1379              }
   1380          
   1381          
   1382              return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
   \                     ??Str_Char_N_8: (+1)
   \                     ??Str_Char_N_1: (+1)
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
   1383          }
   1384          
   1385          
   1386          /*
   1387          *********************************************************************************************************
   1388          *                                           Str_Char_Last()
   1389          *
   1390          * Description : Search string for last occurrence of specific character.
   1391          *
   1392          * Argument(s) : pstr            Pointer to string (see Note #1).
   1393          *
   1394          *               srch_char       Search character.
   1395          *
   1396          * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
   1397          *
   1398          *               Pointer to NULL,                                          otherwise (see Note #2b2).
   1399          *
   1400          * Caller(s)   : Application.
   1401          *
   1402          * Note(s)     : (1) String buffer NOT modified.
   1403          *
   1404          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1405          *
   1406          *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
   1407          *                            ... in the string pointed to by 's' ('pstr')."
   1408          *                       (2) "The terminating null byte is considered to be part of the string."
   1409          *
   1410          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
   1411          *                       "upon successful completion, strrchr() shall return" :
   1412          *
   1413          *                       (1) "a pointer to the byte" ...
   1414          *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
   1415          *                           (A) #### Although NO strrchr() specification states to return NULL for
   1416          *                               any other reason(s), NULL is also returned for any error(s).
   1417          *
   1418          *               (3) String search terminates when :
   1419          *
   1420          *                   (a) String pointer passed a NULL pointer.
   1421          *                       (1) No string search performed; NULL pointer returned.
   1422          *
   1423          *                   (b) String pointer points to NULL.
   1424          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1425          *
   1426          *                   (c) String searched from end to beginning.
   1427          *                       (1) Search character NOT found in search string; NULL pointer returned.
   1428          *                       (2) Applicable even if search character is the terminating NULL character
   1429          *                           (see Note #2a2).
   1430          *
   1431          *                   (d) Search character found.
   1432          *                       (1) Return pointer to last occurrence of search character in search string
   1433          *                           (see Note #2a1).
   1434          *********************************************************************************************************
   1435          */
   1436          

   \                                 In section .text, align 2, keep-with-next
   1437          CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
   1438                                           CPU_CHAR   srch_char)
   1439          {
   \                     Str_Char_Last: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x000A             MOVS     R2,R1
   1440              CPU_CHAR  *pstr_rtn;
   1441          
   1442          
   1443              pstr_rtn = Str_Char_Last_N(pstr,
   1444                                         DEF_INT_CPU_U_MAX_VAL,
   1445                                         srch_char);
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000000A   0x.... 0x....      BL       Str_Char_Last_N
   1446          
   1447              return (pstr_rtn);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1448          }
   1449          
   1450          
   1451          /*
   1452          *********************************************************************************************************
   1453          *                                          Str_Char_Last_N()
   1454          *
   1455          * Description : Search string for last occurrence of specific character, up to a maximum number
   1456          *                   of characters.
   1457          *
   1458          * Argument(s) : pstr            Pointer to string (see Note #1).
   1459          *
   1460          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1461          *
   1462          *               srch_char       Search character.
   1463          *
   1464          * Return(s)   : Pointer to last occurrence of search character in string, if any    (see Note #2b1).
   1465          *
   1466          *               Pointer to NULL,                                          otherwise (see Note #2b2).
   1467          *
   1468          * Caller(s)   : Application.
   1469          *
   1470          * Note(s)     : (1) String buffer NOT modified.
   1471          *
   1472          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : DESCRIPTION' states that :
   1473          *
   1474          *                       (1) "The strrchr() function shall locate the last occurrence of 'c' ('srch_char')
   1475          *                            ... in the string pointed to by 's' ('pstr')."
   1476          *                       (2) "The terminating null byte is considered to be part of the string."
   1477          *
   1478          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strrchr() : RETURN VALUE' states that
   1479          *                       "upon successful completion, strrchr() shall return" :
   1480          *
   1481          *                       (1) "a pointer to the byte" ...
   1482          *                       (2) "or a null pointer if 'c' ('srch_char') does not occur in the string."
   1483          *                           (A) #### Although NO strrchr() specification states to return NULL for
   1484          *                               any other reason(s), NULL is also returned for any error(s).
   1485          *
   1486          *                   (c) Ideally, the 'len_max' argument would be the last argument in this function's
   1487          *                       argument list for consistency with all other custom string library functions.
   1488          *                       However, the 'len_max' argument is sequentially ordered as the second argument
   1489          *                       to comply with most standard library's strnrchr() argument list.
   1490          *
   1491          *                       See also 'Str_Char_N()  Note #2c'.
   1492          *
   1493          *               (3) String search terminates when :
   1494          *
   1495          *                   (a) String pointer passed a NULL pointer.
   1496          *                       (1) No string search performed; NULL pointer returned.
   1497          *
   1498          *                   (b) String pointer points to NULL.
   1499          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1500          *
   1501          *                   (c) String searched from end to beginning.
   1502          *                       (1) Search character NOT found in search string; NULL pointer returned
   1503          *                           (see Note #2b2).
   1504          *                       (2) Applicable even if search character is the terminating NULL character
   1505          *                           (see Note #2a2).
   1506          *
   1507          *                   (d) Search character found.
   1508          *                       (1) Return pointer to last occurrence of search character in search string
   1509          *                           (see Note #2a1).
   1510          *
   1511          *                   (e) 'len_max' number of characters searched.
   1512          *                       (1) Search character NOT found in search string within last 'len_max' number
   1513          *                           of characters; NULL pointer returned.
   1514          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1515          *                           (see Note #2a2).
   1516          *********************************************************************************************************
   1517          */
   1518          

   \                                 In section .text, align 2, keep-with-next
   1519          CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
   1520                                             CPU_SIZE_T   len_max,
   1521                                             CPU_CHAR     srch_char)
   1522          {
   \                     Str_Char_Last_N: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1523              const  CPU_CHAR    *pstr_char;
   1524                     CPU_SIZE_T   str_len_max;
   1525                     CPU_SIZE_T   str_len;
   1526          
   1527          
   1528              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??Str_Char_Last_N_0
   1529                  return ((CPU_CHAR *)0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE01A             B.N      ??Str_Char_Last_N_1
   1530              }
   1531          
   1532              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
   \                     ??Str_Char_Last_N_0: (+1)
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD101             BNE.N    ??Str_Char_Last_N_2
   1533                  return ((CPU_CHAR *)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE016             B.N      ??Str_Char_Last_N_1
   1534              }
   1535          
   1536          
   1537              pstr_char    = pstr;
   1538               str_len_max = len_max - sizeof("");                        /* Str len adj'd for NULL char len.                     */
   \                     ??Str_Char_Last_N_2: (+1)
   \   00000016   0x1E49             SUBS     R1,R1,#+1
   1539               str_len     = Str_Len_N(pstr_char, str_len_max);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       Str_Len_N
   1540              pstr_char   += str_len;
   \   0000001E   0x4420             ADD      R0,R4,R0
   1541          
   1542              if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD102             BNE.N    ??Str_Char_Last_N_3
   1543                  return ((CPU_CHAR *)0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE00D             B.N      ??Str_Char_Last_N_1
   1544              }
   1545          
   1546              while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
   1547                     (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
   1548                  pstr_char--;
   \                     ??Str_Char_Last_N_4: (+1)
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   1549              }
   \                     ??Str_Char_Last_N_3: (+1)
   \   0000002A   0x42A0             CMP      R0,R4
   \   0000002C   0xD004             BEQ.N    ??Str_Char_Last_N_5
   \   0000002E   0x7801             LDRB     R1,[R0, #+0]
   \   00000030   0x002A             MOVS     R2,R5
   \   00000032   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xD1F7             BNE.N    ??Str_Char_Last_N_4
   1550          
   1551          
   1552              if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
   \                     ??Str_Char_Last_N_5: (+1)
   \   00000038   0x7801             LDRB     R1,[R0, #+0]
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x42A9             CMP      R1,R5
   \   0000003E   0xD001             BEQ.N    ??Str_Char_Last_N_6
   1553                   return ((CPU_CHAR *)0);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE7FF             B.N      ??Str_Char_Last_N_1
   1554              }
   1555          
   1556          
   1557              return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
   \                     ??Str_Char_Last_N_6: (+1)
   \                     ??Str_Char_Last_N_1: (+1)
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1558          }
   1559          
   1560          
   1561          /*
   1562          *********************************************************************************************************
   1563          *                                         Str_Char_Replace()
   1564          *
   1565          * Description : Search string for specific character and replace it by another specific character.
   1566          *
   1567          * Argument(s) : pstr            Pointer to string (see Note #1).
   1568          *
   1569          *               char_srch       Search character.
   1570          *
   1571          *               char_replace    Replace character.
   1572          *
   1573          * Return(s)   : Pointer to string, if NO error(s).
   1574          *
   1575          *               Pointer to NULL,   otherwise.
   1576          *
   1577          * Caller(s)   : Application.
   1578          *
   1579          * Note(s)     : (1) String buffer modified.
   1580          *
   1581          *               (2) String search terminates when :
   1582          *
   1583          *                   (a) String pointer passed a NULL pointer.
   1584          *                       (1) No string search performed; NULL pointer returned.
   1585          *
   1586          *                   (b) String pointer points to NULL.
   1587          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1588          *
   1589          *                   (c) String's terminating NULL character found.
   1590          *                       (1) Search character NOT found in search string; NULL pointer returned
   1591          *                       (2) Applicable even if search character is the terminating NULL character
   1592          *
   1593          *                   (d) Search character found.
   1594          *                       (1) Replace character found by the specified character.
   1595          *********************************************************************************************************
   1596          */
   1597          

   \                                 In section .text, align 2, keep-with-next
   1598          CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
   1599                                       CPU_CHAR   char_srch,
   1600                                       CPU_CHAR   char_replace)
   1601          {
   \                     Str_Char_Replace: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1602              CPU_CHAR  *pstr_rtn;
   1603          
   1604          
   1605              pstr_rtn = Str_Char_Replace_N(pstr,
   1606                                            char_srch,
   1607                                            char_replace,
   1608                                            DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x33FF      MOVS     R3,#-1
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x.... 0x....      BL       Str_Char_Replace_N
   1609          
   1610              return (pstr_rtn);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1611          }
   1612          
   1613          
   1614          /*
   1615          *********************************************************************************************************
   1616          *                                        Str_Char_Replace_N()
   1617          *
   1618          * Description : Search string for specific character and replace it by another specific character, up to
   1619          *               a maximum number of characters.
   1620          *
   1621          * Argument(s) : pstr            Pointer to string (see Note #1).
   1622          *
   1623          *               char_srch       Search character.
   1624          *
   1625          *               char_replace    Replace character.
   1626          *
   1627          *               len_max         Maximum number of characters to search (see Notes #2c & #3e).
   1628          *
   1629          * Return(s)   : Pointer to string, if NO error(s).
   1630          *
   1631          *               Pointer to NULL,   otherwise.
   1632          *
   1633          * Caller(s)   : Application.
   1634          *
   1635          * Note(s)     : (1) String buffer modified.
   1636          *
   1637          *               (2) String search terminates when :
   1638          *
   1639          *                   (a) String pointer passed a NULL pointer.
   1640          *                       (1) No string search performed; NULL pointer returned.
   1641          *
   1642          *                   (b) String pointer points to NULL.
   1643          *                       (1) String overlaps with NULL address; NULL pointer returned.
   1644          *
   1645          *                   (c) String's terminating NULL character found.
   1646          *                       (1) Search character NOT found in search string; NULL pointer returned
   1647          *                       (2) Applicable even if search character is the terminating NULL character
   1648          *
   1649          *                   (d) Search character found.
   1650          *                       (1) Replace character found by the specified character.
   1651          *
   1652          *                   (e) 'len_max' number of characters searched.
   1653          *                       (1) Search character NOT found in search string within first 'len_max' number
   1654          *                           of characters; NULL pointer returned.
   1655          *                       (2) 'len_max' number of characters MAY include terminating NULL character
   1656          *                           (see Note #2a2).
   1657          *********************************************************************************************************
   1658          */
   1659          

   \                                 In section .text, align 2, keep-with-next
   1660          CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
   1661                                         CPU_CHAR     char_srch,
   1662                                         CPU_CHAR     char_replace,
   1663                                         CPU_SIZE_T   len_max)
   1664          {
   \                     Str_Char_Replace_N: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1665              CPU_CHAR    *pstr_char;
   1666              CPU_SIZE_T   len;
   1667          
   1668          
   1669              if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE.N    ??Str_Char_Replace_N_0
   1670                  return ((CPU_CHAR *)0);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE014             B.N      ??Str_Char_Replace_N_1
   1671              }
   1672          
   1673              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
   \                     ??Str_Char_Replace_N_0: (+1)
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD101             BNE.N    ??Str_Char_Replace_N_2
   1674                  return ((CPU_CHAR *)0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE010             B.N      ??Str_Char_Replace_N_1
   1675              }
   1676          
   1677              pstr_char = pstr;
   \                     ??Str_Char_Replace_N_2: (+1)
   \   00000012   0x0005             MOVS     R5,R0
   1678              len       = len_max;
   \   00000014   0xE007             B.N      ??Str_Char_Replace_N_3
   1679          
   1680              while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
   1681                     (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
   1682                     ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
   1683          
   1684                  if (*pstr_char == char_srch) {
   \                     ??Str_Char_Replace_N_4: (+1)
   \   00000016   0x782C             LDRB     R4,[R5, #+0]
   \   00000018   0x000E             MOVS     R6,R1
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x42B4             CMP      R4,R6
   \   0000001E   0xD100             BNE.N    ??Str_Char_Replace_N_5
   1685                      *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
   \   00000020   0x702A             STRB     R2,[R5, #+0]
   1686                  }
   1687          
   1688                  pstr_char++;
   \                     ??Str_Char_Replace_N_5: (+1)
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   1689                  len--;
   \   00000024   0x1E5B             SUBS     R3,R3,#+1
   1690              }
   \                     ??Str_Char_Replace_N_3: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD004             BEQ.N    ??Str_Char_Replace_N_6
   \   0000002A   0x782C             LDRB     R4,[R5, #+0]
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD001             BEQ.N    ??Str_Char_Replace_N_6
   \   00000030   0x2B00             CMP      R3,#+0
   \   00000032   0xD1F0             BNE.N    ??Str_Char_Replace_N_4
   1691          
   1692              return (pstr);
   \                     ??Str_Char_Replace_N_6: (+1)
   \                     ??Str_Char_Replace_N_1: (+1)
   \   00000034   0xBC70             POP      {R4-R6}
   \   00000036   0x4770             BX       LR               ;; return
   1693          }
   1694          
   1695          
   1696          /*
   1697          *********************************************************************************************************
   1698          *                                              Str_Str()
   1699          *
   1700          * Description : Search string for first occurence of a specific search string.
   1701          *
   1702          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1703          *
   1704          *               pstr_srch       Pointer to search string (see Note #1).
   1705          *
   1706          * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
   1707          *
   1708          *               Pointer to string,                                      if NULL search string (see Note #2b2).
   1709          *
   1710          *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
   1711          *
   1712          * Caller(s)   : Application.
   1713          *
   1714          * Note(s)     : (1) String buffers NOT modified.
   1715          *
   1716          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1717          *
   1718          *                       (1) "The strstr() function shall locate the first occurrence  in the string
   1719          *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
   1720          *                            pointed to by 's2' ('pstr_srch')" ...
   1721          *                       (2) "(excluding the terminating null byte)."
   1722          *
   1723          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1724          *
   1725          *                       (1) "Upon successful completion, strstr() shall return" :
   1726          *                           (A) "a pointer to the located string" ...
   1727          *                           (B) "or a null pointer if the string is not found."
   1728          *                               (1) #### Although NO strstr() specification states to return NULL for
   1729          *                                   any other reason(s), NULL is also returned for any error(s).
   1730          *
   1731          *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
   1732          *                            shall return 's1' ('pstr')."
   1733          *
   1734          *               (3) String search terminates when :
   1735          *
   1736          *                   (a) String pointer(s) are passed NULL pointers.
   1737          *                       (1) No string search performed; NULL pointer returned.
   1738          *
   1739          *                   (b) String pointer(s) point to NULL.
   1740          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
   1741          *
   1742          *                   (c) Search string length equal to zero.
   1743          *                       (1) No string search performed; string pointer returned (see Note #2b2).
   1744          *
   1745          *                   (d) Search string length greater than string length.
   1746          *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
   1747          *
   1748          *                   (e) Entire string has been searched.
   1749          *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
   1750          *
   1751          *                   (f) Search string found.
   1752          *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
   1753          *********************************************************************************************************
   1754          */
   1755          

   \                                 In section .text, align 2, keep-with-next
   1756          CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
   1757                              const  CPU_CHAR  *pstr_srch)
   1758          {
   \                     Str_Str: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1759              CPU_CHAR  *pstr_rtn;
   1760          
   1761          
   1762              pstr_rtn = Str_Str_N(pstr,
   1763                                   pstr_srch,
   1764                                   DEF_INT_CPU_U_MAX_VAL);
   \   00000002   0xF05F 0x32FF      MOVS     R2,#-1
   \   00000006   0x.... 0x....      BL       Str_Str_N
   1765          
   1766              return (pstr_rtn);
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
   1767          }
   1768          
   1769          
   1770          /*
   1771          *********************************************************************************************************
   1772          *                                             Str_Str_N()
   1773          *
   1774          * Description : Search string for first occurence of a specific search string, up to a maximum number
   1775          *                   of characters.
   1776          *
   1777          * Argument(s) : pstr            Pointer to        string (see Note #1).
   1778          *
   1779          *               pstr_srch       Pointer to search string (see Note #1).
   1780          *
   1781          *               len_max         Maximum number of characters to search (see Note #3g).
   1782          *
   1783          * Return(s)   : Pointer to first occurrence of search string in string, if any                (see Note #2b1A).
   1784          *
   1785          *               Pointer to string,                                      if NULL search string (see Note #2b2).
   1786          *
   1787          *               Pointer to NULL,                                        otherwise             (see Note #2b1B).
   1788          *
   1789          * Caller(s)   : Application.
   1790          *
   1791          * Note(s)     : (1) String buffers NOT modified.
   1792          *
   1793          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : DESCRIPTION' states that :
   1794          *
   1795          *                       (1) "The strstr() function shall locate the first occurrence  in the string
   1796          *                            pointed to by 's1' ('pstr') of the sequence of bytes ... in the string
   1797          *                            pointed to by 's2' ('pstr_srch')" ...
   1798          *                       (2) "(excluding the terminating null byte)."
   1799          *
   1800          *                   (b) IEEE Std 1003.1, 2004 Edition, Section 'strstr() : RETURN VALUE' states that :
   1801          *
   1802          *                       (1) "Upon successful completion, strstr() shall return" :
   1803          *                           (A) "a pointer to the located string" ...
   1804          *                           (B) "or a null pointer if the string is not found."
   1805          *                               (1) #### Although NO strstr() specification states to return NULL for
   1806          *                                   any other reason(s), NULL is also returned for any error(s).
   1807          *
   1808          *                       (2) "If 's2' ('pstr_srch') points to a string with zero length, the function
   1809          *                            shall return 's1' ('pstr')."
   1810          *
   1811          *               (3) String search terminates when :
   1812          *
   1813          *                   (a) String pointer(s) are passed NULL pointers.
   1814          *                       (1) No string search performed; NULL pointer returned.
   1815          *
   1816          *                   (b) String pointer(s) point to NULL.
   1817          *                       (1) String buffer(s) overlap with NULL address; NULL pointer returned.
   1818          *
   1819          *                   (c) Search string length equal to zero.
   1820          *                       (1) No string search performed; string pointer returned (see Note #2b2).
   1821          *
   1822          *                   (d) Search string length greater than string length.
   1823          *                       (1) No string search performed; NULL   pointer returned (see Note #2b1B).
   1824          *
   1825          *                   (e) Entire string has been searched.
   1826          *                       (1) Search string not found; NULL pointer returned (see Note #2b1B).
   1827          *                       (2) Maximum size of the search is defined as the subtraction of the
   1828          *                           search string length from the string length.
   1829          *
   1830          *                   (f) Search string found.
   1831          *                       (1) Return pointer to first occurrence of search string in string (see Note #2b1A).
   1832          *                       (2) Search string found via Str_Cmp_N().
   1833          *
   1834          *                   (g) 'len_max' number of characters searched.
   1835          *                       (1) 'len_max' number of characters does NOT include terminating NULL character
   1836          *                           (see Note #2a2).
   1837          *********************************************************************************************************
   1838          */
   1839          

   \                                 In section .text, align 2, keep-with-next
   1840          CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
   1841                                const  CPU_CHAR    *pstr_srch,
   1842                                       CPU_SIZE_T   len_max)
   1843          {
   \                     Str_Str_N: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1844                     CPU_SIZE_T    str_len;
   1845                     CPU_SIZE_T    str_len_srch;
   1846                     CPU_SIZE_T    len_max_srch;
   1847                     CPU_SIZE_T    srch_len;
   1848                     CPU_SIZE_T    srch_ix;
   1849                     CPU_BOOLEAN   srch_done;
   1850                     CPU_INT16S    srch_cmp;
   1851              const  CPU_CHAR     *pstr_str;
   1852              const  CPU_CHAR     *pstr_srch_ix;
   1853          
   1854                                                                          /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
   1855              if (pstr == (const CPU_CHAR *)0) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??Str_Str_N_0
   1856                  return ((CPU_CHAR *)0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE049             B.N      ??Str_Str_N_1
   1857              }
   1858              if (pstr_srch == (const CPU_CHAR *)0) {
   \                     ??Str_Str_N_0: (+1)
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD101             BNE.N    ??Str_Str_N_2
   1859                  return ((CPU_CHAR *)0);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE045             B.N      ??Str_Str_N_1
   1860              }
   1861          
   1862              if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
   \                     ??Str_Str_N_2: (+1)
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD101             BNE.N    ??Str_Str_N_3
   1863                  return ((CPU_CHAR *)0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE041             B.N      ??Str_Str_N_1
   1864              }
   1865          
   1866                                                                          /* Lim max srch str len (to chk > str len).             */
   1867              len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
   1868                           ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
   \                     ??Str_Str_N_3: (+1)
   \   00000020   0xF112 0x0F01      CMN      R2,#+1
   \   00000024   0xD001             BEQ.N    ??Str_Str_N_4
   \   00000026   0x1C56             ADDS     R6,R2,#+1
   \   00000028   0xE001             B.N      ??Str_Str_N_5
   \                     ??Str_Str_N_4: (+1)
   \   0000002A   0xF05F 0x36FF      MOVS     R6,#-1
   1869          
   1870              str_len      = Str_Len_N(pstr,      len_max);
   \                     ??Str_Str_N_5: (+1)
   \   0000002E   0x0011             MOVS     R1,R2
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       Str_Len_N
   \   00000036   0x4681             MOV      R9,R0
   1871              str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
   \   00000038   0x0031             MOVS     R1,R6
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       Str_Len_N
   \   00000040   0x0006             MOVS     R6,R0
   1872              if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD101             BNE.N    ??Str_Str_N_6
   1873                  return ((CPU_CHAR *)pstr);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0xE02C             B.N      ??Str_Str_N_1
   1874              }
   1875              if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
   \                     ??Str_Str_N_6: (+1)
   \   0000004A   0x45B1             CMP      R9,R6
   \   0000004C   0xD201             BCS.N    ??Str_Str_N_7
   1876                  return ((CPU_CHAR *)0);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE028             B.N      ??Str_Str_N_1
   1877              }
   1878          
   1879                                                                          /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
   1880              pstr_str = pstr      + str_len;
   \                     ??Str_Str_N_7: (+1)
   \   00000052   0xEB04 0x0009      ADD      R0,R4,R9
   1881              if (pstr_str == (const CPU_CHAR *)0) {
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD101             BNE.N    ??Str_Str_N_8
   1882                  return ((CPU_CHAR *)0);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE022             B.N      ??Str_Str_N_1
   1883              }
   1884              pstr_str = pstr_srch + str_len_srch;
   \                     ??Str_Str_N_8: (+1)
   \   0000005E   0xEB05 0x0006      ADD      R0,R5,R6
   1885              if (pstr_str == (const CPU_CHAR *)0) {
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD101             BNE.N    ??Str_Str_N_9
   1886                  return ((CPU_CHAR *)0);
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE01C             B.N      ??Str_Str_N_1
   1887              }
   1888          
   1889              srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
   \                     ??Str_Str_N_9: (+1)
   \   0000006A   0xEBB9 0x0906      SUBS     R9,R9,R6
   1890              srch_ix   = 0u;
   \   0000006E   0x2700             MOVS     R7,#+0
   1891          
   1892              do {
   1893                  pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
   \                     ??Str_Str_N_10: (+1)
   \   00000070   0xEB04 0x0807      ADD      R8,R4,R7
   1894                  srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
   \   00000074   0x0032             MOVS     R2,R6
   \   00000076   0x0029             MOVS     R1,R5
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      BL       Str_Cmp_N
   1895                  srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
   \   0000007E   0x0001             MOVS     R1,R0
   \   00000080   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD101             BNE.N    ??Str_Str_N_11
   \   00000086   0x2101             MOVS     R1,#+1
   \   00000088   0xE000             B.N      ??Str_Str_N_12
   \                     ??Str_Str_N_11: (+1)
   \   0000008A   0x2100             MOVS     R1,#+0
   1896                  srch_ix++;
   \                     ??Str_Str_N_12: (+1)
   \   0000008C   0x1C7F             ADDS     R7,R7,#+1
   1897              } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
   \   0000008E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0xD101             BNE.N    ??Str_Str_N_13
   \   00000094   0x45B9             CMP      R9,R7
   \   00000096   0xD2EB             BCS.N    ??Str_Str_N_10
   1898          
   1899          
   1900              if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
   \                     ??Str_Str_N_13: (+1)
   \   00000098   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD001             BEQ.N    ??Str_Str_N_14
   1901                  return ((CPU_CHAR *)0);
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xE000             B.N      ??Str_Str_N_1
   1902              }
   1903          
   1904              return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
   \                     ??Str_Str_N_14: (+1)
   \   000000A2   0x4640             MOV      R0,R8
   \                     ??Str_Str_N_1: (+1)
   \   000000A4   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1905          }
   1906          
   1907          
   1908          /*
   1909          *********************************************************************************************************
   1910          *                                         Str_FmtNbr_Int32U()
   1911          *
   1912          * Description : Format 32-bit unsigned integer into a multi-digit character string.
   1913          *
   1914          * Argument(s) : nbr             Number           to format.
   1915          *
   1916          *               nbr_dig         Number of digits to format (see Note #1).
   1917          *
   1918          *                               The following may be used to specify the number of digits to format :
   1919          *
   1920          *                                   DEF_INT_32U_NBR_DIG_MIN     Minimum number of 32-bit unsigned digits
   1921          *                                   DEF_INT_32U_NBR_DIG_MAX     Maximum number of 32-bit unsigned digits
   1922          *
   1923          *               nbr_base        Base   of number to format (see Note #2).
   1924          *
   1925          *                               The following may be used to specify the number base :
   1926          *
   1927          *                                   DEF_NBR_BASE_BIN            Base  2
   1928          *                                   DEF_NBR_BASE_OCT            Base  8
   1929          *                                   DEF_NBR_BASE_DEC            Base 10
   1930          *                                   DEF_NBR_BASE_HEX            Base 16
   1931          *
   1932          *               lead_char       Prepend leading character  (see Note #3) :
   1933          *
   1934          *                                   '\0'                    Do NOT prepend leading character to string.
   1935          *                                     Printable character          Prepend leading character to string.
   1936          *                                   Unprintable character   Format invalid string (see Note #6).
   1937          *
   1938          *               lower_case      Format alphabetic characters (if any) in lower case :
   1939          *
   1940          *                                   DEF_NO          Format alphabetic characters in upper case.
   1941          *                                   DEF_YES         Format alphabetic characters in lower case.
   1942          *
   1943          *               nul             Append terminating NULL-character (see Note #4) :
   1944          *
   1945          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   1946          *                                   DEF_YES                Append terminating NULL-character to string.
   1947          *
   1948          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   1949          *
   1950          * Return(s)   : Pointer to formatted string, if NO error(s).
   1951          *
   1952          *               Pointer to NULL,             otherwise.
   1953          *
   1954          * Caller(s)   : Application.
   1955          *
   1956          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
   1957          *                       is performed except possible NULL-termination of the string (see Note #4).
   1958          *
   1959          *                           Example :
   1960          *
   1961          *                               nbr      = 23456
   1962          *                               nbr_dig  = 0
   1963          *                               nbr_base = 10
   1964          *
   1965          *                               pstr     = ""                   See Note #6a
   1966          *
   1967          *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
   1968          *                       significant integer digits of the number to format ('nbr'); then an invalid
   1969          *                       string is formatted instead of truncating any significant integer digits.
   1970          *
   1971          *                           Example :
   1972          *
   1973          *                               nbr      = 23456
   1974          *                               nbr_dig  = 3
   1975          *                               nbr_base = 10
   1976          *
   1977          *                               pstr     = "???"                See Note #6b
   1978          *
   1979          *               (2) The number's base MUST be between 2 & 36, inclusive.
   1980          *
   1981          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   1982          *
   1983          *                   (a) (1) Leading character MUST be a printable ASCII character.
   1984          *
   1985          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   1986          *                           (B) with the exception of '0'.
   1987          *
   1988          *                   (b) The number of leading characters is such that the total number of significant
   1989          *                       integer digits plus the number of leading characters is equal to the requested
   1990          *                       number of integer digits to format ('nbr_dig').
   1991          *
   1992          *                           Example :
   1993          *
   1994          *                               nbr       = 23456
   1995          *                               nbr_dig   = 7
   1996          *                               nbr_base  = 10
   1997          *                               lead_char = ' '
   1998          *
   1999          *                               pstr      = "  23456"
   2000          *
   2001          *                   (c) (1) If the value of the number to format is     zero  ...
   2002          *                       (2) ... & the number of digits to format is non-zero, ...
   2003          *                       (3) ... but NO leading character available;           ...
   2004          *                       (4) ... then one digit of '0' value is formatted.
   2005          *
   2006          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2007          *
   2008          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2009          *                       array formatting.
   2010          *
   2011          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2012          *                       terminate option DISABLED will cause character string run-on.
   2013          *
   2014          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2015          *
   2016          *                   (b) To prevent character buffer overrun :
   2017          *
   2018          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2019          *                                                               1 'NUL' terminator)  characters
   2020          *
   2021          *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
   2022          *                   ('?') will be formatted, where the number of question marks is determined by the
   2023          *                   number of digits to format ('nbr_dig') :
   2024          *
   2025          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2026          *                          number of     =  {
   2027          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2028          *
   2029          *********************************************************************************************************
   2030          */
   2031          

   \                                 In section .text, align 2, keep-with-next
   2032          CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
   2033                                        CPU_INT08U    nbr_dig,
   2034                                        CPU_INT08U    nbr_base,
   2035                                        CPU_CHAR      lead_char,
   2036                                        CPU_BOOLEAN   lower_case,
   2037                                        CPU_BOOLEAN   nul,
   2038                                        CPU_CHAR     *pstr)
   2039          {
   \                     Str_FmtNbr_Int32U: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x9D08             LDR      R5,[SP, #+32]
   \   00000004   0x9C09             LDR      R4,[SP, #+36]
   \   00000006   0x9E0A             LDR      R6,[SP, #+40]
   2040              CPU_CHAR  *pstr_fmt;
   2041          
   2042          
   2043              pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
   2044                                          nbr_dig,
   2045                                          nbr_base,
   2046                                          DEF_NO,
   2047                                          lead_char,
   2048                                          lower_case,
   2049                                          nul,
   2050                                          pstr);
   \   00000008   0x9603             STR      R6,[SP, #+12]
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x9402             STR      R4,[SP, #+8]
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x9501             STR      R5,[SP, #+4]
   \   00000012   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000014   0x9300             STR      R3,[SP, #+0]
   \   00000016   0x2300             MOVS     R3,#+0
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0x.... 0x....      BL       Str_FmtNbr_Int32
   2051          
   2052              return (pstr_fmt);
   \   00000020   0xB004             ADD      SP,SP,#+16
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
   2053          }
   2054          
   2055          
   2056          /*
   2057          *********************************************************************************************************
   2058          *                                         Str_FmtNbr_Int32S()
   2059          *
   2060          * Description : Format 32-bit signed integer into a multi-digit character string.
   2061          *
   2062          * Argument(s) : nbr             Number           to format.
   2063          *
   2064          *               nbr_dig         Number of digits to format (see Note #1).
   2065          *
   2066          *                               The following may be used to specify the number of digits to format :
   2067          *
   2068          *                                   DEF_INT_32S_NBR_DIG_MIN + 1     Minimum number of 32-bit signed digits
   2069          *                                   DEF_INT_32S_NBR_DIG_MAX + 1     Maximum number of 32-bit signed digits
   2070          *                                                                   (plus 1 digit for possible negative sign)
   2071          *
   2072          *               nbr_base        Base   of number to format (see Note #2).
   2073          *
   2074          *                               The following may be used to specify the number base :
   2075          *
   2076          *                                   DEF_NBR_BASE_BIN            Base  2
   2077          *                                   DEF_NBR_BASE_OCT            Base  8
   2078          *                                   DEF_NBR_BASE_DEC            Base 10
   2079          *                                   DEF_NBR_BASE_HEX            Base 16
   2080          *
   2081          *               lead_char       Prepend leading character  (see Note #3) :
   2082          *
   2083          *                                   '\0'                    Do NOT prepend leading character to string.
   2084          *                                     Printable character          Prepend leading character to string.
   2085          *                                   Unprintable character   Format invalid string (see Note #6).
   2086          *
   2087          *               lower_case      Format alphabetic characters (if any) in lower case :
   2088          *
   2089          *                                   DEF_NO          Format alphabetic characters in upper case.
   2090          *                                   DEF_YES         Format alphabetic characters in lower case.
   2091          *
   2092          *               nul             Append terminating NULL-character (see Note #4) :
   2093          *
   2094          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2095          *                                   DEF_YES                Append terminating NULL-character to string.
   2096          *
   2097          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2098          *
   2099          * Return(s)   : Pointer to formatted string, if NO error(s).
   2100          *
   2101          *               Pointer to NULL,             otherwise.
   2102          *
   2103          * Caller(s)   : Application.
   2104          *
   2105          * Note(s)     : (1) (a) If the number of digits to format ('nbr_dig') is zero; then NO formatting
   2106          *                       is performed except possible NULL-termination of the string (see Note #4).
   2107          *
   2108          *                           Example :
   2109          *
   2110          *                               nbr      = -23456
   2111          *                               nbr_dig  =  0
   2112          *                               nbr_base = 10
   2113          *
   2114          *                               pstr     = ""                   See Note #6a
   2115          *
   2116          *                   (b) If the number of digits to format ('nbr_dig') is less than the number of
   2117          *                       significant integer digits of the number to format ('nbr'); then an invalid
   2118          *                       string is formatted instead of truncating any significant integer digits.
   2119          *
   2120          *                           Example :
   2121          *
   2122          *                               nbr      = 23456
   2123          *                               nbr_dig  = 3
   2124          *                               nbr_base = 10
   2125          *
   2126          *                               pstr     = "???"                See Note #6b
   2127          *
   2128          *                   (c) If the number to format ('nbr') is negative but the number of digits to format
   2129          *                       ('nbr_dig') is equal to the number of significant integer digits of the number
   2130          *                       to format ('nbr'); then an invalid string is formatted instead of truncating
   2131          *                       the negative sign.
   2132          *
   2133          *                           Example :
   2134          *
   2135          *                               nbr      = -23456
   2136          *                               nbr_dig  =  5
   2137          *                               nbr_base = 10
   2138          *
   2139          *                               pstr     = "?????"              See Note #6b
   2140          *
   2141          *               (2) The number's base MUST be between 2 & 36, inclusive.
   2142          *
   2143          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2144          *
   2145          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2146          *
   2147          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   2148          *                           (B) with the exception of '0'.
   2149          *
   2150          *                   (b) (1) The number of leading characters is such that the total number of significant
   2151          *                           integer digits plus the number of leading characters plus possible negative
   2152          *                           sign character is equal to the requested number of integer digits to format
   2153          *                           ('nbr_dig').
   2154          *
   2155          *                               Examples :
   2156          *
   2157          *                                   nbr       = 23456
   2158          *                                   nbr_dig   = 7
   2159          *                                   nbr_base  = 10
   2160          *                                   lead_char = ' '
   2161          *
   2162          *                                   pstr      = "  23456"
   2163          *
   2164          *
   2165          *                                   nbr       = -23456
   2166          *                                   nbr_dig   =  7
   2167          *                                   nbr_base  = 10
   2168          *                                   lead_char = ' '
   2169          *
   2170          *                                   pstr      = " -23456"
   2171          *
   2172          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
   2173          *                               ('lead_char') is     a '0' digit; then the negative sign character
   2174          *                               prefixes all leading characters prior to the formatted number.
   2175          *
   2176          *                                   Examples :
   2177          *
   2178          *                                       nbr        = -23456
   2179          *                                       nbr_dig    =  8
   2180          *                                       nbr_base   = 10
   2181          *                                       lead_char  = '0'
   2182          *
   2183          *                                       pstr       = "-0023456"
   2184          *
   2185          *
   2186          *                                       nbr        = -43981
   2187          *                                       nbr_dig    =  8
   2188          *                                       nbr_base   = 16
   2189          *                                       lead_char  = '0'
   2190          *                                       lower_case = DEF_NO
   2191          *
   2192          *                                       pstr       = "-000ABCD"
   2193          *
   2194          *                           (B) If the number to format ('nbr') is negative AND the leading character
   2195          *                               ('lead_char') is NOT a '0' digit; then the negative sign character
   2196          *                               immediately prefixes the most significant digit of the formatted number.
   2197          *
   2198          *                                   Examples :
   2199          *
   2200          *                                       nbr        = -23456
   2201          *                                       nbr_dig    =  8
   2202          *                                       nbr_base   = 10
   2203          *                                       lead_char  = '#'
   2204          *
   2205          *                                       pstr       = "##-23456"
   2206          *
   2207          *
   2208          *                                       nbr        = -43981
   2209          *                                       nbr_dig    =  8
   2210          *                                       nbr_base   = 16
   2211          *                                       lead_char  = '#'
   2212          *                                       lower_case = DEF_YES
   2213          *
   2214          *                                       pstr       = "###-abcd"
   2215          *
   2216          *                   (c) (1) If the value of the number to format is     zero  ...
   2217          *                       (2) ... & the number of digits to format is non-zero, ...
   2218          *                       (3) ... but NO leading character available;           ...
   2219          *                       (4) ... then one digit of '0' value is formatted.
   2220          *
   2221          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2222          *
   2223          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2224          *                       array formatting.
   2225          *
   2226          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2227          *                       terminate option DISABLED will cause character string run-on.
   2228          *
   2229          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2230          *
   2231          *                   (b) To prevent character buffer overrun :
   2232          *
   2233          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2234          *                                                               1 negative sign   +
   2235          *                                                               1 'NUL' terminator)  characters
   2236          *
   2237          *               (6) For any unsuccessful string format or error(s), an invalid string of question marks
   2238          *                   ('?') will be formatted, where the number of question marks is determined by the
   2239          *                   number of digits to format ('nbr_dig') :
   2240          *
   2241          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   2242          *                          number of     =  {
   2243          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   2244          *
   2245          *********************************************************************************************************
   2246          */
   2247          

   \                                 In section .text, align 2, keep-with-next
   2248          CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
   2249                                        CPU_INT08U    nbr_dig,
   2250                                        CPU_INT08U    nbr_base,
   2251                                        CPU_CHAR      lead_char,
   2252                                        CPU_BOOLEAN   lower_case,
   2253                                        CPU_BOOLEAN   nul,
   2254                                        CPU_CHAR     *pstr)
   2255          {
   \                     Str_FmtNbr_Int32S: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   2256              CPU_CHAR     *pstr_fmt;
   2257              CPU_INT32S    nbr_fmt;
   2258              CPU_BOOLEAN   nbr_neg;
   2259          
   2260          
   2261              if (nbr < 0) {                                              /* If nbr neg, ...                                      */
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD502             BPL.N    ??Str_FmtNbr_Int32S_0
   2262                  nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
   \   00000008   0x4240             RSBS     R0,R0,#+0
   2263                  nbr_neg =  DEF_YES;
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0xE000             B.N      ??Str_FmtNbr_Int32S_1
   2264              } else {
   2265                  nbr_fmt =  nbr;
   2266                  nbr_neg =  DEF_NO;
   \                     ??Str_FmtNbr_Int32S_0: (+1)
   \   0000000E   0x2400             MOVS     R4,#+0
   \                     ??Str_FmtNbr_Int32S_1: (+1)
   \   00000010   0x9F0C             LDR      R7,[SP, #+48]
   \   00000012   0x9D0B             LDR      R5,[SP, #+44]
   \   00000014   0x9E0A             LDR      R6,[SP, #+40]
   2267              }
   2268          
   2269              pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
   2270                                                      nbr_dig,
   2271                                                      nbr_base,
   2272                                                      nbr_neg,
   2273                                                      lead_char,
   2274                                                      lower_case,
   2275                                                      nul,
   2276                                                      pstr);
   \   00000016   0x9703             STR      R7,[SP, #+12]
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x9502             STR      R5,[SP, #+8]
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x9601             STR      R6,[SP, #+4]
   \   00000020   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000022   0x9300             STR      R3,[SP, #+0]
   \   00000024   0x0023             MOVS     R3,R4
   \   00000026   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x.... 0x....      BL       Str_FmtNbr_Int32
   2277          
   2278              return (pstr_fmt);
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBDF0             POP      {R4-R7,PC}       ;; return
   2279          }
   2280          
   2281          
   2282          /*
   2283          *********************************************************************************************************
   2284          *                                           Str_FmtNbr_32()
   2285          *
   2286          * Description : Format number into a multi-digit character string.
   2287          *
   2288          * Argument(s) : nbr             Number                         to format (see Note #1).
   2289          *
   2290          *               nbr_dig         Number of decimal       digits to format (see Note #2).
   2291          *
   2292          *               nbr_dp          Number of decimal point digits to format.
   2293          *
   2294          *               lead_char       Prepend leading character (see Note #3) :
   2295          *
   2296          *                                   '\0'                    Do NOT prepend leading character to string.
   2297          *                                     Printable character          Prepend leading character to string.
   2298          *                                   Unprintable character   Format invalid string (see Note #6d).
   2299          *
   2300          *               nul             Append terminating NULL-character (see Note #4) :
   2301          *
   2302          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   2303          *                                   DEF_YES                Append terminating NULL-character to string.
   2304          *
   2305          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   2306          *
   2307          * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6c].
   2308          *
   2309          *               Pointer to NULL,             otherwise.
   2310          *
   2311          * Caller(s)   : Application.
   2312          *
   2313          * Note(s)     : (1) (a) The maximum accuracy for 32-bit floating-point numbers :
   2314          *
   2315          *
   2316          *                                 Maximum Accuracy            log [Internal-Base ^ (Number-Internal-Base-Digits)]
   2317          *                           32-bit Floating-point Number  =  -----------------------------------------------------
   2318          *                                                                             log [External-Base]
   2319          *
   2320          *                                                             log [2 ^ 24]
   2321          *                                                         =  --------------
   2322          *                                                               log [10]
   2323          *
   2324          *                                                         <  7.225  Base-10 Digits
   2325          *
   2326          *                               where
   2327          *                                       Internal-Base                   Internal number base of floating-
   2328          *                                                                           point numbers (i.e.  2)
   2329          *                                       External-Base                   External number base of floating-
   2330          *                                                                           point numbers (i.e. 10)
   2331          *                                       Number-Internal-Base-Digits     Number of internal number base
   2332          *                                                                           significant digits (i.e. 24)
   2333          *
   2334          *                   (b) Some CPUs' &/or compilers' floating-point implementations MAY further reduce the
   2335          *                       maximum accuracy.
   2336          *
   2337          *               (2) (a) If the total number of digits to format ('nbr_dig + nbr_dp') is zero; then NO
   2338          *                       formatting is performed except possible NULL-termination of the string (see Note #4).
   2339          *
   2340          *                           Example :
   2341          *
   2342          *                               nbr     = -23456.789
   2343          *                               nbr_dig =  0
   2344          *                               nbr_dp  =  0
   2345          *
   2346          *                               pstr    = ""                        See Note #7a
   2347          *
   2348          *                   (b) (1) If the number of digits to format ('nbr_dig') is less than the number of
   2349          *                           significant integer digits of the number to format ('nbr'); then an invalid
   2350          *                           string is formatted instead of truncating any significant integer digits.
   2351          *
   2352          *                               Example :
   2353          *
   2354          *                                   nbr     = 23456.789
   2355          *                                   nbr_dig = 3
   2356          *                                   nbr_dp  = 2
   2357          *
   2358          *                                   pstr    = "??????"              See Note #7d
   2359          *
   2360          *                       (2) If the number to format ('nbr') is negative but the number of digits to format
   2361          *                           ('nbr_dig') is equal to the number of significant integer digits of the number
   2362          *                           to format ('nbr'); then an invalid string is formatted instead of truncating
   2363          *                           the negative sign.
   2364          *
   2365          *                               Example :
   2366          *
   2367          *                                   nbr     = -23456.789
   2368          *                                   nbr_dig =  5
   2369          *                                   nbr_dp  =  2
   2370          *
   2371          *                                   pstr    = "????????"            See Note #7d
   2372          *
   2373          *                       (3) If the number to format ('nbr') is negative but the number of significant
   2374          *                           integer digits is zero, & the number of digits to format ('nbr_dig') is one
   2375          *                           but the number of decimal point digits to format ('nbr_dp') is zero; then
   2376          *                           an invalid string is formatted instead of truncating the negative sign.
   2377          *
   2378          *                               Example :
   2379          *
   2380          *                                   nbr     = -0.7895
   2381          *                                   nbr_dig =  1
   2382          *                                   nbr_dp  =  0
   2383          *
   2384          *                                   pstr    = "?"                   See Note #7d
   2385          *
   2386          *                       (4) (A) If the number to format ('nbr') is negative but the number of significant
   2387          *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
   2388          *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
   2389          *                               zero; then the negative sign immediately prefixes the decimal point --
   2390          *                               with NO decimal digits formatted, NOT even a single decimal digit of '0'.
   2391          *
   2392          *                                   Example :
   2393          *
   2394          *                                       nbr     = -0.7895
   2395          *                                       nbr_dig =  0
   2396          *                                       nbr_dp  =  2
   2397          *
   2398          *                                       pstr    = "-.78"
   2399          *
   2400          *                           (B) If the number to format ('nbr') is positive but the number of significant
   2401          *                               integer digits is zero, & the number of digits to format ('nbr_dig') is
   2402          *                               zero but the number of decimal point digits to format ('nbr_dp') is non-
   2403          *                               zero; then a single decimal digit of '0' prefixes the decimal point.
   2404          *
   2405          *                               This '0' digit is used whenever a negative sign is not formatted (see
   2406          *                               Note #2b4A) so that the formatted string's decimal point is not floating,
   2407          *                               but fixed in the string as the 2nd character.
   2408          *
   2409          *                                   Example :
   2410          *
   2411          *                                       nbr     =  0.7895
   2412          *                                       nbr_dig =  0
   2413          *                                       nbr_dp  =  2
   2414          *
   2415          *                                       pstr    = "0.78"
   2416          *
   2417          *                   (c) (1) If the total number of digits to format ('nbr_dig + nbr_dp') is greater than ... :
   2418          *
   2419          *                           (A) ... the maximum accuracy of the CPU's &/or compiler's 32-bit floating-point
   2420          *                               numbers, digits following all significantly-accurate digits of the number to
   2421          *                               format ('nbr') will be inaccurate; ...
   2422          *                           (B) ... the configured maximum accuracy ('LIB_STR_CFG_FP_MAX_NBR_DIG_SIG'), all
   2423          *                               digits or decimal places following all significantly-accurate digits of the
   2424          *                               number to format ('nbr') will be replaced & formatted with zeros ('0').
   2425          *
   2426          *                                   Example :
   2427          *
   2428          *                                       nbr                            = 123456789.012345
   2429          *                                       nbr_dig                        = 9
   2430          *                                       nbr_dp                         = 6
   2431          *                                       LIB_STR_CFG_FP_MAX_NBR_DIG_SIG = 7
   2432          *
   2433          *                                       pstr                           = "123456700.000000"
   2434          *
   2435          *                       (2) Therefore, one or more least-significant digit(s) of the number to format ('nbr')
   2436          *                           MAY be rounded & not necessarily truncated due to the inaccuracy of the CPU's
   2437          *                           &/or compiler's floating-point implementation.
   2438          *
   2439          *                       See also Note #1.
   2440          *
   2441          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   2442          *
   2443          *                   (a) (1) Leading character MUST be a printable ASCII character.
   2444          *
   2445          *                       (2) (A) Leading character MUST NOT be a base-10 digit, ...
   2446          *                           (B) with the exception of '0'.
   2447          *
   2448          *                   (b) (1) The number of leading characters is such that the total number of significant
   2449          *                           integer digits plus the number of leading characters plus possible negative
   2450          *                           sign character is equal to the requested number of integer digits to format
   2451          *                           ('nbr_dig').
   2452          *
   2453          *                               Examples :
   2454          *
   2455          *                                   nbr       = 23456.789
   2456          *                                   nbr_dig   = 7
   2457          *                                   nbr_dp    = 2
   2458          *                                   lead_char = ' '
   2459          *
   2460          *                                   pstr      = "  23456.78"
   2461          *
   2462          *
   2463          *                                   nbr       = -23456.789
   2464          *                                   nbr_dig   =  7
   2465          *                                   nbr_dp    =  2
   2466          *                                   lead_char = ' '
   2467          *
   2468          *                                   pstr      = " -23456.78"
   2469          *
   2470          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
   2471          *                               ('lead_char') is     a '0' digit; then the negative sign character
   2472          *                               prefixes all leading characters prior to the formatted number.
   2473          *
   2474          *                                   Example :
   2475          *
   2476          *                                       nbr       = -23456.789
   2477          *                                       nbr_dig   =  8
   2478          *                                       nbr_dp    =  2
   2479          *                                       lead_char = '0'
   2480          *
   2481          *                                       pstr      = "-0023456.78"
   2482          *
   2483          *                           (B) If the number to format ('nbr') is negative AND the leading character
   2484          *                               ('lead_char') is NOT a '0' digit; then the negative sign character
   2485          *                               immediately prefixes the most significant digit of the formatted number.
   2486          *
   2487          *                                   Examples :
   2488          *
   2489          *                                       nbr       = -23456.789
   2490          *                                       nbr_dig   =  8
   2491          *                                       nbr_dp    =  2
   2492          *                                       lead_char = '#'
   2493          *
   2494          *                                       pstr      = "##-23456.78"
   2495          *
   2496          *                   (c) (1) If the integer value of the number to format is zero & ...
   2497          *                       (2) ... the number of digits to format is greater than one ...
   2498          *                       (3) ... OR  the number is NOT negative,                    ...
   2499          *                       (4) ... but NO leading character available;                ...
   2500          *                       (5) ... then one digit of '0' value is formatted.
   2501          *
   2502          *                           This is NOT a leading character; but a single integer digit of '0' value.
   2503          *
   2504          *                       See also Note #2b4B.
   2505          *
   2506          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   2507          *                       array formatting.
   2508          *
   2509          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   2510          *                       terminate option DISABLED will cause character string run-on.
   2511          *
   2512          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   2513          *
   2514          *                   (b) To prevent character buffer overrun :
   2515          *
   2516          *                           Character array size MUST be  >=  ('nbr_dig'          +
   2517          *                                                              'nbr_dp'           +
   2518          *                                                               1 negative sign   +
   2519          *                                                               1 decimal point   +
   2520          *                                                               1 'NUL' terminator)  characters
   2521          *
   2522          *               (6) String format terminates when :
   2523          *
   2524          *                   (a) Format string pointer is passed a NULL pointer.
   2525          *                       (1) No      string formatted;                NULL pointer returned.
   2526          *
   2527          *                   (b) Total number of digits to format ('nbr_dig + nbr_dp') is zero.
   2528          *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
   2529          *
   2530          *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
   2531          *                           integer digits of the number to format ('nbr'), including possible
   2532          *                           negative sign.
   2533          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   2534          *
   2535          *                   (d) Lead character is NOT a valid, printable character (see Note #3a).
   2536          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   2537          *
   2538          *                   (e) Number successfully formatted into character string array.
   2539          *
   2540          *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
   2541          *                   ('?') will be formatted, where the number of question marks is determined by the
   2542          *                   number of digits ('nbr_dig') & number of decimal point digits ('nbr_dp') to format :
   2543          *
   2544          *                                           {  (a)    0 (NULL string)          ,  if 'nbr_dig' = 0  AND
   2545          *                                           {                                        'nbr_dp'  = 0
   2546          *                                           {
   2547          *                                           {  (b)   'nbr_dig'                 ,  if 'nbr_dig' > 0  AND
   2548          *                                           {                                        'nbr_dp'  = 0
   2549          *                      Invalid string's     {
   2550          *                          number of     =  {  (c)  ['nbr_dp'               +  ,  if 'nbr_dig' = 0  AND
   2551          *                       question marks      {         1 (for decimal point) +        'nbr_dp'  > 0
   2552          *                                           {         1 (for negative sign) ]
   2553          *                                           {
   2554          *                                           {  (d)  ['nbr_dig'              +  ,  if 'nbr_dig' > 0  AND
   2555          *                                           {        'nbr_dp'               +        'nbr_dp'  > 0
   2556          *                                           {         1 (for decimal point) ]
   2557          *
   2558          *********************************************************************************************************
   2559          */
   2560          
   2561          #if (LIB_STR_CFG_FP_EN == DEF_ENABLED)
   2562          CPU_CHAR  *Str_FmtNbr_32 (CPU_FP32      nbr,
   2563                                    CPU_INT08U    nbr_dig,
   2564                                    CPU_INT08U    nbr_dp,
   2565                                    CPU_CHAR      lead_char,
   2566                                    CPU_BOOLEAN   nul,
   2567                                    CPU_CHAR     *pstr)
   2568          {
   2569              CPU_CHAR     *pstr_fmt;
   2570              CPU_DATA      i;
   2571              CPU_FP32      nbr_fmt;
   2572              CPU_FP32      nbr_log;
   2573              CPU_INT32U    nbr_shiftd;
   2574              CPU_INT16U    nbr_dig_max;
   2575              CPU_INT16U    nbr_dig_sig    = 0;
   2576              CPU_INT08U    nbr_neg_sign;
   2577              CPU_INT08U    dig_val;
   2578              CPU_FP32      dig_exp;
   2579              CPU_FP32      dp_exp;
   2580              CPU_BOOLEAN   lead_char_dig;
   2581              CPU_BOOLEAN   lead_char_fmtd = DEF_NO;
   2582              CPU_BOOLEAN   lead_char_0;
   2583              CPU_BOOLEAN   fmt_invalid;
   2584              CPU_BOOLEAN   print_char;
   2585              CPU_BOOLEAN   nbr_neg;
   2586              CPU_BOOLEAN   nbr_neg_fmtd   = DEF_NO;
   2587          
   2588          
   2589                                                                          /* ---------------- VALIDATE FMT ARGS ----------------- */
   2590              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   2591                  return ((CPU_CHAR *)0);
   2592              }
   2593          
   2594              dig_exp     =  1.0f;
   2595              fmt_invalid =  DEF_NO;
   2596              lead_char_0 = (lead_char == '0') ? DEF_YES : DEF_NO;        /* Chk if lead char a '0' dig (see Note #3b2).          */
   2597              nbr_fmt     =  0.0f;
   2598              nbr_neg     =  DEF_NO;
   2599          
   2600              if ((nbr_dig < 1) && (nbr_dp < 1)) {                        /* If nbr digs/dps = 0, ...                             */
   2601                  fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
   2602              }
   2603          
   2604              if (lead_char != (CPU_CHAR)'\0') {
   2605                  print_char =  ASCII_IsPrint(lead_char);
   2606                  if (print_char != DEF_YES) {                            /* If lead char non-printable  (see Note #3a1), ...     */
   2607                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str         (see Note #6d).          */
   2608          
   2609                  } else if (lead_char != '0') {                          /* Chk lead char for non-0 dig.                         */
   2610                      lead_char_dig = ASCII_IsDig(lead_char);
   2611                      if (lead_char_dig == DEF_YES) {                     /* If  lead char     non-0 dig (see Note #3a2A), ...    */
   2612                          fmt_invalid = DEF_YES;                          /* ... fmt invalid str         (see Note #6d).          */
   2613                      }
   2614                  }
   2615              }
   2616          
   2617          
   2618                                                                          /* ----------------- PREPARE NBR FMT ------------------ */
   2619              pstr_fmt = pstr;
   2620          
   2621              if (fmt_invalid == DEF_NO) {
   2622                  if (nbr < 0.0f) {                                       /* If nbr neg, ...                                      */
   2623                      nbr_fmt      = -nbr;                                /* ... negate nbr.                                      */
   2624                      nbr_neg_sign =  1u;
   2625                      nbr_neg      =  DEF_YES;
   2626                  } else {
   2627                      nbr_fmt      =  nbr;
   2628                      nbr_neg_sign =  0u;
   2629                      nbr_neg      =  DEF_NO;
   2630                  }
   2631          
   2632                  nbr_log     = nbr_fmt;
   2633                  nbr_dig_max = 0u;
   2634                  while (nbr_log >= 1.0f) {                               /* While base-10 digs avail, ...                        */
   2635                      nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
   2636                      nbr_log /= 10.0f;
   2637                  }
   2638          
   2639                  if (((nbr_dig >= (nbr_dig_max + nbr_neg_sign)) ||       /* If req'd nbr digs >= (max nbr digs + neg sign)    .. */
   2640                       (nbr_dig_max < 1))                        &&       /* .. or NO nbr digs,                                .. */
   2641                      ((nbr_dig     > 1) ||                               /* .. but NOT [(req'd nbr dig = 1) AND               .. */
   2642                       (nbr_dp      > 0) ||                               /* ..          (req'd nbr dp  = 0) AND               .. */
   2643                       (nbr_neg == DEF_NO))) {                            /* ..          (      nbr neg    )]   (see Note #2b3).  */
   2644                                                                          /* .. prepare nbr digs to fmt.                          */
   2645                      for (i = 1u; i < nbr_dig; i++) {
   2646                          dig_exp *= 10.0f;
   2647                      }
   2648          
   2649                      nbr_neg_fmtd   =  DEF_NO;
   2650                      nbr_dig_sig    =  0u;
   2651                      lead_char_fmtd =  DEF_NO;
   2652                  } else {                                                /* Else if nbr trunc'd, ...                             */
   2653                      fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
   2654                  }
   2655              }
   2656          
   2657          
   2658                                                                          /* ------------------- FMT NBR STR -------------------- */
   2659              for (i = nbr_dig; i > 0; i--) {                             /* Fmt str for desired nbr digs :                       */
   2660                  if (fmt_invalid == DEF_NO) {
   2661                      if (nbr_dig_sig < LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) { /* If nbr sig digs < max, fmt str digs;           ...   */
   2662                          nbr_shiftd = (CPU_INT32U)(nbr_fmt / dig_exp);
   2663                          if ((nbr_shiftd > 0) ||                         /* If shifted nbr > 0                          ...      */
   2664                              (i == 1u)) {                                /* ... OR on one's dig to fmt (see Note #3c1), ...      */
   2665                                                                          /* ... calc & fmt dig val;                     ...      */
   2666                              if ((nbr_neg      == DEF_YES) &&            /* If  nbr neg                     ...                  */
   2667                                  (nbr_neg_fmtd == DEF_NO )) {            /* ... but neg sign NOT yet fmt'd; ...                  */
   2668          
   2669                                  if (lead_char_fmtd == DEF_YES) {        /* ... & if lead char(s) fmt'd,    ...                  */
   2670                                      pstr_fmt--;                         /* ... replace last lead char w/   ...                  */
   2671                                  }
   2672                                 *pstr_fmt++   = '-';                     /* ... prepend neg sign (see Notes #2b & #3b).          */
   2673                                  nbr_neg_fmtd = DEF_YES;
   2674                              }
   2675          
   2676                              if (nbr_shiftd > 0) {                       /* If shifted nbr > 0,        ...                       */
   2677                                  dig_val    = (CPU_INT08U)(nbr_shiftd % 10u);
   2678                                 *pstr_fmt++ = (CPU_CHAR  )(dig_val    + '0');
   2679          
   2680                                  nbr_dig_sig++;                          /* ... inc nbr sig digs;      ...                       */
   2681          
   2682                              } else if ((nbr_dig > 1) ||                 /* ... else if req'd digs > 1 ...                       */
   2683                                         (nbr_neg == DEF_NO)) {           /* ... or non-neg nbr,        ...                       */
   2684                                 *pstr_fmt++ = '0';                       /* ... fmt one '0' char (see Note #3c5).                */
   2685                              }
   2686          
   2687                          } else if ((nbr_neg      == DEF_YES) &&         /* ... else if nbr neg                         ...      */
   2688                                     (lead_char_0  == DEF_YES) &&         /* ... & lead char a '0' dig                   ...      */
   2689                                     (nbr_neg_fmtd == DEF_NO )) {         /* ... but neg sign NOT yet fmt'd,             ...      */
   2690          
   2691                             *pstr_fmt++   = '-';                         /* ... prepend neg sign (see Note #3b);        ...      */
   2692                              nbr_neg_fmtd = DEF_YES;
   2693          
   2694                          } else if (lead_char != (CPU_CHAR)'\0') {       /* ... else if avail,                          ...      */
   2695                             *pstr_fmt++     = lead_char;                 /* ... fmt lead char.                                   */
   2696                              lead_char_fmtd = DEF_YES;
   2697                          }
   2698          
   2699                          dig_exp /= 10.0f;                               /* Shift to next least-sig dig.                         */
   2700          
   2701                      } else {                                            /* ... else append non-sig 0's (see Note #2c2).         */
   2702                         *pstr_fmt++ = '0';
   2703                      }
   2704          
   2705                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   2706                     *pstr_fmt++ = '?';
   2707                  }
   2708              }
   2709          
   2710          
   2711              if (nbr_dp > 0) {                                           /* Fmt str for desired nbr dp :                         */
   2712                  if (nbr_dig < 1) {                                      /* If NO digs fmt'd;                             ...    */
   2713                      if (fmt_invalid == DEF_NO) {                        /* ... nbr fmt valid,                            ...    */
   2714                          if ((nbr_neg      == DEF_YES) &&                /* ... nbr neg                                   ...    */
   2715                              (nbr_neg_fmtd == DEF_NO )) {                /* ... but neg sign NOT yet fmt'd,               ...    */
   2716                              *pstr_fmt++ = '-';                          /* ... prepend neg sign (see Notes #2b & #3b);   ...    */
   2717                          } else {                                        /* ... else prepend 1 dig of '0' (see Note #3c5) ...    */
   2718                              *pstr_fmt++ = '0';
   2719                          }
   2720                      } else {                                            /* ... else fmt '?' for invalid str (see Note #7).      */
   2721                          *pstr_fmt++ = '?';
   2722                      }
   2723                  }
   2724          
   2725                  if (fmt_invalid == DEF_NO) {                            /* If nbr fmt valid, ...                                */
   2726                     *pstr_fmt++ = '.';                                   /* ... append dp prior to dp conversion.                */
   2727                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   2728                     *pstr_fmt++ = '?';
   2729                  }
   2730          
   2731                  dp_exp = 10.0f;
   2732                  for (i = 0u; i < nbr_dp; i++) {
   2733                      if (fmt_invalid == DEF_NO) {
   2734                                                                          /* If nbr sig digs < max, fmt str dps;    ...           */
   2735                          if (nbr_dig_sig <  LIB_STR_CFG_FP_MAX_NBR_DIG_SIG) {
   2736                              nbr_shiftd  = (CPU_INT32U)(nbr_fmt * dp_exp);
   2737                              dig_val     = (CPU_INT08U)(nbr_shiftd % 10u);
   2738                             *pstr_fmt++  = (CPU_CHAR  )(dig_val    + '0');
   2739                              dp_exp     *=  10.0f;                       /* Shift to next least-sig dp.                          */
   2740          
   2741                              if ((nbr_shiftd  > 0) ||                    /* If shifted nbr > 0                  ...              */
   2742                                  (nbr_dig_sig > 0)) {                    /* ... OR  > 0 sig digs already fmt'd, ...              */
   2743                                   nbr_dig_sig++;                         /* ... inc nbr sig digs.                                */
   2744                              }
   2745          
   2746                          } else {                                        /* ... else append non-sig 0's (see Note #2c2).         */
   2747                             *pstr_fmt++ = '0';
   2748                          }
   2749          
   2750                      } else {                                            /* Else fmt '?' for invalid str (see Note #7).          */
   2751                         *pstr_fmt++ = '?';
   2752                      }
   2753                  }
   2754              }
   2755          
   2756          
   2757              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   2758                 *pstr_fmt = (CPU_CHAR)'\0';
   2759              }
   2760          
   2761          
   2762              if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6d).  */
   2763                  return ((CPU_CHAR *)0);
   2764              }
   2765          
   2766          
   2767              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6e).                 */
   2768          }
   2769          #endif
   2770          
   2771          
   2772          /*
   2773          *********************************************************************************************************
   2774          *                                        Str_ParseNbr_Int32U()
   2775          *
   2776          * Description : Parse 32-bit unsigned integer from string.
   2777          *
   2778          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   2779          *
   2780          *               pstr_next   Optional pointer to a variable to ... :
   2781          *
   2782          *                               (a) Return a pointer to first character following the integer string,
   2783          *                                       if NO error(s) [see Note #2a2B2];
   2784          *                               (b) Return a pointer to 'pstr',
   2785          *                                       otherwise      (see Note #2a2A2).
   2786          *
   2787          *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
   2788          *
   2789          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   2790          *
   2791          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   2792          *
   2793          *               0,                   otherwise                            (see Note #2a3B).
   2794          *
   2795          * Caller(s)   : Application.
   2796          *
   2797          * Note(s)     : (1) String buffer NOT modified.
   2798          *
   2799          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : DESCRIPTION' states that "these
   2800          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
   2801          *                       to a type unsigned long ... representation" :
   2802          *
   2803          *                       (1) "First, they decompose the input string into three parts" :
   2804          *
   2805          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   2806          *                                by isspace()]."
   2807          *
   2808          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   2809          *                                    input string, starting with the first non-white-space character that is of
   2810          *                                    the expected form.  The subject sequence shall contain no characters if the
   2811          *                                    input string is empty or consists entirely of white-space characters."
   2812          *
   2813          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   2814          *                                    determined by the value of 'base' ('nbr_base')" :
   2815          *
   2816          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   2817          *                                        subject sequence is that of a decimal constant, octal constant, or
   2818          *                                        hexadecimal constant" :
   2819          *
   2820          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   2821          *                                            sequence of decimal digits."
   2822          *
   2823          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   2824          *                                            a sequence of the digits '0' to '7' only."
   2825          *
   2826          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   2827          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   2828          *                                            (or 'F') with values 10 to 15 respectively."
   2829          *
   2830          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
   2831          *                                        of the subject sequence is a sequence of letters and digits representing
   2832          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   2833          *
   2834          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   2835          *                                                ascribed the values 10 to 35"; ...
   2836          *                                           (B) "only letters whose ascribed values are less than that of base
   2837          *                                                are permitted."
   2838          *
   2839          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
   2840          *                                                '0X' may optionally precede the sequence of letters and digits."
   2841          *
   2842          *                                           (B) Although NO specification states that "if the value of 'base'
   2843          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
   2844          *                                               the sequence of letters and digits"; it seems reasonable to
   2845          *                                               allow the '0' character to be optionally parsed.
   2846          *
   2847          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   2848          *
   2849          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   2850          *                                       integer string into an unsigned integer.
   2851          *
   2852          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   2853          *                                   (b) "including the terminating null byte of the input string" ...
   2854          *                               (2) "other than a sign or a permissible letter or digit."
   2855          *
   2856          *                       (2) Second, "they shall attempt to convert the subject sequence to an unsigned integer" :
   2857          *
   2858          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   2859          *
   2860          *                               (1) "no conversion [is] performed"; ...
   2861          *                               (2) "the value of 'str' ('pstr') [is] stored in the object pointed to by 'endptr'
   2862          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   2863          *
   2864          *                           (B) "If the subject sequence has the expected form" :
   2865          *
   2866          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
   2867          *                                        starting with the first digit shall be interpreted as an integer constant."
   2868          *
   2869          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
   2870          *                                        used as the base for conversion, ascribing to each letter its value as
   2871          *                                        given above" (see Note #2a1B1b1A).
   2872          *
   2873          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   2874          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
   2875          *                                   pointer."
   2876          *
   2877          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : RETURN VALUE' states that :
   2878          *
   2879          *                           (A) "Upon successful completion, these functions shall return the converted value."
   2880          *                               (1) "If the correct value is outside the range of representable values, {ULONG_MAX}
   2881          *                                    ... shall be returned."
   2882          *
   2883          *                           (B) "If no conversion could be performed, 0 shall be returned."
   2884          *
   2885          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2886          *                           shall fail if" :
   2887          *
   2888          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   2889          *
   2890          *                           (B) "[ERANGE] - The value to be returned is not representable."
   2891          *
   2892          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   2893          *                           may fail if" :
   2894          *
   2895          *                           (A) "[EINVAL] - No conversion could be performed."
   2896          *
   2897          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   2898          *
   2899          *                   (a) Valid parse string integer :
   2900          *
   2901          *                           pstr      = "     ABCDE xyz"
   2902          *                           nbr_base  = 16
   2903          *
   2904          *                           nbr       = 703710
   2905          *                           pstr_next = " xyz"
   2906          *
   2907          *
   2908          *                   (b) Invalid parse string integer :
   2909          *
   2910          *                           pstr      = "     ABCDE"
   2911          *                           nbr_base  = 10
   2912          *
   2913          *                           nbr       =  0
   2914          *                           pstr_next = pstr = "     ABCDE"
   2915          *
   2916          *
   2917          *                   (c) Valid hexadecimal parse string integer :
   2918          *
   2919          *                           pstr      = "     0xGABCDE"
   2920          *                           nbr_base  = 16
   2921          *
   2922          *                           nbr       =  0
   2923          *                           pstr_next = "xGABCDE"
   2924          *
   2925          *
   2926          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   2927          *                               following invalid hexadecimal characters) :
   2928          *
   2929          *                           pstr      = "     0xGABCDE"
   2930          *                           nbr_base  =  0
   2931          *
   2932          *                           nbr       =  0
   2933          *                           pstr_next = "xGABCDE"
   2934          *
   2935          *
   2936          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   2937          *                               following invalid octal       characters) :
   2938          *
   2939          *                           pstr      = "     0GABCDE"
   2940          *                           nbr_base  =  0
   2941          *
   2942          *                           nbr       =  0
   2943          *                           pstr_next = "GABCDE"
   2944          *
   2945          *
   2946          *                   (f) Parse string integer overflow :
   2947          *
   2948          *                           pstr      = "   12345678901234567890*123456"
   2949          *                           nbr_base  = 10
   2950          *
   2951          *                           nbr       = DEF_INT_32U_MAX_VAL
   2952          *                           pstr_next = "*123456"
   2953          *
   2954          *
   2955          *                   (g) Invalid negative unsigned parse string :
   2956          *
   2957          *                           pstr      = "  -12345678901234567890*123456"
   2958          *                           nbr_base  = 10
   2959          *
   2960          *                           nbr       = 0
   2961          *                           pstr_next = pstr = "  -12345678901234567890*123456"
   2962          *
   2963          *********************************************************************************************************
   2964          */
   2965          

   \                                 In section .text, align 2, keep-with-next
   2966          CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
   2967                                                  CPU_CHAR    **pstr_next,
   2968                                                  CPU_INT08U    nbr_base)
   2969          {
   \                     Str_ParseNbr_Int32U: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2970              CPU_INT32U  nbr;
   2971          
   2972          
   2973              nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
   2974                                                      pstr_next,
   2975                                                      nbr_base,
   2976                                                      DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
   2977                                       (CPU_BOOLEAN *)0);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x9300             STR      R3,[SP, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x.... 0x....      BL       Str_ParseNbr_Int32
   2978          
   2979              return (nbr);
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   2980          }
   2981          
   2982          
   2983          /*
   2984          *********************************************************************************************************
   2985          *                                        Str_ParseNbr_Int32S()
   2986          *
   2987          * Description : Parse 32-bit signed integer from string.
   2988          *
   2989          * Argument(s) : pstr        Pointer to string (see Notes #1 & #2a).
   2990          *
   2991          *               pstr_next   Optional pointer to a variable to ... :
   2992          *
   2993          *                               (a) Return a pointer to first character following the integer string,
   2994          *                                       if NO error(s) [see Note #2a2B2];
   2995          *                               (b) Return a pointer to 'pstr',
   2996          *                                       otherwise      (see Note #2a2A2).
   2997          *
   2998          *               nbr_base    Base of number to parse (see Notes #2a1B1 & #2a2B1).
   2999          *
   3000          * Return(s)   : Parsed integer,      if integer parsed with NO over- or underflow (see Note #2a3A).
   3001          *
   3002          *               DEF_INT_32S_MIN_VAL, if integer parsed but negatively underflowed (see Note #2a3A1a).
   3003          *
   3004          *               DEF_INT_32U_MAX_VAL, if integer parsed but positively overflowed  (see Note #2a3A1b).
   3005          *
   3006          *               0,                   otherwise                                    (see Note #2a3B).
   3007          *
   3008          * Caller(s)   : Application.
   3009          *
   3010          * Note(s)     : (1) String buffer NOT modified.
   3011          *
   3012          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   3013          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
   3014          *                       to a type long ... representation" :
   3015          *
   3016          *                       (1) "First, they decompose the input string into three parts" :
   3017          *
   3018          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   3019          *                                by isspace()]."
   3020          *
   3021          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   3022          *                                    input string, starting with the first non-white-space character that is of
   3023          *                                    the expected form.  The subject sequence shall contain no characters if the
   3024          *                                    input string is empty or consists entirely of white-space characters."
   3025          *
   3026          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   3027          *                                    determined by the value of 'base' ('nbr_base')" :
   3028          *
   3029          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   3030          *                                        subject sequence is that of a decimal constant, octal constant, or
   3031          *                                        hexadecimal constant" :
   3032          *
   3033          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   3034          *                                            sequence of decimal digits."
   3035          *
   3036          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   3037          *                                            a sequence of the digits '0' to '7' only."
   3038          *
   3039          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   3040          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   3041          *                                            (or 'F') with values 10 to 15 respectively."
   3042          *
   3043          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
   3044          *                                        of the subject sequence is a sequence of letters and digits representing
   3045          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   3046          *
   3047          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3048          *                                                ascribed the values 10 to 35"; ...
   3049          *                                           (B) "only letters whose ascribed values are less than that of base
   3050          *                                                are permitted."
   3051          *
   3052          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
   3053          *                                                '0X' may optionally precede the sequence of letters and digits."
   3054          *
   3055          *                                           (B) Although NO specification states that "if the value of 'base'
   3056          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
   3057          *                                               the sequence of letters and digits"; it seems reasonable to
   3058          *                                               allow the '0' character to be optionally parsed.
   3059          *
   3060          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   3061          *
   3062          *                                   (a) However, it does NOT seem reasonable to parse & convert a negative number
   3063          *                                       integer string into an unsigned integer.
   3064          *
   3065          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   3066          *                                   (b) "including the terminating null byte of the input string" ...
   3067          *                               (2) "other than a sign or a permissible letter or digit."
   3068          *
   3069          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   3070          *
   3071          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   3072          *
   3073          *                               (1) "no conversion is performed"; ...
   3074          *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
   3075          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   3076          *
   3077          *                           (B) "If the subject sequence has the expected form" :
   3078          *
   3079          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
   3080          *                                        starting with the first digit shall be interpreted as an integer constant."
   3081          *
   3082          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
   3083          *                                        used as the base for conversion, ascribing to each letter its value as
   3084          *                                        given above" (see Note #2a1B1b1A).
   3085          *
   3086          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   3087          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
   3088          *                                   pointer."
   3089          *
   3090          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   3091          *
   3092          *                           (A) "Upon successful completion, these functions shall return the converted value."
   3093          *
   3094          *                               (1) "If the correct value is outside the range of representable values", either
   3095          *                                    of the following "shall be returned" :
   3096          *                                   (a) "{LONG_MIN}" or ...
   3097          *                                   (b) "{LONG_MAX}"
   3098          *
   3099          *                           (B) "If no conversion could be performed, 0 shall be returned."
   3100          *
   3101          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3102          *                           shall fail if" :
   3103          *
   3104          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   3105          *
   3106          *                           (B) "[ERANGE] - The value to be returned is not representable."
   3107          *
   3108          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3109          *                           may fail if" :
   3110          *
   3111          *                           (A) "[EINVAL] - No conversion could be performed."
   3112          *
   3113          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   3114          *
   3115          *                   (a) Valid parse string integer :
   3116          *
   3117          *                           pstr      = "     ABCDE xyz"
   3118          *                           nbr_base  = 16
   3119          *
   3120          *                           nbr       = 703710
   3121          *                           pstr_next = " xyz"
   3122          *
   3123          *
   3124          *                   (b) Invalid parse string integer :
   3125          *
   3126          *                           pstr      = "     ABCDE"
   3127          *                           nbr_base  = 10
   3128          *
   3129          *                           nbr       =  0
   3130          *                           pstr_next = pstr = "     ABCDE"
   3131          *
   3132          *
   3133          *                   (c) Valid hexadecimal parse string integer :
   3134          *
   3135          *                           pstr      = "     0xGABCDE"
   3136          *                           nbr_base  = 16
   3137          *
   3138          *                           nbr       =  0
   3139          *                           pstr_next = "xGABCDE"
   3140          *
   3141          *
   3142          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   3143          *                               following invalid hexadecimal characters) :
   3144          *
   3145          *                           pstr      = "     0xGABCDE"
   3146          *                           nbr_base  =  0
   3147          *
   3148          *                           nbr       =  0
   3149          *                           pstr_next = "xGABCDE"
   3150          *
   3151          *
   3152          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   3153          *                               following invalid octal       characters) :
   3154          *
   3155          *                           pstr      = "     0GABCDE"
   3156          *                           nbr_base  =  0
   3157          *
   3158          *                           nbr       =  0
   3159          *                           pstr_next = "GABCDE"
   3160          *
   3161          *
   3162          *                   (f) Parse string integer overflow :
   3163          *
   3164          *                           pstr      = "   12345678901234567890*123456"
   3165          *                           nbr_base  = 10
   3166          *
   3167          *                           nbr       = DEF_INT_32S_MAX_VAL
   3168          *                           pstr_next = "*123456"
   3169          *
   3170          *
   3171          *                   (g) Parse string integer underflow :
   3172          *
   3173          *                           pstr      = "  -12345678901234567890*123456"
   3174          *                           nbr_base  = 10
   3175          *
   3176          *                           nbr       = DEF_INT_32S_MIN_VAL
   3177          *                           pstr_next = "*123456"
   3178          *
   3179          *********************************************************************************************************
   3180          */
   3181          

   \                                 In section .text, align 2, keep-with-next
   3182          CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
   3183                                                  CPU_CHAR    **pstr_next,
   3184                                                  CPU_INT08U    nbr_base)
   3185          {
   \                     Str_ParseNbr_Int32S: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
   3186              CPU_INT32S   nbr;
   3187              CPU_INT32U   nbr_abs;
   3188              CPU_BOOLEAN  nbr_neg;
   3189          
   3190          
   3191              nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
   3192                                           pstr_next,
   3193                                           nbr_base,
   3194                                           DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
   3195                                          &nbr_neg);
   \   00000002   0xAB01             ADD      R3,SP,#+4
   \   00000004   0x9300             STR      R3,[SP, #+0]
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x.... 0x....      BL       Str_ParseNbr_Int32
   3196          
   3197              if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
   \   0000000E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD106             BNE.N    ??Str_ParseNbr_Int32S_0
   3198                  nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
   3199                                                                              :  (CPU_INT32S)nbr_abs;
   \   00000016   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   0000001A   0xD302             BCC.N    ??Str_ParseNbr_Int32S_1
   \   0000001C   0xF07F 0x4000      MVNS     R0,#-2147483648
   \   00000020   0xE007             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_1: (+1)
   \   00000022   0xE006             B.N      ??Str_ParseNbr_Int32S_2
   3200              } else {
   3201                  nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
   3202                                                                              : -(CPU_INT32S)nbr_abs;
   \                     ??Str_ParseNbr_Int32S_0: (+1)
   \   00000024   0xF1B0 0x4F00      CMP      R0,#-2147483648
   \   00000028   0xD302             BCC.N    ??Str_ParseNbr_Int32S_3
   \   0000002A   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   0000002E   0xE000             B.N      ??Str_ParseNbr_Int32S_2
   \                     ??Str_ParseNbr_Int32S_3: (+1)
   \   00000030   0x4240             RSBS     R0,R0,#+0
   3203              }
   3204          
   3205              return (nbr);
   \                     ??Str_ParseNbr_Int32S_2: (+1)
   \   00000032   0xBD0E             POP      {R1-R3,PC}       ;; return
   3206          }
   3207          
   3208          
   3209          /*
   3210          *********************************************************************************************************
   3211          *********************************************************************************************************
   3212          *                                           LOCAL FUNCTIONS
   3213          *********************************************************************************************************
   3214          *********************************************************************************************************
   3215          */
   3216          
   3217          /*
   3218          *********************************************************************************************************
   3219          *                                         Str_FmtNbr_Int32()
   3220          *
   3221          * Description : Format 32-bit integer into a multi-digit character string.
   3222          *
   3223          * Argument(s) : nbr             Number           to format.
   3224          *
   3225          *               nbr_dig         Number of digits to format (see Note #1).
   3226          *
   3227          *               nbr_base        Base   of number to format (see Note #2).
   3228          *
   3229          *               nbr_neg         Indicates whether number to format is negative :
   3230          *               -------
   3231          *                                   DEF_NO          Number is non-negative.
   3232          *                                   DEF_YES         Number is     negative.
   3233          *
   3234          *                               Argument validated in Str_FmtNbr_Int32U(),
   3235          *                                                     Str_FmtNbr_Int32S().
   3236          *
   3237          *               lead_char       Prepend leading character  (see Note #3) :
   3238          *
   3239          *                                   '\0'                    Do NOT prepend leading character to string.
   3240          *                                     Printable character          Prepend leading character to string.
   3241          *                                   Unprintable character   Format invalid string (see Note #6e).
   3242          *
   3243          *               lower_case      Format alphabetic characters (if any) in lower case :
   3244          *
   3245          *                                   DEF_NO          Format alphabetic characters in upper case.
   3246          *                                   DEF_YES         Format alphabetic characters in lower case.
   3247          *
   3248          *               nul             Append terminating NULL-character (see Note #4) :
   3249          *
   3250          *                                   DEF_NO          Do NOT append terminating NULL-character to string.
   3251          *                                   DEF_YES                Append terminating NULL-character to string.
   3252          *
   3253          *               pstr            Pointer to character array to return formatted number string (see Note #5).
   3254          *
   3255          * Return(s)   : Pointer to formatted string, if NO error(s) [see Note #6f].
   3256          *
   3257          *               Pointer to NULL,             otherwise.
   3258          *
   3259          * Caller(s)   : Str_FmtNbr_Int32U(),
   3260          *               Str_FmtNbr_Int32S().
   3261          *
   3262          * Note(s)     : (1) (a) The maximum number of digits to format for 32-bit integer numbers :
   3263          *
   3264          *
   3265          *                               Maximum Number of             [  log (Number)      ]
   3266          *                             32-bit Integer Digits  =  floor [ -------------- + 1 ]
   3267          *                                   to Format                 [   log (Base)       ]
   3268          *
   3269          *                               where
   3270          *                                       Number                  Number to format
   3271          *                                       Base            Base of number to format
   3272          *
   3273          *                   (b) (1) If the number of digits to format ('nbr_dig') is zero; then NO formatting
   3274          *                           is performed except possible NULL-termination of the string (see Note #4).
   3275          *
   3276          *                               Example :
   3277          *
   3278          *                                   nbr      = -23456
   3279          *                                   nbr_dig  =  0
   3280          *                                   nbr_base = 10
   3281          *
   3282          *                                   pstr     = ""                   See Note #7a
   3283          *
   3284          *                       (2) If the number of digits to format ('nbr_dig') is less than the number of
   3285          *                           significant integer digits of the number to format ('nbr'); then an invalid
   3286          *                           string is formatted instead of truncating any significant integer digits.
   3287          *
   3288          *                               Example :
   3289          *
   3290          *                                   nbr      = 23456
   3291          *                                   nbr_dig  = 3
   3292          *                                   nbr_base = 10
   3293          *
   3294          *                                   pstr     = "???"                See Note #7b
   3295          *
   3296          *                       (3) If the number to format ('nbr') is negative but the number of digits to format
   3297          *                           ('nbr_dig') is equal to the number of significant integer digits of the number
   3298          *                           to format ('nbr'); then an invalid string is formatted instead of truncating
   3299          *                           the negative sign.
   3300          *
   3301          *                               Example :
   3302          *
   3303          *                                   nbr      = -23456
   3304          *                                   nbr_dig  =  5
   3305          *                                   nbr_base = 10
   3306          *
   3307          *                                   pstr     = "?????"              See Note #7b
   3308          *
   3309          *               (2) The number's base MUST be between 2 & 36, inclusive.
   3310          *
   3311          *               (3) Leading character option prepends leading characters prior to the first non-zero digit.
   3312          *
   3313          *                   (a) (1) Leading character MUST be a printable ASCII character.
   3314          *
   3315          *                       (2) (A) Leading character MUST NOT be a number base digit, ...
   3316          *                           (B) with the exception of '0'.
   3317          *
   3318          *                   (b) (1) The number of leading characters is such that the total number of significant
   3319          *                           integer digits plus the number of leading characters plus possible negative
   3320          *                           sign character is equal to the requested number of integer digits to format
   3321          *                           ('nbr_dig').
   3322          *
   3323          *                               Examples :
   3324          *
   3325          *                                   nbr       = 23456
   3326          *                                   nbr_dig   = 7
   3327          *                                   nbr_base  = 10
   3328          *                                   lead_char = ' '
   3329          *
   3330          *                                   pstr      = "  23456"
   3331          *
   3332          *
   3333          *                                   nbr       = -23456
   3334          *                                   nbr_dig   = 7
   3335          *                                   nbr_base  = 10
   3336          *                                   lead_char = ' '
   3337          *
   3338          *                                   pstr      = " -23456"
   3339          *
   3340          *                       (2) (A) If the number to format ('nbr') is negative AND the leading character
   3341          *                               ('lead_char') is     a '0' digit; then the negative sign character
   3342          *                               prefixes all leading characters prior to the formatted number.
   3343          *
   3344          *                                   Examples :
   3345          *
   3346          *                                       nbr        = -23456
   3347          *                                       nbr_dig    =  8
   3348          *                                       nbr_base   = 10
   3349          *                                       lead_char  = '0'
   3350          *
   3351          *                                       pstr       = "-0023456"
   3352          *
   3353          *
   3354          *                                       nbr        = -43981
   3355          *                                       nbr_dig    =  8
   3356          *                                       nbr_base   = 16
   3357          *                                       lead_char  = '0'
   3358          *                                       lower_case = DEF_NO
   3359          *
   3360          *                                       pstr       = "-000ABCD"
   3361          *
   3362          *                           (B) If the number to format ('nbr') is negative AND the leading character
   3363          *                               ('lead_char') is NOT a '0' digit; then the negative sign character
   3364          *                               immediately prefixes the most significant digit of the formatted number.
   3365          *
   3366          *                                   Examples :
   3367          *
   3368          *                                       nbr        = -23456
   3369          *                                       nbr_dig    =  8
   3370          *                                       nbr_base   = 10
   3371          *                                       lead_char  = '#'
   3372          *
   3373          *                                       pstr       = "##-23456"
   3374          *
   3375          *
   3376          *                                       nbr        = -43981
   3377          *                                       nbr_dig    =  8
   3378          *                                       nbr_base   = 16
   3379          *                                       lead_char  = '#'
   3380          *                                       lower_case = DEF_YES
   3381          *
   3382          *                                       pstr       = "###-abcd"
   3383          *
   3384          *                   (c) (1) If the value of the number to format is     zero  ...
   3385          *                       (2) ... & the number of digits to format is non-zero, ...
   3386          *                       (3) ... but NO leading character available;           ...
   3387          *                       (4) ... then one digit of '0' value is formatted.
   3388          *
   3389          *                           This is NOT a leading character; but a single integer digit of '0' value.
   3390          *
   3391          *               (4) (a) NULL-character terminate option DISABLED prevents overwriting previous character
   3392          *                       array formatting.
   3393          *
   3394          *                   (b) WARNING: Unless 'pstr' character array is pre-/post-terminated, NULL-character
   3395          *                       terminate option DISABLED will cause character string run-on.
   3396          *
   3397          *               (5) (a) Format buffer size NOT validated; buffer overruns MUST be prevented by caller.
   3398          *
   3399          *                   (b) To prevent character buffer overrun :
   3400          *
   3401          *                           Character array size MUST be  >=  ('nbr_dig'          +
   3402          *                                                               1 negative sign   +
   3403          *                                                               1 'NUL' terminator)  characters
   3404          *
   3405          *               (6) String format terminates when :
   3406          *
   3407          *                   (a) Format string pointer is passed a NULL pointer.
   3408          *                       (1) No      string formatted;                NULL pointer returned.
   3409          *
   3410          *                   (b) Number of digits to format ('nbr_dig') is zero.
   3411          *                       (1) NULL    string formatted (see Note #7a); NULL pointer returned.
   3412          *
   3413          *                   (c) Number of digits to format ('nbr_dig') is less than number of significant
   3414          *                           integer digits of the number to format ('nbr'), including possible
   3415          *                           negative sign.
   3416          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   3417          *
   3418          *                   (d) Base is passed an invalid base (see Note #2).
   3419          *                       (1) Invalid string format performed; NULL pointer returned.
   3420          *
   3421          *                   (e) Lead character is NOT a valid, printable character (see Note #3a).
   3422          *                       (1) Invalid string formatted (see Note #7);  NULL pointer returned.
   3423          *
   3424          *                   (f) Number successfully formatted into character string array.
   3425          *
   3426          *               (7) For any unsuccessful string format or error(s), an invalid string of question marks
   3427          *                   ('?') will be formatted, where the number of question marks is determined by the
   3428          *                   number of digits to format ('nbr_dig') :
   3429          *
   3430          *                      Invalid string's     {  (a)   0 (NULL string)  ,  if 'nbr_dig' = 0
   3431          *                          number of     =  {
   3432          *                       question marks      {  (b)  'nbr_dig'         ,  if 'nbr_dig' > 0
   3433          *
   3434          *********************************************************************************************************
   3435          */
   3436          

   \                                 In section .text, align 2, keep-with-next
   3437          static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
   3438                                               CPU_INT08U    nbr_dig,
   3439                                               CPU_INT08U    nbr_base,
   3440                                               CPU_BOOLEAN   nbr_neg,
   3441                                               CPU_CHAR      lead_char,
   3442                                               CPU_BOOLEAN   lower_case,
   3443                                               CPU_BOOLEAN   nul,
   3444                                               CPU_CHAR     *pstr)
   3445          {
   \                     Str_FmtNbr_Int32: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x469B             MOV      R11,R3
   3446              CPU_CHAR     *pstr_fmt;
   3447              CPU_DATA      i;
   3448              CPU_INT32U    nbr_fmt            = 0;
   \   00000008   0x2400             MOVS     R4,#+0
   3449              CPU_INT32U    nbr_log;
   3450              CPU_INT08U    nbr_dig_max;
   3451              CPU_INT08U    nbr_dig_min;
   3452              CPU_INT08U    nbr_dig_fmtd       = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   3453              CPU_INT08U    nbr_neg_sign;
   3454              CPU_INT08U    nbr_lead_char;
   3455              CPU_INT08U    dig_val;
   3456              CPU_INT08U    lead_char_delta_0;
   3457              CPU_INT08U    lead_char_delta_a;
   3458              CPU_BOOLEAN   lead_char_dig;
   3459              CPU_BOOLEAN   lead_char_0;
   3460              CPU_BOOLEAN   fmt_valid          = DEF_YES;
   \   0000000C   0x2501             MOVS     R5,#+1
   3461              CPU_BOOLEAN   print_char;
   3462              CPU_BOOLEAN   nbr_neg_fmtd       = DEF_NO;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
   3463          
   3464          
   3465                                                                          /* ---------------- VALIDATE FMT ARGS ----------------- */
   3466              if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
   \   00000012   0x980F             LDR      R0,[SP, #+60]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??Str_FmtNbr_Int32_0
   3467                  return ((CPU_CHAR *)0);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE117             B.N      ??Str_FmtNbr_Int32_1
   3468              }
   \                     ??Str_FmtNbr_Int32_0: (+1)
   \   0000001C   0x4689             MOV      R9,R1
   3469          
   3470              if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
   \   0000001E   0x4648             MOV      R0,R9
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD100             BNE.N    ??Str_FmtNbr_Int32_2
   3471                  fmt_valid = DEF_NO;                                     /* ... fmt valid str (see Note #6b).                    */
   \   00000026   0x2500             MOVS     R5,#+0
   \                     ??Str_FmtNbr_Int32_2: (+1)
   \   00000028   0x4692             MOV      R10,R2
   3472              }
   3473                                                                          /* If invalid base, ...                                 */
   3474              if ((nbr_base <  2u) ||
   3475                  (nbr_base > 36u)) {
   \   0000002A   0x4650             MOV      R0,R10
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x1E80             SUBS     R0,R0,#+2
   \   00000030   0x2823             CMP      R0,#+35
   \   00000032   0xD300             BCC.N    ??Str_FmtNbr_Int32_3
   3476                  fmt_valid = DEF_NO;                                     /* ... fmt valid str (see Note #6d).                  */
   \   00000034   0x2500             MOVS     R5,#+0
   \                     ??Str_FmtNbr_Int32_3: (+1)
   \   00000036   0x9E0C             LDR      R6,[SP, #+48]
   3477              }
   3478          
   3479              if (lead_char != (CPU_CHAR)'\0') {
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD035             BEQ.N    ??Str_FmtNbr_Int32_4
   3480                  print_char =  ASCII_IsPrint(lead_char);
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       ASCII_IsPrint
   3481                  if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD001             BEQ.N    ??Str_FmtNbr_Int32_5
   3482                      fmt_valid = DEF_NO;                                 /* ... fmt valid str          (see Note #6e).           */
   \   0000004E   0x2500             MOVS     R5,#+0
   \   00000050   0xE02C             B.N      ??Str_FmtNbr_Int32_4
   3483          
   3484                  } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
   \                     ??Str_FmtNbr_Int32_5: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x2830             CMP      R0,#+48
   \   00000058   0xD028             BEQ.N    ??Str_FmtNbr_Int32_4
   3485                      lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
   \   0000005A   0xF1B6 0x0030      SUBS     R0,R6,#+48
   3486                      if (lower_case != DEF_YES) {
   \   0000005E   0xF89D 0x1034      LDRB     R1,[SP, #+52]
   \   00000062   0x2901             CMP      R1,#+1
   \   00000064   0xD002             BEQ.N    ??Str_FmtNbr_Int32_6
   3487                          lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
   \   00000066   0xF1B6 0x0141      SUBS     R1,R6,#+65
   \   0000006A   0xE001             B.N      ??Str_FmtNbr_Int32_7
   3488                      } else {
   3489                          lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
   \                     ??Str_FmtNbr_Int32_6: (+1)
   \   0000006C   0xF1B6 0x0161      SUBS     R1,R6,#+97
   3490                      }
   3491          
   3492                      lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
   3493                                       ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
   3494                                                              (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
   \                     ??Str_FmtNbr_Int32_7: (+1)
   \   00000070   0x4652             MOV      R2,R10
   \   00000072   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000074   0x2A0B             CMP      R2,#+11
   \   00000076   0xD205             BCS.N    ??Str_FmtNbr_Int32_8
   \   00000078   0x0002             MOVS     R2,R0
   \   0000007A   0x4653             MOV      R3,R10
   \   0000007C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000080   0x429A             CMP      R2,R3
   \   00000082   0xD30C             BCC.N    ??Str_FmtNbr_Int32_9
   \                     ??Str_FmtNbr_Int32_8: (+1)
   \   00000084   0x4652             MOV      R2,R10
   \   00000086   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000088   0x2A0B             CMP      R2,#+11
   \   0000008A   0xD30A             BCC.N    ??Str_FmtNbr_Int32_10
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x280A             CMP      R0,#+10
   \   00000090   0xD305             BCC.N    ??Str_FmtNbr_Int32_9
   \   00000092   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000094   0x4650             MOV      R0,R10
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x380A             SUBS     R0,R0,#+10
   \   0000009A   0x4281             CMP      R1,R0
   \   0000009C   0xD201             BCS.N    ??Str_FmtNbr_Int32_10
   \                     ??Str_FmtNbr_Int32_9: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xE000             B.N      ??Str_FmtNbr_Int32_11
   \                     ??Str_FmtNbr_Int32_10: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   3495          
   3496                      if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
   \                     ??Str_FmtNbr_Int32_11: (+1)
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD100             BNE.N    ??Str_FmtNbr_Int32_4
   3497                          fmt_valid = DEF_NO;                             /* ... fmt valid str               (see Note #6e).      */
   \   000000AA   0x2500             MOVS     R5,#+0
   \                     ??Str_FmtNbr_Int32_4: (+1)
   \   000000AC   0x4658             MOV      R0,R11
   3498                      }
   3499                  } else {
   3500                                                                          /* Empty Else Statement                                 */
   3501                  }
   3502              }
   3503          
   3504          
   3505                                                                          /* ----------------- PREPARE NBR FMT ------------------ */
   3506              pstr_fmt    = pstr;
   \   000000AE   0x990F             LDR      R1,[SP, #+60]
   3507              lead_char_0 = DEF_NO;
   \   000000B0   0x2200             MOVS     R2,#+0
   3508          
   3509              if (fmt_valid == DEF_YES) {
   \   000000B2   0x002B             MOVS     R3,R5
   \   000000B4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000B6   0x2B01             CMP      R3,#+1
   \   000000B8   0xD14F             BNE.N    ??Str_FmtNbr_Int32_12
   \   000000BA   0xF8DD 0xC008      LDR      R12,[SP, #+8]
   3510                  nbr_fmt     = nbr;
   \   000000BE   0x4664             MOV      R4,R12
   3511                  nbr_log     = nbr;
   3512                  nbr_dig_max = 1u;
   \   000000C0   0x2301             MOVS     R3,#+1
   \   000000C2   0xE005             B.N      ??Str_FmtNbr_Int32_13
   3513                  while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
   3514                      nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
   \                     ??Str_FmtNbr_Int32_14: (+1)
   \   000000C4   0x1C5B             ADDS     R3,R3,#+1
   3515                      nbr_log /= nbr_base;
   \   000000C6   0x46D6             MOV      LR,R10
   \   000000C8   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000000CC   0xFBBC 0xFCFE      UDIV     R12,R12,LR
   3516                  }
   \                     ??Str_FmtNbr_Int32_13: (+1)
   \   000000D0   0x46D6             MOV      LR,R10
   \   000000D2   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000000D6   0x45F4             CMP      R12,LR
   \   000000D8   0xD2F4             BCS.N    ??Str_FmtNbr_Int32_14
   3517          
   3518                  nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
   \   000000DA   0x4684             MOV      R12,R0
   \   000000DC   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   000000E0   0xF1BC 0x0F01      CMP      R12,#+1
   \   000000E4   0xD102             BNE.N    ??Str_FmtNbr_Int32_15
   \   000000E6   0xF05F 0x0C01      MOVS     R12,#+1
   \   000000EA   0xE001             B.N      ??Str_FmtNbr_Int32_16
   \                     ??Str_FmtNbr_Int32_15: (+1)
   \   000000EC   0xF05F 0x0C00      MOVS     R12,#+0
   3519                  if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
   \                     ??Str_FmtNbr_Int32_16: (+1)
   \   000000F0   0x46CE             MOV      LR,R9
   \   000000F2   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000000F6   0xF8CD 0xE000      STR      LR,[SP, #+0]
   \   000000FA   0x469B             MOV      R11,R3
   \   000000FC   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000100   0x46E6             MOV      LR,R12
   \   00000102   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000106   0xEB1E 0x0E0B      ADDS     LR,LR,R11
   \   0000010A   0xF8DD 0xB000      LDR      R11,[SP, #+0]
   \   0000010E   0x45F3             CMP      R11,LR
   \   00000110   0xDB22             BLT.N    ??Str_FmtNbr_Int32_17
   3520                      nbr_neg_fmtd = DEF_NO;
   \   00000112   0xF05F 0x0800      MOVS     R8,#+0
   3521                      nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
   \   00000116   0x001F             MOVS     R7,R3
   \   00000118   0x46CE             MOV      LR,R9
   \   0000011A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000011C   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   00000120   0x4577             CMP      R7,LR
   \   00000122   0xD300             BCC.N    ??Str_FmtNbr_Int32_18
   \                     ??Str_FmtNbr_Int32_19: (+1)
   \   00000124   0x464B             MOV      R3,R9
   3522                                                                          /* ... calc nbr digs to fmt & nbr lead chars.           */
   3523                      if (lead_char != (CPU_CHAR)'\0') {
   \                     ??Str_FmtNbr_Int32_18: (+1)
   \   00000126   0x0037             MOVS     R7,R6
   \   00000128   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000012A   0x2F00             CMP      R7,#+0
   \   0000012C   0xD005             BEQ.N    ??Str_FmtNbr_Int32_20
   3524                          nbr_dig_fmtd  = nbr_dig;
   \   0000012E   0x464F             MOV      R7,R9
   3525                          nbr_lead_char = nbr_dig     -
   3526                                         (nbr_dig_min + nbr_neg_sign);
   \   00000130   0xEBB9 0x0303      SUBS     R3,R9,R3
   \   00000134   0xEBB3 0x030C      SUBS     R3,R3,R12
   \   00000138   0xE003             B.N      ??Str_FmtNbr_Int32_21
   3527                      } else {
   3528                          nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
   \                     ??Str_FmtNbr_Int32_20: (+1)
   \   0000013A   0xEB1C 0x0303      ADDS     R3,R12,R3
   \   0000013E   0x001F             MOVS     R7,R3
   3529                          nbr_lead_char = 0u;
   \   00000140   0x2300             MOVS     R3,#+0
   3530                      }
   3531          
   3532                      if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
   \                     ??Str_FmtNbr_Int32_21: (+1)
   \   00000142   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000144   0x2B00             CMP      R3,#+0
   \   00000146   0xD008             BEQ.N    ??Str_FmtNbr_Int32_12
   3533                          lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
   3534                                      ?  DEF_YES : DEF_NO;
   \   00000148   0x0032             MOVS     R2,R6
   \   0000014A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000014C   0x2A30             CMP      R2,#+48
   \   0000014E   0xD101             BNE.N    ??Str_FmtNbr_Int32_22
   \   00000150   0x2201             MOVS     R2,#+1
   \   00000152   0xE002             B.N      ??Str_FmtNbr_Int32_12
   \                     ??Str_FmtNbr_Int32_22: (+1)
   \   00000154   0x2200             MOVS     R2,#+0
   \   00000156   0xE000             B.N      ??Str_FmtNbr_Int32_12
   3535                      }
   3536          
   3537                  } else {                                                /* Else if nbr trunc'd, ...                             */
   3538                      fmt_valid = DEF_NO;                                 /* ... fmt valid str (see Note #6c).                    */
   \                     ??Str_FmtNbr_Int32_17: (+1)
   \   00000158   0x2500             MOVS     R5,#+0
   3539                  }
   3540              }
   3541          
   3542              if (fmt_valid == DEF_NO) {
   \                     ??Str_FmtNbr_Int32_12: (+1)
   \   0000015A   0x002B             MOVS     R3,R5
   \   0000015C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000015E   0x2B00             CMP      R3,#+0
   \   00000160   0xD100             BNE.N    ??Str_FmtNbr_Int32_23
   3543                  nbr_dig_fmtd = nbr_dig;
   \   00000162   0x464F             MOV      R7,R9
   \                     ??Str_FmtNbr_Int32_23: (+1)
   \   00000164   0x9B0E             LDR      R3,[SP, #+56]
   3544              }
   3545          
   3546          
   3547                                                                          /* ------------------- FMT NBR STR -------------------- */
   3548              pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
   \   00000166   0x46BC             MOV      R12,R7
   \   00000168   0xFA5F 0xFC8C      UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
   \   0000016C   0x4461             ADD      R1,R1,R12
   3549          
   3550              if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
   \   0000016E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000170   0x2B00             CMP      R3,#+0
   \   00000172   0xD001             BEQ.N    ??Str_FmtNbr_Int32_24
   3551                 *pstr_fmt = (CPU_CHAR)'\0';
   \   00000174   0x2300             MOVS     R3,#+0
   \   00000176   0x700B             STRB     R3,[R1, #+0]
   3552              }
   3553              pstr_fmt--;
   \                     ??Str_FmtNbr_Int32_24: (+1)
   \   00000178   0xF1B1 0x0C01      SUBS     R12,R1,#+1
   3554          
   3555          
   3556              for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
   \   0000017C   0x2100             MOVS     R1,#+0
   \   0000017E   0xE00E             B.N      ??Str_FmtNbr_Int32_25
   3557                  if (fmt_valid == DEF_YES) {
   3558                      if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
   3559                          (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
   3560                                                                          /* ... calc & fmt dig val;                      ...     */
   3561                          dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
   3562                          if (dig_val < 10u) {
   3563                             *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
   3564                          } else {
   3565                              if (lower_case !=  DEF_YES) {
   3566                                 *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
   3567                              } else {
   3568                                 *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
   3569                              }
   3570                          }
   3571          
   3572                          nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
   3573          
   3574                      } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
   3575                               (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
   3576                                 (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
   3577                                ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
   3578                                 (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
   3579          
   3580                         *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
   3581                          nbr_neg_fmtd = DEF_YES;
   3582          
   3583                      } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
   3584                         *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
   3585                      } else {
   3586                                                                          /* Empty Else Statement                                 */
   3587                      }
   3588          
   3589                  } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
   3590                     *pstr_fmt-- = '?';
   \                     ??Str_FmtNbr_Int32_26: (+1)
   \   00000180   0x233F             MOVS     R3,#+63
   \   00000182   0xF88C 0x3000      STRB     R3,[R12, #+0]
   \   00000186   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   0000018A   0xE007             B.N      ??Str_FmtNbr_Int32_27
   3591                  }
   \                     ??Str_FmtNbr_Int32_28: (+1)
   \   0000018C   0x0033             MOVS     R3,R6
   \   0000018E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000190   0x2B00             CMP      R3,#+0
   \   00000192   0xD003             BEQ.N    ??Str_FmtNbr_Int32_27
   \   00000194   0xF88C 0x6000      STRB     R6,[R12, #+0]
   \   00000198   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \                     ??Str_FmtNbr_Int32_27: (+1)
   \   0000019C   0x1C49             ADDS     R1,R1,#+1
   \                     ??Str_FmtNbr_Int32_25: (+1)
   \   0000019E   0x003B             MOVS     R3,R7
   \   000001A0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001A2   0x4299             CMP      R1,R3
   \   000001A4   0xD24C             BCS.N    ??Str_FmtNbr_Int32_29
   \   000001A6   0x002B             MOVS     R3,R5
   \   000001A8   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000001AA   0x2B01             CMP      R3,#+1
   \   000001AC   0xD1E8             BNE.N    ??Str_FmtNbr_Int32_26
   \   000001AE   0x2C00             CMP      R4,#+0
   \   000001B0   0xD101             BNE.N    ??Str_FmtNbr_Int32_30
   \   000001B2   0x2900             CMP      R1,#+0
   \   000001B4   0xD127             BNE.N    ??Str_FmtNbr_Int32_31
   \                     ??Str_FmtNbr_Int32_30: (+1)
   \   000001B6   0x46D6             MOV      LR,R10
   \   000001B8   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000001BC   0xFBB4 0xF3FE      UDIV     R3,R4,LR
   \   000001C0   0xFB0E 0x4313      MLS      R3,LR,R3,R4
   \   000001C4   0x469E             MOV      LR,R3
   \   000001C6   0xFA5F 0xFE8E      UXTB     LR,LR            ;; ZeroExt  LR,LR,#+24,#+24
   \   000001CA   0xF1BE 0x0F0A      CMP      LR,#+10
   \   000001CE   0xD205             BCS.N    ??Str_FmtNbr_Int32_32
   \   000001D0   0x3330             ADDS     R3,R3,#+48
   \   000001D2   0xF88C 0x3000      STRB     R3,[R12, #+0]
   \   000001D6   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   000001DA   0xE00F             B.N      ??Str_FmtNbr_Int32_33
   \                     ??Str_FmtNbr_Int32_32: (+1)
   \   000001DC   0xF89D 0xE034      LDRB     LR,[SP, #+52]
   \   000001E0   0xF1BE 0x0F01      CMP      LR,#+1
   \   000001E4   0xD005             BEQ.N    ??Str_FmtNbr_Int32_34
   \   000001E6   0x3337             ADDS     R3,R3,#+55
   \   000001E8   0xF88C 0x3000      STRB     R3,[R12, #+0]
   \   000001EC   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   000001F0   0xE004             B.N      ??Str_FmtNbr_Int32_33
   \                     ??Str_FmtNbr_Int32_34: (+1)
   \   000001F2   0x3357             ADDS     R3,R3,#+87
   \   000001F4   0xF88C 0x3000      STRB     R3,[R12, #+0]
   \   000001F8   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \                     ??Str_FmtNbr_Int32_33: (+1)
   \   000001FC   0x4653             MOV      R3,R10
   \   000001FE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000200   0xFBB4 0xF4F3      UDIV     R4,R4,R3
   \   00000204   0xE7CA             B.N      ??Str_FmtNbr_Int32_27
   \                     ??Str_FmtNbr_Int32_31: (+1)
   \   00000206   0x0003             MOVS     R3,R0
   \   00000208   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000020A   0x2B01             CMP      R3,#+1
   \   0000020C   0xD1BE             BNE.N    ??Str_FmtNbr_Int32_28
   \   0000020E   0x0013             MOVS     R3,R2
   \   00000210   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000212   0x2B00             CMP      R3,#+0
   \   00000214   0xD103             BNE.N    ??Str_FmtNbr_Int32_35
   \   00000216   0x4643             MOV      R3,R8
   \   00000218   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000021A   0x2B00             CMP      R3,#+0
   \   0000021C   0xD008             BEQ.N    ??Str_FmtNbr_Int32_36
   \                     ??Str_FmtNbr_Int32_35: (+1)
   \   0000021E   0x0013             MOVS     R3,R2
   \   00000220   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000222   0x2B00             CMP      R3,#+0
   \   00000224   0xD0B2             BEQ.N    ??Str_FmtNbr_Int32_28
   \   00000226   0x003B             MOVS     R3,R7
   \   00000228   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000022A   0x1E5B             SUBS     R3,R3,#+1
   \   0000022C   0x4299             CMP      R1,R3
   \   0000022E   0xD1AD             BNE.N    ??Str_FmtNbr_Int32_28
   \                     ??Str_FmtNbr_Int32_36: (+1)
   \   00000230   0x232D             MOVS     R3,#+45
   \   00000232   0xF88C 0x3000      STRB     R3,[R12, #+0]
   \   00000236   0xF1BC 0x0C01      SUBS     R12,R12,#+1
   \   0000023A   0xF05F 0x0801      MOVS     R8,#+1
   \   0000023E   0xE7AD             B.N      ??Str_FmtNbr_Int32_27
   3592              }
   3593          
   3594          
   3595              if (fmt_valid == DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
   \                     ??Str_FmtNbr_Int32_29: (+1)
   \   00000240   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000242   0x2D00             CMP      R5,#+0
   \   00000244   0xD101             BNE.N    ??Str_FmtNbr_Int32_37
   3596                  return ((CPU_CHAR *)0);
   \   00000246   0x2000             MOVS     R0,#+0
   \   00000248   0xE000             B.N      ??Str_FmtNbr_Int32_1
   3597              }
   3598          
   3599          
   3600              return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
   \                     ??Str_FmtNbr_Int32_37: (+1)
   \   0000024A   0x980F             LDR      R0,[SP, #+60]
   \                     ??Str_FmtNbr_Int32_1: (+1)
   \   0000024C   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   3601          }
   3602          
   3603          
   3604          /*
   3605          *********************************************************************************************************
   3606          *                                        Str_ParseNbr_Int32()
   3607          *
   3608          * Description : Parse 32-bit integer from string.
   3609          *
   3610          * Argument(s) : pstr            Pointer to string (see Notes #1 & #2a).
   3611          *
   3612          *               pstr_next       Optional pointer to a variable to ... :
   3613          *
   3614          *                                   (a) Return a pointer to first character following the integer string,
   3615          *                                           if NO error(s) [see Note #2a2B2];
   3616          *                                   (b) Return a pointer to 'pstr',
   3617          *                                           otherwise      (see Note #2a2A2).
   3618          *
   3619          *               nbr_base        Base of number to parse (see Notes #2a1B1 & #2a2B1).
   3620          *
   3621          *               nbr_signed      Indicates whether number to parse is signed :
   3622          *
   3623          *                                   DEF_NO                  Number is unsigned.
   3624          *                                   DEF_YES                 Number is   signed.
   3625          *
   3626          *               pnbr_neg        Pointer to a variable to return if the parsed (signed) number is negative :
   3627          *
   3628          *                                   DEF_NO                  Number is non-negative.
   3629          *                                   DEF_YES                 Number is     negative.
   3630          *
   3631          * Return(s)   : Parsed integer,      if integer parsed with NO overflow   (see Note #2a3A).
   3632          *
   3633          *               DEF_INT_32U_MAX_VAL, if integer parsed but     overflowed (see Note #2a3A1).
   3634          *
   3635          *               0,                   otherwise                            (see Note #2a3B).
   3636          *
   3637          * Caller(s)   : Str_ParseNbr_Int32U(),
   3638          *               Str_ParseNbr_Int32S().
   3639          *
   3640          * Note(s)     : (1) String buffer NOT modified.
   3641          *
   3642          *               (2) (a) IEEE Std 1003.1, 2004 Edition, Section 'strtol() : DESCRIPTION' states that "these
   3643          *                       functions shall convert the initial portion of the string pointed to by 'str' ('pstr')
   3644          *                       to a type long ... representation" :
   3645          *
   3646          *                       (1) "First, they decompose the input string into three parts" :
   3647          *
   3648          *                           (A) "An initial, possibly empty, sequence of white-space characters [as specified
   3649          *                                by isspace()]."
   3650          *
   3651          *                               (1) "The subject sequence is defined as the longest initial subsequence of the
   3652          *                                    input string, starting with the first non-white-space character that is of
   3653          *                                    the expected form.  The subject sequence shall contain no characters if the
   3654          *                                    input string is empty or consists entirely of white-space characters."
   3655          *
   3656          *                           (B) (1) "A subject sequence interpreted as an integer represented in some radix
   3657          *                                    determined by the value of 'base' ('nbr_base')" :
   3658          *
   3659          *                                   (a) "If the value of 'base' ('nbr_base') is 0, the expected form of the
   3660          *                                        subject sequence is that of a decimal constant, octal constant, or
   3661          *                                        hexadecimal constant" :
   3662          *
   3663          *                                       (1) "A decimal constant begins with a non-zero digit, and consists of a
   3664          *                                            sequence of decimal digits."
   3665          *
   3666          *                                       (2) "An octal constant consists of the prefix '0' optionally followed by
   3667          *                                            a sequence of the digits '0' to '7' only."
   3668          *
   3669          *                                       (3) "A hexadecimal constant consists of the prefix '0x' or '0X' followed
   3670          *                                            by a sequence of the decimal digits and letters 'a' (or 'A') to 'f'
   3671          *                                            (or 'F') with values 10 to 15 respectively."
   3672          *
   3673          *                                   (b) "If the value of 'base' ('nbr_base') is between 2 and 36, the expected form
   3674          *                                        of the subject sequence is a sequence of letters and digits representing
   3675          *                                        an integer with the radix specified by 'base' ('nbr_base')" :
   3676          *
   3677          *                                       (1) (A) "The letters from 'a' (or 'A') to 'z' (or 'Z') inclusive are
   3678          *                                                ascribed the values 10 to 35"; ...
   3679          *                                           (B) "only letters whose ascribed values are less than that of base
   3680          *                                                are permitted."
   3681          *
   3682          *                                       (2) (A) "If the value of 'base' ('nbr_base') is 16, the characters '0x' or
   3683          *                                               '0X' may optionally precede the sequence of letters and digits."
   3684          *
   3685          *                                           (B) Although NO specification states that "if the value of 'base'
   3686          *                                               ('nbr_base') is" 8, the '0' character "may optionally precede
   3687          *                                               the sequence of letters and digits"; it seems reasonable to
   3688          *                                               allow the '0' character to be optionally parsed.
   3689          *
   3690          *                               (2) "A subject sequence .... may be preceded by a '+' or '-' sign."
   3691          *
   3692          *                                   (a) It does NOT seem reasonable to parse & convert a negative number
   3693          *                                       integer string into an unsigned integer.  However, a negative sign
   3694          *                                       for an unsigned integer will automatically be parsed as an invalid
   3695          *                                       character (see Note #2aC1).
   3696          *
   3697          *                           (C) (1) (a) "A final string of one or more unrecognized characters,"  ...
   3698          *                                   (b) "including the terminating null byte of the input string" ...
   3699          *                               (2) "other than a sign or a permissible letter or digit."
   3700          *
   3701          *                       (2) Second, "they shall attempt to convert the subject sequence to an integer" :
   3702          *
   3703          *                           (A) "If the subject sequence is empty or does not have the expected form" :
   3704          *
   3705          *                               (1) "no conversion is performed"; ...
   3706          *                               (2) "the value of 'str' ('pstr') is stored in the object pointed to by 'endptr'
   3707          *                                    ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null pointer."
   3708          *
   3709          *                           (B) "If the subject sequence has the expected form" :
   3710          *
   3711          *                               (1) (a) "and the value of 'base' ('nbr_base') is 0, the sequence of characters
   3712          *                                        starting with the first digit shall be interpreted as an integer constant."
   3713          *
   3714          *                                   (b) "and the value of 'base' ('nbr_base') is between 2 and 36, it shall be
   3715          *                                        used as the base for conversion, ascribing to each letter its value as
   3716          *                                        given above" (see Note #2a1B1b1A).
   3717          *
   3718          *                               (2) "A pointer to the final string shall be stored in the object pointed to by
   3719          *                                   'endptr' ('pstr_next'), provided that 'endptr' ('pstr_next') is not a null
   3720          *                                   pointer."
   3721          *
   3722          *                       (3) Lastly, IEEE Std 1003.1, 2004 Edition, Section 'strtol() : RETURN VALUE' states that :
   3723          *
   3724          *                           (A) "Upon successful completion, these functions shall return the converted value."
   3725          *                               (1) "If the correct value is outside the range of representable values, {LONG_MIN}
   3726          *                                    [or] {LONG_MAX} ... shall be returned."
   3727          *
   3728          *                           (B) "If no conversion could be performed, 0 shall be returned."
   3729          *
   3730          *                   (b) (1) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3731          *                           shall fail if" :
   3732          *
   3733          *                           (A) "[EINVAL] - The value of 'base' ('nbr_base') is not supported."
   3734          *
   3735          *                           (B) "[ERANGE] - The value to be returned is not representable."
   3736          *
   3737          *                       (2) IEEE Std 1003.1, 2004 Edition, Section 'strtoul() : ERRORS' states that "these functions
   3738          *                           may fail if" :
   3739          *
   3740          *                           (A) "[EINVAL] - No conversion could be performed."
   3741          *
   3742          *               (3) Return integer value & next string pointer should be used to diagnose parse success or failure :
   3743          *
   3744          *                   (a) Valid parse string integer :
   3745          *
   3746          *                           pstr      = "     ABCDE xyz"
   3747          *                           nbr_base  = 16
   3748          *
   3749          *                           nbr       = 703710
   3750          *                           pstr_next = " xyz"
   3751          *
   3752          *
   3753          *                   (b) Invalid parse string integer :
   3754          *
   3755          *                           pstr      = "     ABCDE"
   3756          *                           nbr_base  = 10
   3757          *
   3758          *                           nbr       =  0
   3759          *                           pstr_next = pstr = "     ABCDE"
   3760          *
   3761          *
   3762          *                   (c) Valid hexadecimal parse string integer :
   3763          *
   3764          *                           pstr      = "     0xGABCDE"
   3765          *                           nbr_base  = 16
   3766          *
   3767          *                           nbr       =  0
   3768          *                           pstr_next = "xGABCDE"
   3769          *
   3770          *
   3771          *                   (d) Valid decimal parse string integer ('0x' prefix ignored
   3772          *                               following invalid hexadecimal characters) :
   3773          *
   3774          *                           pstr      = "     0xGABCDE"
   3775          *                           nbr_base  =  0
   3776          *
   3777          *                           nbr       =  0
   3778          *                           pstr_next = "xGABCDE"
   3779          *
   3780          *
   3781          *                   (e) Valid decimal parse string integer ('0'  prefix ignored
   3782          *                               following invalid octal       characters) :
   3783          *
   3784          *                           pstr      = "     0GABCDE"
   3785          *                           nbr_base  =  0
   3786          *
   3787          *                           nbr       =  0
   3788          *                           pstr_next = "GABCDE"
   3789          *
   3790          *
   3791          *                   (f) Parse string integer overflow :
   3792          *
   3793          *                           pstr      = "   12345678901234567890*123456"
   3794          *                           nbr_base  = 10
   3795          *
   3796          *                           nbr       = DEF_INT_32U_MAX_VAL
   3797          *                           pstr_next = "*123456"
   3798          *
   3799          *
   3800          *                   (g) Parse string integer underflow :
   3801          *
   3802          *                           pstr      = "  -12345678901234567890*123456"
   3803          *                           nbr_base  = 10
   3804          *
   3805          *                           nbr       = DEF_INT_32S_MIN_VAL
   3806          *                           pstr_next = "*123456"
   3807          *
   3808          *
   3809          *               (4) String parse terminates when :
   3810          *
   3811          *                   (a) Base passed an invalid base (see Note #2a1B1b).
   3812          *                       (1) No conversion performed; 0 returned.
   3813          *
   3814          *                   (b) (1) Parse string passed a NULL pointer OR empty integer sequence (see Note #2a2A).
   3815          *                           (A) No conversion performed; 0 returned.
   3816          *
   3817          *                       (2) Invalid parse string character found (see Note #2a1C).
   3818          *                           (A) Parsed integer returned.
   3819          *                           (B) 'pstr_next' points to invalid character.
   3820          *
   3821          *                       (3) Entire  parse string converted (see Note #2a2B).
   3822          *                           (A) Parsed integer returned.
   3823          *                           (B) 'pstr_next' points to terminating NULL character.
   3824          *
   3825          *               (5) Pointers to variables that return values MUST be initialized PRIOR to all other
   3826          *                   validation or function handling in case of any error(s).
   3827          *********************************************************************************************************
   3828          */
   3829          

   \                                 In section .text, align 2, keep-with-next
   3830          static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
   3831                                                         CPU_CHAR     **pstr_next,
   3832                                                         CPU_INT08U     nbr_base,
   3833                                                         CPU_BOOLEAN    nbr_signed,
   3834                                                         CPU_BOOLEAN   *pnbr_neg)
   3835          {
   \                     Str_ParseNbr_Int32: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001C             MOVS     R4,R3
   3836              const  CPU_CHAR     *pstr_parse;
   3837              const  CPU_CHAR     *pstr_parse_nbr;
   3838                     CPU_CHAR     *pstr_parse_unused;
   3839                     CPU_CHAR      parse_char;
   3840                     CPU_INT08U    parse_dig;
   3841                     CPU_INT32U    nbr;
   3842                     CPU_BOOLEAN   nbr_neg_unused;
   3843                     CPU_BOOLEAN   nbr_dig;
   3844                     CPU_BOOLEAN   nbr_alpha;
   3845                     CPU_BOOLEAN   nbr_hex;
   3846                     CPU_BOOLEAN   nbr_hex_lower;
   3847                     CPU_BOOLEAN   whitespace;
   3848                     CPU_BOOLEAN   neg;
   3849                     CPU_BOOLEAN   ovf;
   3850                     CPU_BOOLEAN   done;
   3851          
   3852                                                                          /* --------------- VALIDATE PARSE ARGS ---------------- */
   3853              if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD100             BNE.N    ??Str_ParseNbr_Int32_0
   3854                  pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
   \   0000000E   0xAD03             ADD      R5,SP,#+12
   3855                 (void)pstr_parse_unused;                                 /* Prevent possible 'variable unused' warning.          */
   \                     ??Str_ParseNbr_Int32_0: (+1)
   \   00000010   0x9001             STR      R0,[SP, #+4]
   3856              }
   3857             *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
   \   00000012   0x9801             LDR      R0,[SP, #+4]
   \   00000014   0x6028             STR      R0,[R5, #+0]
   3858          
   3859              if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
   \   00000016   0x980E             LDR      R0,[SP, #+56]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??Str_ParseNbr_Int32_1
   3860                  pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x900E             STR      R0,[SP, #+56]
   3861                 (void)nbr_neg_unused;                                    /* Prevent possible 'variable unused' warning.          */
   3862              }
   3863             *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
   \                     ??Str_ParseNbr_Int32_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x990E             LDR      R1,[SP, #+56]
   \   00000024   0x7008             STRB     R0,[R1, #+0]
   3864          
   3865          
   3866              if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD101             BNE.N    ??Str_ParseNbr_Int32_2
   3867                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE0D9             B.N      ??Str_ParseNbr_Int32_3
   3868              }
   \                     ??Str_ParseNbr_Int32_2: (+1)
   \   00000030   0x0017             MOVS     R7,R2
   3869                                                                          /* Rtn zero if invalid base (see Note #4a).             */
   3870              if ((nbr_base == 1u) ||
   3871                  (nbr_base > 36u)) {
   \   00000032   0x0038             MOVS     R0,R7
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD003             BEQ.N    ??Str_ParseNbr_Int32_4
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x2825             CMP      R0,#+37
   \   00000040   0xD301             BCC.N    ??Str_ParseNbr_Int32_5
   3872                  return (0u);
   \                     ??Str_ParseNbr_Int32_4: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE0CE             B.N      ??Str_ParseNbr_Int32_3
   3873              }
   3874          
   3875          
   3876                                                                          /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
   3877              pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_5: (+1)
   \   00000046   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   3878          
   3879              whitespace = ASCII_IsSpace(*pstr_parse);
   \   0000004A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000004E   0x.... 0x....      BL       ASCII_IsSpace
   \   00000052   0xE005             B.N      ??Str_ParseNbr_Int32_6
   3880              while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
   3881                  pstr_parse++;
   \                     ??Str_ParseNbr_Int32_7: (+1)
   \   00000054   0xF118 0x0801      ADDS     R8,R8,#+1
   3882                  whitespace = ASCII_IsSpace(*pstr_parse);
   \   00000058   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000005C   0x.... 0x....      BL       ASCII_IsSpace
   3883              }
   \                     ??Str_ParseNbr_Int32_6: (+1)
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD0F6             BEQ.N    ??Str_ParseNbr_Int32_7
   3884          
   3885              switch (*pstr_parse) {
   \   00000066   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   0000006A   0x282B             CMP      R0,#+43
   \   0000006C   0xD002             BEQ.N    ??Str_ParseNbr_Int32_8
   \   0000006E   0x282D             CMP      R0,#+45
   \   00000070   0xD004             BEQ.N    ??Str_ParseNbr_Int32_9
   \   00000072   0xE00A             B.N      ??Str_ParseNbr_Int32_10
   3886                  case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
   3887                       pstr_parse++;
   \                     ??Str_ParseNbr_Int32_8: (+1)
   \   00000074   0xF118 0x0801      ADDS     R8,R8,#+1
   3888                       neg = DEF_NO;
   \   00000078   0x2600             MOVS     R6,#+0
   3889                       break;
   \   0000007A   0xE007             B.N      ??Str_ParseNbr_Int32_11
   3890          
   3891          
   3892                  case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
   3893                       if (nbr_signed == DEF_YES) {
   \                     ??Str_ParseNbr_Int32_9: (+1)
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2C01             CMP      R4,#+1
   \   00000080   0xD101             BNE.N    ??Str_ParseNbr_Int32_12
   3894                           pstr_parse++;
   \   00000082   0xF118 0x0801      ADDS     R8,R8,#+1
   3895                       }
   3896                       neg = DEF_YES;
   \                     ??Str_ParseNbr_Int32_12: (+1)
   \   00000086   0x2601             MOVS     R6,#+1
   3897                       break;
   \   00000088   0xE000             B.N      ??Str_ParseNbr_Int32_11
   3898          
   3899          
   3900                  default:
   3901                       neg = DEF_NO;
   \                     ??Str_ParseNbr_Int32_10: (+1)
   \   0000008A   0x2600             MOVS     R6,#+0
   3902                       break;
   3903              }
   3904          
   3905          
   3906                                                                          /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
   3907              pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
   \                     ??Str_ParseNbr_Int32_11: (+1)
   \   0000008C   0xF8CD 0x8008      STR      R8,[SP, #+8]
   3908          
   3909              switch (nbr_base) {
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD004             BEQ.N    ??Str_ParseNbr_Int32_13
   \   00000098   0x2808             CMP      R0,#+8
   \   0000009A   0xD01E             BEQ.N    ??Str_ParseNbr_Int32_14
   \   0000009C   0x2810             CMP      R0,#+16
   \   0000009E   0xD023             BEQ.N    ??Str_ParseNbr_Int32_15
   \   000000A0   0xE03A             B.N      ??Str_ParseNbr_Int32_16
   3910                  case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
   3911                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_13: (+1)
   \   000000A2   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000A6   0x2830             CMP      R0,#+48
   \   000000A8   0xD115             BNE.N    ??Str_ParseNbr_Int32_17
   3912                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   000000AA   0xF118 0x0801      ADDS     R8,R8,#+1
   3913                            switch (*pstr_parse) {
   \   000000AE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000B2   0x2858             CMP      R0,#+88
   \   000000B4   0xD001             BEQ.N    ??Str_ParseNbr_Int32_18
   \   000000B6   0x2878             CMP      R0,#+120
   \   000000B8   0xD10B             BNE.N    ??Str_ParseNbr_Int32_19
   3914                                case 'x':                                 /* For '0x' prefix, ...                                 */
   3915                                case 'X':
   3916                                     nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
   \                     ??Str_ParseNbr_Int32_18: (+1)
   \   000000BA   0x2710             MOVS     R7,#+16
   3917                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \   000000BC   0xF898 0x0001      LDRB     R0,[R8, #+1]
   3918                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x.... 0x....      BL       ASCII_IsDigHex
   3919                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xD101             BNE.N    ??Str_ParseNbr_Int32_20
   3920                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   000000CC   0xF118 0x0801      ADDS     R8,R8,#+1
   3921                                     }
   3922                                     break;
   \                     ??Str_ParseNbr_Int32_20: (+1)
   \   000000D0   0xE002             B.N      ??Str_ParseNbr_Int32_21
   3923          
   3924          
   3925                                default:                                  /* For '0'  prefix, ...                                 */
   3926                                     nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
   \                     ??Str_ParseNbr_Int32_19: (+1)
   \   000000D2   0x2708             MOVS     R7,#+8
   3927                                     break;
   \   000000D4   0xE000             B.N      ??Str_ParseNbr_Int32_21
   3928                            }
   3929          
   3930                       } else {                                           /* For non-'0' prefix, ...                              */
   3931                           nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
   \                     ??Str_ParseNbr_Int32_17: (+1)
   \   000000D6   0x270A             MOVS     R7,#+10
   3932                       }
   3933                       break;
   \                     ??Str_ParseNbr_Int32_21: (+1)
   \   000000D8   0xE01E             B.N      ??Str_ParseNbr_Int32_22
   3934          
   3935          
   3936                  case  8u:                                               /* See Note #2a1B1a2.                                   */
   3937                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_14: (+1)
   \   000000DA   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000DE   0x2830             CMP      R0,#+48
   \   000000E0   0xD101             BNE.N    ??Str_ParseNbr_Int32_23
   3938                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
   \   000000E2   0xF118 0x0801      ADDS     R8,R8,#+1
   3939                       }
   3940                       break;
   \                     ??Str_ParseNbr_Int32_23: (+1)
   \   000000E6   0xE017             B.N      ??Str_ParseNbr_Int32_22
   3941          
   3942          
   3943                  case 16u:                                               /* See Note #2a1B1a3.                                   */
   3944                       if (*pstr_parse == '0') {                          /* If avail, ...                                        */
   \                     ??Str_ParseNbr_Int32_15: (+1)
   \   000000E8   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000EC   0x2830             CMP      R0,#+48
   \   000000EE   0xD112             BNE.N    ??Str_ParseNbr_Int32_24
   3945                            pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
   \   000000F0   0xF118 0x0801      ADDS     R8,R8,#+1
   3946                            switch (*pstr_parse) {
   \   000000F4   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000F8   0x2858             CMP      R0,#+88
   \   000000FA   0xD001             BEQ.N    ??Str_ParseNbr_Int32_25
   \   000000FC   0x2878             CMP      R0,#+120
   \   000000FE   0xD10A             BNE.N    ??Str_ParseNbr_Int32_26
   3947                                case 'x':
   3948                                case 'X':
   3949                                     parse_char = (CPU_CHAR)(*(pstr_parse + 1));
   \                     ??Str_ParseNbr_Int32_25: (+1)
   \   00000100   0xF898 0x0001      LDRB     R0,[R8, #+1]
   3950                                     nbr_hex    =  ASCII_IsDigHex(parse_char);
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000106   0x.... 0x....      BL       ASCII_IsDigHex
   3951                                     if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x2801             CMP      R0,#+1
   \   0000010E   0xD101             BNE.N    ??Str_ParseNbr_Int32_27
   3952                                         pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
   \   00000110   0xF118 0x0801      ADDS     R8,R8,#+1
   3953                                     }
   3954                                     break;
   \                     ??Str_ParseNbr_Int32_27: (+1)
   \   00000114   0xE7FF             B.N      ??Str_ParseNbr_Int32_24
   3955          
   3956          
   3957                                default:
   3958                                     break;
   3959                            }
   3960                       }
   3961                       break;
   \                     ??Str_ParseNbr_Int32_26: (+1)
   \                     ??Str_ParseNbr_Int32_24: (+1)
   \   00000116   0xE7FF             B.N      ??Str_ParseNbr_Int32_22
   3962          
   3963          
   3964                  default:                                                /* See Note #2a1B1b.                                    */
   3965                       break;
   3966              }
   3967          
   3968          
   3969                                                                          /* ------------------ PARSE INT STR ------------------- */
   3970              nbr  = 0u;
   \                     ??Str_ParseNbr_Int32_16: (+1)
   \                     ??Str_ParseNbr_Int32_22: (+1)
   \   00000118   0x2400             MOVS     R4,#+0
   3971              ovf  = DEF_NO;
   \   0000011A   0xF05F 0x0A00      MOVS     R10,#+0
   3972              done = DEF_NO;
   \   0000011E   0xF05F 0x0900      MOVS     R9,#+0
   \   00000122   0xE001             B.N      ??Str_ParseNbr_Int32_28
   3973          
   3974              while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
   3975                  parse_char = (CPU_CHAR)*pstr_parse;
   3976                  nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
   3977                  if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
   3978                                                                          /* ... convert parse char into nbr dig.                 */
   3979                      nbr_dig = ASCII_IsDig(parse_char);
   3980                      if (nbr_dig == DEF_YES) {
   3981                          parse_dig = (CPU_INT08U)(parse_char - '0');
   3982                      } else {
   3983                          nbr_hex_lower = ASCII_IsLower(parse_char);
   3984                          if (nbr_hex_lower == DEF_YES) {
   3985                              parse_dig = ((CPU_INT08U)(parse_char - 'a') + 10u);
   3986                          } else {
   3987                              parse_dig = ((CPU_INT08U)(parse_char - 'A') + 10u);
   3988                          }
   3989                      }
   3990          
   3991                      if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
   3992                          if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
   3993                              if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
   3994                                                                          /* ... merge parse char dig into nbr.                   */
   3995                                  nbr *= nbr_base;
   3996                                  nbr += parse_dig;
   3997                                  if (nbr < parse_dig) {
   3998                                      ovf = DEF_YES;
   3999                                  }
   4000                              } else {
   4001                                  ovf = DEF_YES;
   4002                              }
   4003                          }
   4004                          pstr_parse++;
   4005          
   4006                      } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
   4007                          done = DEF_YES;
   4008                      }
   4009          
   4010                  } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
   4011                      done = DEF_YES;
   \                     ??Str_ParseNbr_Int32_29: (+1)
   \   00000124   0xF05F 0x0901      MOVS     R9,#+1
   4012                  }
   \                     ??Str_ParseNbr_Int32_28: (+1)
   \   00000128   0x4648             MOV      R0,R9
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD147             BNE.N    ??Str_ParseNbr_Int32_30
   \   00000130   0xF898 0xB000      LDRB     R11,[R8, #+0]
   \   00000134   0x4658             MOV      R0,R11
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0x.... 0x....      BL       ASCII_IsAlphaNum
   \   0000013C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013E   0x2801             CMP      R0,#+1
   \   00000140   0xD1F0             BNE.N    ??Str_ParseNbr_Int32_29
   \   00000142   0x4658             MOV      R0,R11
   \   00000144   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000146   0x.... 0x....      BL       ASCII_IsDig
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014C   0x2801             CMP      R0,#+1
   \   0000014E   0xD102             BNE.N    ??Str_ParseNbr_Int32_31
   \   00000150   0xF1BB 0x0130      SUBS     R1,R11,#+48
   \   00000154   0xE00D             B.N      ??Str_ParseNbr_Int32_32
   \                     ??Str_ParseNbr_Int32_31: (+1)
   \   00000156   0x4658             MOV      R0,R11
   \   00000158   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015A   0x.... 0x....      BL       ASCII_IsLower
   \   0000015E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000160   0x2801             CMP      R0,#+1
   \   00000162   0xD103             BNE.N    ??Str_ParseNbr_Int32_33
   \   00000164   0xF1BB 0x0161      SUBS     R1,R11,#+97
   \   00000168   0x310A             ADDS     R1,R1,#+10
   \   0000016A   0xE002             B.N      ??Str_ParseNbr_Int32_32
   \                     ??Str_ParseNbr_Int32_33: (+1)
   \   0000016C   0xF1BB 0x0141      SUBS     R1,R11,#+65
   \   00000170   0x310A             ADDS     R1,R1,#+10
   \                     ??Str_ParseNbr_Int32_32: (+1)
   \   00000172   0x0008             MOVS     R0,R1
   \   00000174   0x003A             MOVS     R2,R7
   \   00000176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000178   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000017A   0x4290             CMP      R0,R2
   \   0000017C   0xD21D             BCS.N    ??Str_ParseNbr_Int32_34
   \   0000017E   0x4650             MOV      R0,R10
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0x2800             CMP      R0,#+0
   \   00000184   0xD116             BNE.N    ??Str_ParseNbr_Int32_35
   \   00000186   0x....             LDR.N    R0,??DataTable1
   \   00000188   0x003A             MOVS     R2,R7
   \   0000018A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000018C   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \   00000190   0x42A0             CMP      R0,R4
   \   00000192   0xD30D             BCC.N    ??Str_ParseNbr_Int32_36
   \   00000194   0x0038             MOVS     R0,R7
   \   00000196   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000198   0x4344             MULS     R4,R0,R4
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x0004             MOVS     R4,R0
   \   0000019E   0x0008             MOVS     R0,R1
   \   000001A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A2   0x1904             ADDS     R4,R0,R4
   \   000001A4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001A6   0x428C             CMP      R4,R1
   \   000001A8   0xD204             BCS.N    ??Str_ParseNbr_Int32_35
   \   000001AA   0xF05F 0x0A01      MOVS     R10,#+1
   \   000001AE   0xE001             B.N      ??Str_ParseNbr_Int32_35
   \                     ??Str_ParseNbr_Int32_36: (+1)
   \   000001B0   0xF05F 0x0A01      MOVS     R10,#+1
   \                     ??Str_ParseNbr_Int32_35: (+1)
   \   000001B4   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000001B8   0xE7B6             B.N      ??Str_ParseNbr_Int32_28
   \                     ??Str_ParseNbr_Int32_34: (+1)
   \   000001BA   0xF05F 0x0901      MOVS     R9,#+1
   \   000001BE   0xE7B3             B.N      ??Str_ParseNbr_Int32_28
   4013              }
   4014          
   4015              if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
   \                     ??Str_ParseNbr_Int32_30: (+1)
   \   000001C0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001C4   0xF1BA 0x0F01      CMP      R10,#+1
   \   000001C8   0xD101             BNE.N    ??Str_ParseNbr_Int32_37
   4016                  nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
   \   000001CA   0xF05F 0x34FF      MOVS     R4,#-1
   4017              }
   4018          
   4019          
   4020              if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
   \                     ??Str_ParseNbr_Int32_37: (+1)
   \   000001CE   0x9802             LDR      R0,[SP, #+8]
   \   000001D0   0x4580             CMP      R8,R0
   \   000001D2   0xD002             BEQ.N    ??Str_ParseNbr_Int32_38
   4021                 *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
   \   000001D4   0xF8C5 0x8000      STR      R8,[R5, #+0]
   \   000001D8   0xE001             B.N      ??Str_ParseNbr_Int32_39
   4022              } else {
   4023                 *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
   \                     ??Str_ParseNbr_Int32_38: (+1)
   \   000001DA   0x9801             LDR      R0,[SP, #+4]
   \   000001DC   0x6028             STR      R0,[R5, #+0]
   4024              }
   4025          
   4026             *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
   \                     ??Str_ParseNbr_Int32_39: (+1)
   \   000001DE   0x980E             LDR      R0,[SP, #+56]
   \   000001E0   0x7006             STRB     R6,[R0, #+0]
   4027          
   4028          
   4029              return (nbr);
   \   000001E2   0x0020             MOVS     R0,R4
   \                     ??Str_ParseNbr_Int32_3: (+1)
   \   000001E4   0xB005             ADD      SP,SP,#+20
   \   000001E6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   4030          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     Str_MultOvfThTbl_Int32U

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Str_Cat
         8   -> Str_Cat_N
       8   Str_Cat_N
       8   Str_Char
         8   -> Str_Char_N
       8   Str_Char_Last
         8   -> Str_Char_Last_N
      16   Str_Char_Last_N
        16   -> Str_Len_N
       8   Str_Char_N
       8   Str_Char_Replace
         8   -> Str_Char_Replace_N
      12   Str_Char_Replace_N
       8   Str_Cmp
         8   -> Str_Cmp_N
       8   Str_CmpIgnoreCase
         8   -> Str_CmpIgnoreCase_N
      32   Str_CmpIgnoreCase_N
        32   -> ASCII_ToLower
      16   Str_Cmp_N
       8   Str_Copy
         8   -> Str_Copy_N
       8   Str_Copy_N
      48   Str_FmtNbr_Int32
        48   -> ASCII_IsPrint
      40   Str_FmtNbr_Int32S
        40   -> Str_FmtNbr_Int32
      32   Str_FmtNbr_Int32U
        32   -> Str_FmtNbr_Int32
       8   Str_Len
         8   -> Str_Len_N
       0   Str_Len_N
      56   Str_ParseNbr_Int32
        56   -> ASCII_IsAlphaNum
        56   -> ASCII_IsDig
        56   -> ASCII_IsDigHex
        56   -> ASCII_IsLower
        56   -> ASCII_IsSpace
      16   Str_ParseNbr_Int32S
        16   -> Str_ParseNbr_Int32
       8   Str_ParseNbr_Int32U
         8   -> Str_ParseNbr_Int32
       8   Str_Str
         8   -> Str_Str_N
      32   Str_Str_N
        32   -> Str_Cmp_N
        32   -> Str_Len_N


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
      12  Str_Cat
      98  Str_Cat_N
      16  Str_Char
      16  Str_Char_Last
      70  Str_Char_Last_N
      82  Str_Char_N
      16  Str_Char_Replace
      56  Str_Char_Replace_N
      14  Str_Cmp
      14  Str_CmpIgnoreCase
     258  Str_CmpIgnoreCase_N
     144  Str_Cmp_N
      12  Str_Copy
      76  Str_Copy_N
     592  Str_FmtNbr_Int32
      52  Str_FmtNbr_Int32S
      36  Str_FmtNbr_Int32U
      12  Str_Len
      26  Str_Len_N
     148  Str_MultOvfThTbl_Int32U
     490  Str_ParseNbr_Int32
      52  Str_ParseNbr_Int32S
      16  Str_ParseNbr_Int32U
      12  Str_Str
     168  Str_Str_N

 
   148 bytes in section .rodata
 2 344 bytes in section .text
 
 2 344 bytes of CODE  memory
   148 bytes of CONST memory

Errors: none
Warnings: none
