###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  11:44:50
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_time.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW2B52.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_time.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_time.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_time.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_time.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                            TIME MANAGEMENT
     20          *
     21          * File    : os_time.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_time__c = "$Id: $";
     31          #endif
     32          
     33          /*
     34          ************************************************************************************************************************
     35          *                                                  DELAY TASK 'n' TICKS
     36          *
     37          * Description: This function is called to delay execution of the currently running task until the specified number of
     38          *              system ticks expires.  This, of course, directly equates to delaying the current task for some time to
     39          *              expire.  No delay will result if the specified delay is 0.  If the specified delay is greater than 0
     40          *              then, a context switch will result.
     41          *
     42          * Arguments  : dly       is a value in 'clock ticks' that the task will either delay for or, the target match value
     43          *                        of the tick counter (OSTickCtr).  Note that specifying 0 means the task is not to delay.
     44          *
     45          *                        depending on the option argument, the task will wake up when OSTickCtr reaches:
     46          *
     47          *                            OS_OPT_TIME_DLY      : OSTickCtr + dly
     48          *                            OS_OPT_TIME_TIMEOUT  : OSTickCtr + dly
     49          *                            OS_OPT_TIME_MATCH    : dly
     50          *                            OS_OPT_TIME_PERIODIC : OSTCBCurPtr->TickCtrPrev + dly
     51          *
     52          *              opt       specifies whether 'dly' represents absolute or relative time; default option marked with *** :
     53          *
     54          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
     55          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
     56          *                            OS_OPT_TIME_MATCH      indicates that 'dly' specifies the absolute value that OSTickCtr
     57          *                                                   must reach before the task will be resumed.
     58          *                            OS_OPT_TIME_PERIODIC   indicates that 'dly' specifies the periodic value that OSTickCtr
     59          *                                                   must reach before the task will be resumed.
     60          *
     61          *              p_err     is a pointer to a variable that will contain an error code from this call.
     62          *
     63          *                            OS_ERR_NONE              The call was successful and the delay occurred
     64          *                            OS_ERR_OPT_INVALID       If you specified an invalid option for this function
     65          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
     66          *                            OS_ERR_SCHED_LOCKED      Can't delay when the scheduler is locked
     67          *                            OS_ERR_TIME_DLY_ISR      If you called this function from an ISR
     68          *                            OS_ERR_TIME_ZERO_DLY     If the effective delay is zero
     69          *                            OS_ERR_TICK_DISABLED     If kernel ticks are disabled
     70          *
     71          * Returns    : none
     72          *
     73          * Note(s)    : none
     74          ************************************************************************************************************************
     75          */
     76          

   \                                 In section .text, align 2, keep-with-next
     77          void  OSTimeDly (OS_TICK   dly,
     78                           OS_OPT    opt,
     79                           OS_ERR   *p_err)
     80          {
   \                     OSTimeDly: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
     81          #if (OS_CFG_TICK_EN > 0u)
     82              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
     83          #endif
     84          
     85          
     86          #ifdef OS_SAFETY_CRITICAL
     87              if (p_err == (OS_ERR *)0) {
     88                  OS_SAFETY_CRITICAL_EXCEPTION();
     89                  return;
     90              }
     91          #endif
     92          
     93          #if (OS_CFG_TICK_EN == 0u)
     94              *p_err = OS_ERR_TICK_DISABLED;
     95              return;
     96          #else
     97          
     98          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
     99              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000A   0x....             LDR.N    R0,??DataTable5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTimeDly_0
    100                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000012   0xF247 0x2075      MOVW     R0,#+29301
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    101                  return;
   \   00000018   0xE031             B.N      ??OSTimeDly_1
    102              }
    103          #endif
    104          
    105          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    106              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTimeDly_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSTimeDly_2
    107                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    108                  return;
   \   00000028   0xE029             B.N      ??OSTimeDly_1
    109              }
    110          #endif
    111          
    112              if (OSSchedLockNestingCtr > 0u) {                           /* Can't delay when the scheduler is locked             */
   \                     ??OSTimeDly_2: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable5_2
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD003             BEQ.N    ??OSTimeDly_3
    113                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000032   0xF646 0x5063      MOVW     R0,#+28003
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    114                  return;
   \   00000038   0xE021             B.N      ??OSTimeDly_1
    115              }
    116          
    117              switch (opt) {
   \                     ??OSTimeDly_3: (+1)
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD005             BEQ.N    ??OSTimeDly_4
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD003             BEQ.N    ??OSTimeDly_4
   \   00000046   0x2804             CMP      R0,#+4
   \   00000048   0xD001             BEQ.N    ??OSTimeDly_4
   \   0000004A   0x2808             CMP      R0,#+8
   \   0000004C   0xD118             BNE.N    ??OSTimeDly_5
    118                  case OS_OPT_TIME_DLY:
    119                  case OS_OPT_TIME_TIMEOUT:
    120                  case OS_OPT_TIME_PERIODIC:
    121                  case OS_OPT_TIME_MATCH:
    122                       break;
    123          
    124                  default:
    125                      *p_err = OS_ERR_OPT_INVALID;
    126                       return;
    127              }
    128          
    129          #if (OS_CFG_TICK_EN > 0u)
    130              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDly_4: (+1)
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x0007             MOVS     R7,R0
    131              OS_TickListInsertDly(OSTCBCurPtr,
    132                                   dly,
    133                                   opt,
    134                                   p_err);
   \   00000056   0x0023             MOVS     R3,R4
   \   00000058   0x0032             MOVS     R2,R6
   \   0000005A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000005C   0x0029             MOVS     R1,R5
   \   0000005E   0x....             LDR.N    R0,??DataTable5_3
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x.... 0x....      BL       OS_TickListInsertDly
    135              if (*p_err != OS_ERR_NONE) {
   \   00000066   0x8820             LDRH     R0,[R4, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD10D             BNE.N    ??OSTimeDly_6
    136                   CPU_CRITICAL_EXIT();
    137                   return;
    138              }
    139          
    140              OS_RdyListRemove(OSTCBCurPtr);                              /* Remove current task from ready list                  */
   \   0000006C   0x....             LDR.N    R0,??DataTable5_3
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x.... 0x....      BL       OS_RdyListRemove
    141              CPU_CRITICAL_EXIT();
   \   00000074   0x0038             MOVS     R0,R7
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    142              OSSched();                                                  /* Find next task to run!                               */
   \   0000007A   0x.... 0x....      BL       OSSched
    143          #endif
    144          #endif
    145          }
   \                     ??OSTimeDly_1: (+1)
   \   0000007E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??OSTimeDly_5: (+1)
   \   00000080   0xF645 0x6025      MOVW     R0,#+24101
   \   00000084   0x8020             STRH     R0,[R4, #+0]
   \   00000086   0xE7FA             B.N      ??OSTimeDly_1
   \                     ??OSTimeDly_6: (+1)
   \   00000088   0x0038             MOVS     R0,R7
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000008E   0xE7F6             B.N      ??OSTimeDly_1
    146          
    147          
    148          /*
    149          ************************************************************************************************************************
    150          *                                             DELAY TASK FOR SPECIFIED TIME
    151          *
    152          * Description: This function is called to delay execution of the currently running task until some time expires.  This
    153          *              call allows you to specify the delay time in HOURS, MINUTES, SECONDS and MILLISECONDS instead of ticks.
    154          *
    155          * Arguments  : hours     specifies the number of hours that the task will be delayed (max. is 999 if the tick rate is
    156          *                        1000 Hz or less otherwise, a higher value would overflow a 32-bit unsigned counter).
    157          *
    158          *              minutes   specifies the number of minutes (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    159          *
    160          *              seconds   specifies the number of seconds (max. 59 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    161          *
    162          *              milli     specifies the number of milliseconds (max. 999 if 'opt' is OS_OPT_TIME_HMSM_STRICT)
    163          *
    164          *              opt       specifies time delay bit-field options logically OR'd; default options marked with *** :
    165          *
    166          *                        *** OS_OPT_TIME_DLY        specifies a relative time from the current value of OSTickCtr.
    167          *                            OS_OPT_TIME_TIMEOUT    same as OS_OPT_TIME_DLY.
    168          *                            OS_OPT_TIME_MATCH      indicates that the delay specifies the absolute value that OSTickCtr
    169          *                                                   must reach before the task will be resumed.
    170          *                            OS_OPT_TIME_PERIODIC   indicates that the delay specifies the periodic value that OSTickCtr
    171          *                                                   must reach before the task will be resumed.
    172          *
    173          *                        *** OS_OPT_TIME_HMSM_STRICT            strictly allow only hours        (0...99)
    174          *                                                                                   minutes      (0...59)
    175          *                                                                                   seconds      (0...59)
    176          *                                                                                   milliseconds (0...999)
    177          *                            OS_OPT_TIME_HMSM_NON_STRICT        allow any value of  hours        (0...999)
    178          *                                                                                   minutes      (0...9999)
    179          *                                                                                   seconds      (0...65535)
    180          *                                                                                   milliseconds (0...4294967295)
    181          *
    182          *              p_err     is a pointer to a variable that will receive an error code from this call.
    183          *
    184          *                            OS_ERR_NONE                        If the function returns from the desired delay
    185          *                            OS_ERR_OPT_INVALID                 If you specified an invalid option for 'opt'
    186          *                            OS_ERR_OS_NOT_RUNNING              If uC/OS-III is not running yet
    187          *                            OS_ERR_SCHED_LOCKED                Can't delay when the scheduler is locked
    188          *                            OS_ERR_TIME_DLY_ISR                If called from an ISR
    189          *                            OS_ERR_TIME_INVALID_HOURS          If you didn't specify a valid value for 'hours'
    190          *                            OS_ERR_TIME_INVALID_MINUTES        If you didn't specify a valid value for 'minutes'
    191          *                            OS_ERR_TIME_INVALID_SECONDS        If you didn't specify a valid value for 'seconds'
    192          *                            OS_ERR_TIME_INVALID_MILLISECONDS   If you didn't specify a valid value for 'milli'
    193          *                            OS_ERR_TIME_ZERO_DLY               If the effective delay is zero
    194          *                            OS_ERR_TICK_DISABLED               If kernel ticks are disabled
    195          *
    196          * Returns    : none
    197          *
    198          * Note(s)    : 1) The resolution on the milliseconds depends on the tick rate.  For example, you can't do a 10 mS delay
    199          *                 if the ticker interrupts every 100 mS.  In this case, the delay would be set to 0.  The actual delay
    200          *                 is rounded to the nearest tick.
    201          *
    202          *              2) Although this function allows you to delay a task for many, many hours, it's not recommended to put
    203          *                 a task to sleep for that long.
    204          ************************************************************************************************************************
    205          */
    206          
    207          #if (OS_CFG_TIME_DLY_HMSM_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    208          void  OSTimeDlyHMSM (CPU_INT16U   hours,
    209                               CPU_INT16U   minutes,
    210                               CPU_INT16U   seconds,
    211                               CPU_INT32U   milli,
    212                               OS_OPT       opt,
    213                               OS_ERR      *p_err)
    214          {
   \                     OSTimeDlyHMSM: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x9D07             LDR      R5,[SP, #+28]
    215          #if (OS_CFG_TICK_EN > 0u)
    216          #if (OS_CFG_ARG_CHK_EN > 0u)
    217              CPU_BOOLEAN  opt_invalid;
    218              CPU_BOOLEAN  opt_non_strict;
    219          #endif
    220              OS_OPT       opt_time;
    221              OS_RATE_HZ   tick_rate;
    222              OS_TICK      ticks;
    223              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    224          #endif
    225          
    226          
    227          
    228          #ifdef OS_SAFETY_CRITICAL
    229              if (p_err == (OS_ERR *)0) {
    230                  OS_SAFETY_CRITICAL_EXCEPTION();
    231                  return;
    232              }
    233          #endif
    234          
    235          #if (OS_CFG_TICK_EN == 0u)
    236              *p_err = OS_ERR_TICK_DISABLED;
    237              return;
    238          #else
    239          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    240              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTimeDlyHMSM_0
    241                 *p_err = OS_ERR_TIME_DLY_ISR;
   \   00000010   0xF247 0x2075      MOVW     R0,#+29301
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    242                  return;
   \   00000016   0xE09F             B.N      ??OSTimeDlyHMSM_1
    243              }
    244          #endif
    245          
    246          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    247              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTimeDlyHMSM_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable5_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD003             BEQ.N    ??OSTimeDlyHMSM_2
    248                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000020   0xF645 0x6089      MOVW     R0,#+24201
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    249                  return;
   \   00000026   0xE097             B.N      ??OSTimeDlyHMSM_1
    250              }
    251          #endif
    252          
    253              if (OSSchedLockNestingCtr > 0u) {                           /* Can't delay when the scheduler is locked             */
   \                     ??OSTimeDlyHMSM_2: (+1)
   \   00000028   0x....             LDR.N    R0,??DataTable5_2
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??OSTimeDlyHMSM_3
    254                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000030   0xF646 0x5063      MOVW     R0,#+28003
   \   00000034   0x8028             STRH     R0,[R5, #+0]
    255                  return;
   \   00000036   0xE08F             B.N      ??OSTimeDlyHMSM_1
    256              }
   \                     ??OSTimeDlyHMSM_3: (+1)
   \   00000038   0x9E06             LDR      R6,[SP, #+24]
    257          
    258              opt_time = opt & OS_OPT_TIME_MASK;                          /* Retrieve time options only.                          */
   \   0000003A   0xF016 0x070E      ANDS     R7,R6,#0xE
    259              switch (opt_time) {
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD005             BEQ.N    ??OSTimeDlyHMSM_4
   \   00000046   0x2802             CMP      R0,#+2
   \   00000048   0xD003             BEQ.N    ??OSTimeDlyHMSM_4
   \   0000004A   0x2804             CMP      R0,#+4
   \   0000004C   0xD001             BEQ.N    ??OSTimeDlyHMSM_4
   \   0000004E   0x2808             CMP      R0,#+8
   \   00000050   0xD107             BNE.N    ??OSTimeDlyHMSM_5
    260                  case OS_OPT_TIME_DLY:
    261                  case OS_OPT_TIME_TIMEOUT:
    262                  case OS_OPT_TIME_PERIODIC:
    263                  case OS_OPT_TIME_MATCH:
    264                       break;
    265          
    266                  default:
    267                      *p_err = OS_ERR_OPT_INVALID;
    268                       return;
    269              }
    270          
    271          #if (OS_CFG_ARG_CHK_EN > 0u)                                    /* Validate arguments to be within range                */
    272              opt_invalid = ((((opt) & (~OS_OPT_TIME_OPTS_MASK)) == 0u) ? (OS_FALSE) : (OS_TRUE));
   \                     ??OSTimeDlyHMSM_4: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000056   0xF030 0x001E      BICS     R0,R0,#0x1E
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD105             BNE.N    ??OSTimeDlyHMSM_6
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE004             B.N      ??OSTimeDlyHMSM_7
   \                     ??OSTimeDlyHMSM_5: (+1)
   \   00000062   0xF645 0x6025      MOVW     R0,#+24101
   \   00000066   0x8028             STRH     R0,[R5, #+0]
   \   00000068   0xE076             B.N      ??OSTimeDlyHMSM_1
   \                     ??OSTimeDlyHMSM_6: (+1)
   \   0000006A   0x2001             MOVS     R0,#+1
    273              if (opt_invalid == OS_TRUE) {
   \                     ??OSTimeDlyHMSM_7: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2801             CMP      R0,#+1
   \   00000070   0xD103             BNE.N    ??OSTimeDlyHMSM_8
    274                 *p_err = OS_ERR_OPT_INVALID;
   \   00000072   0xF645 0x6025      MOVW     R0,#+24101
   \   00000076   0x8028             STRH     R0,[R5, #+0]
    275                  return;
   \   00000078   0xE06E             B.N      ??OSTimeDlyHMSM_1
    276              }
    277          
    278              opt_non_strict = ((((opt) & (OS_OPT_TIME_HMSM_NON_STRICT)) == 0u) ? (OS_FALSE) : (OS_TRUE));
   \                     ??OSTimeDlyHMSM_8: (+1)
   \   0000007A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000007C   0xF3C6 0x1000      UBFX     R0,R6,#+4,#+1
   \   00000080   0xF010 0x0001      ANDS     R0,R0,#0x1
    279          
    280              if (opt_non_strict != OS_TRUE) {
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD01E             BEQ.N    ??OSTimeDlyHMSM_9
    281                   if (milli   > 999u) {
   \   0000008A   0xF5B3 0x7F7A      CMP      R3,#+1000
   \   0000008E   0xD303             BCC.N    ??OSTimeDlyHMSM_10
    282                      *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
   \   00000090   0xF247 0x207B      MOVW     R0,#+29307
   \   00000094   0x8028             STRH     R0,[R5, #+0]
    283                       return;
   \   00000096   0xE05F             B.N      ??OSTimeDlyHMSM_1
    284                   }
    285                   if (seconds > 59u) {
   \                     ??OSTimeDlyHMSM_10: (+1)
   \   00000098   0x0010             MOVS     R0,R2
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x283C             CMP      R0,#+60
   \   0000009E   0xD303             BCC.N    ??OSTimeDlyHMSM_11
    286                      *p_err = OS_ERR_TIME_INVALID_SECONDS;
   \   000000A0   0xF247 0x207A      MOVW     R0,#+29306
   \   000000A4   0x8028             STRH     R0,[R5, #+0]
    287                       return;
   \   000000A6   0xE057             B.N      ??OSTimeDlyHMSM_1
    288                   }
    289                   if (minutes > 59u) {
   \                     ??OSTimeDlyHMSM_11: (+1)
   \   000000A8   0x0008             MOVS     R0,R1
   \   000000AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AC   0x283C             CMP      R0,#+60
   \   000000AE   0xD303             BCC.N    ??OSTimeDlyHMSM_12
    290                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   000000B0   0xF247 0x2079      MOVW     R0,#+29305
   \   000000B4   0x8028             STRH     R0,[R5, #+0]
    291                       return;
   \   000000B6   0xE04F             B.N      ??OSTimeDlyHMSM_1
    292                   }
    293                   if (hours   > 99u) {
   \                     ??OSTimeDlyHMSM_12: (+1)
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000BC   0x2864             CMP      R0,#+100
   \   000000BE   0xD316             BCC.N    ??OSTimeDlyHMSM_13
    294                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   000000C0   0xF247 0x2078      MOVW     R0,#+29304
   \   000000C4   0x8028             STRH     R0,[R5, #+0]
    295                       return;
   \   000000C6   0xE047             B.N      ??OSTimeDlyHMSM_1
    296                   }
    297              } else {
    298                   if (minutes > 9999u) {
   \                     ??OSTimeDlyHMSM_9: (+1)
   \   000000C8   0x0008             MOVS     R0,R1
   \   000000CA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CC   0xF242 0x7610      MOVW     R6,#+10000
   \   000000D0   0x42B0             CMP      R0,R6
   \   000000D2   0xD303             BCC.N    ??OSTimeDlyHMSM_14
    299                      *p_err = OS_ERR_TIME_INVALID_MINUTES;
   \   000000D4   0xF247 0x2079      MOVW     R0,#+29305
   \   000000D8   0x8028             STRH     R0,[R5, #+0]
    300                       return;
   \   000000DA   0xE03D             B.N      ??OSTimeDlyHMSM_1
    301                   }
    302                   if (hours   > 999u) {
   \                     ??OSTimeDlyHMSM_14: (+1)
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E0   0xF5B0 0x7F7A      CMP      R0,#+1000
   \   000000E4   0xD303             BCC.N    ??OSTimeDlyHMSM_13
    303                      *p_err = OS_ERR_TIME_INVALID_HOURS;
   \   000000E6   0xF247 0x2078      MOVW     R0,#+29304
   \   000000EA   0x8028             STRH     R0,[R5, #+0]
    304                       return;
   \   000000EC   0xE034             B.N      ??OSTimeDlyHMSM_1
    305                   }
    306              }
    307          #endif
    308          
    309                                                                          /* Compute the total number of clock ticks required..   */
    310                                                                          /* .. (rounded to the nearest tick)                     */
    311              tick_rate = OSCfg_TickRate_Hz;
   \                     ??OSTimeDlyHMSM_13: (+1)
   \   000000EE   0x....             LDR.N    R0,??DataTable5_4
   \   000000F0   0x6806             LDR      R6,[R0, #+0]
    312              ticks     = ((((OS_TICK)hours * (OS_TICK)3600u) + ((OS_TICK)minutes * (OS_TICK)60u) + (OS_TICK)seconds) * tick_rate)
    313                        + ((tick_rate * ((OS_TICK)milli + ((OS_TICK)500u / tick_rate))) / (OS_TICK)1000u);
   \   000000F2   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   000000F4   0xF44F 0x6C61      MOV      R12,#+3600
   \   000000F8   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000FA   0x203C             MOVS     R0,#+60
   \   000000FC   0x4341             MULS     R1,R0,R1
   \   000000FE   0xFB0C 0x1404      MLA      R4,R12,R4,R1
   \   00000102   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000104   0x1914             ADDS     R4,R2,R4
   \   00000106   0xF44F 0x70FA      MOV      R0,#+500
   \   0000010A   0xFBB0 0xF0F6      UDIV     R0,R0,R6
   \   0000010E   0x18C3             ADDS     R3,R0,R3
   \   00000110   0xFB03 0xF306      MUL      R3,R3,R6
   \   00000114   0xF44F 0x707A      MOV      R0,#+1000
   \   00000118   0xFBB3 0xF0F0      UDIV     R0,R3,R0
   \   0000011C   0xFB06 0x0404      MLA      R4,R6,R4,R0
    314          
    315          
    316              CPU_CRITICAL_ENTER();
   \   00000120   0x2040             MOVS     R0,#+64
   \   00000122   0x.... 0x....      BL       CPU_SR_Save
   \   00000126   0x0006             MOVS     R6,R0
    317              OS_TickListInsertDly(OSTCBCurPtr,
    318                                   ticks,
    319                                   opt_time,
    320                                   p_err);
   \   00000128   0x002B             MOVS     R3,R5
   \   0000012A   0x003A             MOVS     R2,R7
   \   0000012C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000012E   0x0021             MOVS     R1,R4
   \   00000130   0x....             LDR.N    R0,??DataTable5_3
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x.... 0x....      BL       OS_TickListInsertDly
    321              if (*p_err != OS_ERR_NONE) {
   \   00000138   0x8828             LDRH     R0,[R5, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD003             BEQ.N    ??OSTimeDlyHMSM_15
    322                   CPU_CRITICAL_EXIT();
   \   0000013E   0x0030             MOVS     R0,R6
   \   00000140   0x.... 0x....      BL       CPU_SR_Restore
    323                   return;
   \   00000144   0xE008             B.N      ??OSTimeDlyHMSM_1
    324              }
    325          
    326              OS_RdyListRemove(OSTCBCurPtr);                              /* Remove current task from ready list                  */
   \                     ??OSTimeDlyHMSM_15: (+1)
   \   00000146   0x....             LDR.N    R0,??DataTable5_3
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x.... 0x....      BL       OS_RdyListRemove
    327              CPU_CRITICAL_EXIT();
   \   0000014E   0x0030             MOVS     R0,R6
   \   00000150   0x.... 0x....      BL       CPU_SR_Restore
    328              OSSched();                                                  /* Find next task to run!                               */
   \   00000154   0x.... 0x....      BL       OSSched
    329          #endif
    330          }
   \                     ??OSTimeDlyHMSM_1: (+1)
   \   00000158   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    331          #endif
    332          
    333          /*
    334          ************************************************************************************************************************
    335          *                                                RESUME A DELAYED TASK
    336          *
    337          * Description: This function is used resume a task that has been delayed through a call to either OSTimeDly() or
    338          *              OSTimeDlyHMSM().  Note that you cannot call this function to resume a task that is waiting for an event
    339          *              with timeout.
    340          *
    341          * Arguments  : p_tcb    is a pointer to the TCB of the task to resume.
    342          *
    343          *              p_err    is a pointer to a variable that will receive an error code
    344          *
    345          *                           OS_ERR_NONE                  Task has been resumed
    346          *                           OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    347          *                           OS_ERR_STATE_INVALID         Task is in an invalid state
    348          *                           OS_ERR_TASK_NOT_DLY          Task is not waiting for time to expire
    349          *                           OS_ERR_TASK_SUSPENDED        Task cannot be resumed, it was suspended by OSTaskSuspend()
    350          *                           OS_ERR_TCB_INVALID           If 'p_tcb' is a NULL pointer
    351          *                           OS_ERR_TIME_DLY_RESUME_ISR   If called from an ISR
    352          *
    353          * Returns    : none
    354          *
    355          * Note(s)    : none
    356          ************************************************************************************************************************
    357          */
    358          
    359          #if (OS_CFG_TIME_DLY_RESUME_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    360          void  OSTimeDlyResume (OS_TCB  *p_tcb,
    361                                 OS_ERR  *p_err)
    362          {
   \                     OSTimeDlyResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    363              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    364          
    365          
    366          
    367          #ifdef OS_SAFETY_CRITICAL
    368              if (p_err == (OS_ERR *)0) {
    369                  OS_SAFETY_CRITICAL_EXCEPTION();
    370                  return;
    371              }
    372          #endif
    373          
    374          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    375              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x....             LDR.N    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTimeDlyResume_0
    376                 *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
   \   00000010   0xF247 0x2076      MOVW     R0,#+29302
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    377                  return;
   \   00000016   0xE04B             B.N      ??OSTimeDlyResume_1
    378              }
    379          #endif
    380          
    381          #if (OS_CFG_ARG_CHK_EN > 0u)                                    /* ---------------- VALIDATE ARGUMENTS ---------------- */
    382              if (p_tcb == (OS_TCB *)0) {                                 /* User must supply a valid OS_TCB                      */
   \                     ??OSTimeDlyResume_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD103             BNE.N    ??OSTimeDlyResume_2
    383                 *p_err = OS_ERR_TCB_INVALID;
   \   0000001C   0xF247 0x10AD      MOVW     R0,#+29101
   \   00000020   0x8028             STRH     R0,[R5, #+0]
    384                  return;
   \   00000022   0xE045             B.N      ??OSTimeDlyResume_1
    385              }
    386          #endif
    387          
    388          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    389              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTimeDlyResume_2: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable5_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD003             BEQ.N    ??OSTimeDlyResume_3
    390                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002C   0xF645 0x6089      MOVW     R0,#+24201
   \   00000030   0x8028             STRH     R0,[R5, #+0]
    391                  return;
   \   00000032   0xE03D             B.N      ??OSTimeDlyResume_1
    392              }
    393          #endif
    394          
    395              CPU_CRITICAL_ENTER();
   \                     ??OSTimeDlyResume_3: (+1)
   \   00000034   0x2040             MOVS     R0,#+64
   \   00000036   0x.... 0x....      BL       CPU_SR_Save
   \   0000003A   0x0006             MOVS     R6,R0
    396              switch (p_tcb->TaskState) {
   \   0000003C   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00A             BEQ.N    ??OSTimeDlyResume_4
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD008             BEQ.N    ??OSTimeDlyResume_4
   \   00000048   0xD30E             BCC.N    ??OSTimeDlyResume_5
   \   0000004A   0x2804             CMP      R0,#+4
   \   0000004C   0xD005             BEQ.N    ??OSTimeDlyResume_4
   \   0000004E   0xD304             BCC.N    ??OSTimeDlyResume_4
   \   00000050   0x2806             CMP      R0,#+6
   \   00000052   0xD002             BEQ.N    ??OSTimeDlyResume_4
   \   00000054   0xD317             BCC.N    ??OSTimeDlyResume_6
   \   00000056   0x2807             CMP      R0,#+7
   \   00000058   0xD122             BNE.N    ??OSTimeDlyResume_7
    397                  case OS_TASK_STATE_RDY:                                 /* Cannot Abort delay if task is ready                  */
    398                  case OS_TASK_STATE_PEND:
    399                  case OS_TASK_STATE_PEND_TIMEOUT:
    400                  case OS_TASK_STATE_SUSPENDED:
    401                  case OS_TASK_STATE_PEND_SUSPENDED:
    402                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    403                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_4: (+1)
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x.... 0x....      BL       CPU_SR_Restore
    404                      *p_err = OS_ERR_TASK_NOT_DLY;
   \   00000060   0xF247 0x1051      MOVW     R0,#+29009
   \   00000064   0x8028             STRH     R0,[R5, #+0]
    405                       break;
   \   00000066   0xE021             B.N      ??OSTimeDlyResume_8
    406          
    407                  case OS_TASK_STATE_DLY:
    408                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \                     ??OSTimeDlyResume_5: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF884 0x002E      STRB     R0,[R4, #+46]
    409          #if (OS_CFG_TICK_EN > 0u)
    410                       OS_TickListRemove(p_tcb);                          /* Remove task from tick list                           */
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       OS_TickListRemove
    411                       OS_RdyListInsert(p_tcb);                           /* Add to ready list                                    */
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       OS_RdyListInsert
    412          #endif
    413                       CPU_CRITICAL_EXIT();
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
    414                      *p_err = OS_ERR_NONE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x8028             STRH     R0,[R5, #+0]
    415                       break;
   \   00000084   0xE012             B.N      ??OSTimeDlyResume_8
    416          
    417                  case OS_TASK_STATE_DLY_SUSPENDED:
    418                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OSTimeDlyResume_6: (+1)
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0xF884 0x002E      STRB     R0,[R4, #+46]
    419          #if (OS_CFG_TICK_EN > 0u)
    420                       OS_TickListRemove(p_tcb);                          /* Remove task from tick list                           */
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       OS_TickListRemove
    421          #endif
    422                       CPU_CRITICAL_EXIT();
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0x.... 0x....      BL       CPU_SR_Restore
    423                      *p_err            = OS_ERR_TASK_SUSPENDED;
   \   00000098   0xF247 0x105A      MOVW     R0,#+29018
   \   0000009C   0x8028             STRH     R0,[R5, #+0]
    424                       break;
   \   0000009E   0xE005             B.N      ??OSTimeDlyResume_8
    425          
    426                  default:
    427                       CPU_CRITICAL_EXIT();
   \                     ??OSTimeDlyResume_7: (+1)
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x.... 0x....      BL       CPU_SR_Restore
    428                      *p_err = OS_ERR_STATE_INVALID;
   \   000000A6   0xF646 0x602D      MOVW     R0,#+28205
   \   000000AA   0x8028             STRH     R0,[R5, #+0]
    429                       break;
    430              }
    431          
    432              OSSched();
   \                     ??OSTimeDlyResume_8: (+1)
   \   000000AC   0x.... 0x....      BL       OSSched
    433          }
   \                     ??OSTimeDlyResume_1: (+1)
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return
    434          #endif
    435          
    436          /*
    437          ************************************************************************************************************************
    438          *                                               GET CURRENT SYSTEM TIME
    439          *
    440          * Description: This function is used by your application to obtain the current value of the counter which keeps track of
    441          *              the number of clock ticks.
    442          *
    443          * Arguments  : p_err    is a pointer to a variable that will receive an error code
    444          *
    445          *                           OS_ERR_NONE              If the call was successful
    446          *                           OS_ERR_TICK_DISABLED     If kernel ticks are disabled
    447          *
    448          * Returns    : The current value of OSTickCtr
    449          *
    450          * Note(s)    : none
    451          ************************************************************************************************************************
    452          */
    453          

   \                                 In section .text, align 2, keep-with-next
    454          OS_TICK  OSTimeGet (OS_ERR  *p_err)
    455          {
   \                     OSTimeGet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    456              OS_TICK  ticks;
    457          #if (OS_CFG_TICK_EN > 0u)
    458              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    459          #endif
    460          
    461          
    462          #ifdef OS_SAFETY_CRITICAL
    463              if (p_err == (OS_ERR *)0) {
    464                  OS_SAFETY_CRITICAL_EXCEPTION();
    465                  return (0u);
    466              }
    467          #endif
    468          
    469          
    470          #if (OS_CFG_TICK_EN > 0u)
    471              CPU_CRITICAL_ENTER();
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
    472          #if (OS_CFG_DYN_TICK_EN > 0u)
    473              if (OSRunning == OS_STATE_OS_RUNNING) {
    474                  ticks = OSTickCtr + OS_DynTickGet();
    475              } else {
    476                  ticks = OSTickCtr;
    477              }
    478          #else
    479              ticks = OSTickCtr;
   \   0000000C   0x....             LDR.N    R1,??DataTable5_5
   \   0000000E   0x680D             LDR      R5,[R1, #+0]
    480          #endif
    481              CPU_CRITICAL_EXIT();
   \   00000010   0x.... 0x....      BL       CPU_SR_Restore
    482             *p_err = OS_ERR_NONE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x8020             STRH     R0,[R4, #+0]
    483          #else
    484              ticks = 0u;
    485             *p_err = OS_ERR_TICK_DISABLED;
    486          #endif
    487          
    488              return (ticks);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    489          }
    490          
    491          /*
    492          ************************************************************************************************************************
    493          *                                                   SET SYSTEM CLOCK
    494          *
    495          * Description: This function sets the counter which keeps track of the number of clock ticks.
    496          *
    497          * Arguments  : ticks    is the desired tick value
    498          *
    499          *              p_err    is a pointer to a variable that will receive an error code
    500          *
    501          *                           OS_ERR_NONE              If the call was successful
    502          *                           OS_ERR_TICK_DISABLED     If kernel ticks are disabled
    503          *
    504          * Returns    : none
    505          *
    506          * Note(s)    : none
    507          ************************************************************************************************************************
    508          */
    509          

   \                                 In section .text, align 2, keep-with-next
    510          void  OSTimeSet (OS_TICK   ticks,
    511                           OS_ERR   *p_err)
    512          {
   \                     OSTimeSet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    513          #if (OS_CFG_TICK_EN > 0u)
    514              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    515          
    516          #else
    517              (void)ticks;
    518          #endif
    519          
    520          
    521          #ifdef OS_SAFETY_CRITICAL
    522              if (p_err == (OS_ERR *)0) {
    523                  OS_SAFETY_CRITICAL_EXCEPTION();
    524                  return;
    525              }
    526          #endif
    527          
    528          #if (OS_CFG_TICK_EN > 0u)
    529              CPU_CRITICAL_ENTER();
   \   00000008   0x2040             MOVS     R0,#+64
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
    530              OSTickCtr = ticks;
   \   0000000E   0x....             LDR.N    R1,??DataTable5_5
   \   00000010   0x600C             STR      R4,[R1, #+0]
    531              OS_TRACE_TICK_INCREMENT(OSTickCtr);
    532              CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_SR_Restore
    533             *p_err = OS_ERR_NONE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    534          #else
    535             *p_err = OS_ERR_TICK_DISABLED;
    536          #endif
    537          
    538          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    539          
    540          
    541          /*
    542          ************************************************************************************************************************
    543          *                                                 PROCESS SYSTEM TICK
    544          *
    545          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    546          *              'clock tick').  This function should be called by the tick ISR.
    547          *
    548          * Arguments  : none
    549          *
    550          * Returns    : none
    551          *
    552          * Note(s)    : none
    553          ************************************************************************************************************************
    554          */
    555          

   \                                 In section .text, align 2, keep-with-next
    556          void  OSTimeTick (void)
    557          {
   \                     OSTimeTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    558              if (OSRunning != OS_STATE_OS_RUNNING) {
   \   00000002   0x....             LDR.N    R0,??DataTable5_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE.N    ??OSTimeTick_0
    559                  return;
    560              }
    561          
    562              OSTimeTickHook();                                           /* Call user definable hook                             */
   \                     ??OSTimeTick_1: (+1)
   \   0000000A   0x.... 0x....      BL       OSTimeTickHook
    563          
    564          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)
    565              OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);                  /* Update quanta ctr for the task which just ran        */
   \   0000000E   0x....             LDR.N    R0,??DataTable5_6
   \   00000010   0x....             LDR.N    R1,??DataTable5_7
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0xEB00 0x00C1      ADD      R0,R0,R1, LSL #+3
   \   00000018   0x.... 0x....      BL       OS_SchedRoundRobin
    566          #endif
    567          
    568          #if (OS_CFG_TICK_EN > 0u)
    569              OS_TickUpdate(1u);                                          /* Update from the ISR                                  */
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       OS_TickUpdate
    570          #endif
    571          }
   \                     ??OSTimeTick_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     OSPrioCur
    572          
    573          
    574          /*
    575          ************************************************************************************************************************
    576          *                                             PROCESS SYSTEM TICK (DYNAMIC)
    577          *
    578          * Description: This function is used to signal to uC/OS-III the occurrence of a 'system tick' (also known as a
    579          *              'clock tick').  This function should be called by the tick ISR.
    580          *
    581          * Arguments  : none
    582          *
    583          * Returns    : none
    584          *
    585          * Note(s)    : none
    586          ************************************************************************************************************************
    587          */
    588          
    589          #if (OS_CFG_DYN_TICK_EN > 0u)
    590          void  OSTimeDynTick (OS_TICK  ticks)
    591          {
    592              if (OSRunning != OS_STATE_OS_RUNNING) {
    593                  return;
    594              }
    595          
    596              OSTimeTickHook();
    597          
    598              OS_TickUpdate(ticks);                                       /* Update from the ISR                                  */
    599          }
    600          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTimeDly
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsertDly
      24   OSTimeDlyHMSM
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_RdyListRemove
        24   -> OS_TickListInsertDly
      16   OSTimeDlyResume
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
      16   OSTimeGet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTimeSet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       8   OSTimeTick
         8   -> OSTimeTickHook
         8   -> OS_SchedRoundRobin
         8   -> OS_TickUpdate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
     144  OSTimeDly
     346  OSTimeDlyHMSM
     178  OSTimeDlyResume
      28  OSTimeGet
      28  OSTimeSet
      36  OSTimeTick

 
 792 bytes in section .text
 
 792 bytes of CODE memory

Errors: none
Warnings: none
