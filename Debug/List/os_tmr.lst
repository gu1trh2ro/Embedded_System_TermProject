###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  11:44:51
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_tmr.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW2BD0.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_tmr.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_tmr.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_tmr.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_tmr.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                           TIMER MANAGEMENT
     20          *
     21          * File    : os_tmr.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_tmr__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_TMR_EN > 0u)
     35          /*
     36          ************************************************************************************************************************
     37          *                                               LOCAL FUNCTION PROTOTYPES
     38          ************************************************************************************************************************
     39          */
     40          
     41          static  void  OS_TmrLock      (void);
     42          static  void  OS_TmrUnlock    (void);
     43          
     44          static  void  OS_TmrCondCreate(void);
     45          static  void  OS_TmrCondSignal(void);
     46          static  void  OS_TmrCondWait  (OS_TICK  timeout);
     47          
     48          
     49          /*
     50          ************************************************************************************************************************
     51          *                                                   CREATE A TIMER
     52          *
     53          * Description: This function is called by your application code to create a timer.
     54          *
     55          * Arguments  : p_tmr           Is a pointer to a timer control block
     56          *
     57          *              p_name          Is a pointer to an ASCII string that is used to name the timer.  Names are useful for
     58          *                              debugging.
     59          *
     60          *              dly             Initial delay.
     61          *                              If the timer is configured for ONE-SHOT mode, this is the timeout used
     62          *                              If the timer is configured for PERIODIC mode, this is the first timeout to wait for
     63          *                              before the timer starts entering periodic mode
     64          *
     65          *              period          The 'period' being repeated for the timer.
     66          *                              If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer expires, it will
     67          *                              automatically restart with the same period.
     68          *
     69          *              opt             Specifies either:
     70          *
     71          *                                  OS_OPT_TMR_ONE_SHOT       The timer counts down only once
     72          *                                  OS_OPT_TMR_PERIODIC       The timer counts down and then reloads itself
     73          *
     74          *              p_callback      Is a pointer to a callback function that will be called when the timer expires.  The
     75          *                              callback function must be declared as follows:
     76          *
     77          *                                  void  MyCallback (OS_TMR *p_tmr, void *p_arg);
     78          *
     79          *              p_callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
     80          *
     81          *              p_err           Is a pointer to an error code.  '*p_err' will contain one of the following:
     82          *
     83          *                                 OS_ERR_NONE                    The call succeeded
     84          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the timer after you called
     85          *                                                                  OSSafetyCriticalStart()
     86          *                                 OS_ERR_OBJ_PTR_NULL            Is 'p_tmr' is a NULL pointer
     87          *                                 OS_ERR_OPT_INVALID             You specified an invalid option
     88          *                                 OS_ERR_TMR_INVALID_CALLBACK    You specified an invalid callback for a periodic timer
     89          *                                 OS_ERR_TMR_INVALID_DLY         You specified an invalid delay
     90          *                                 OS_ERR_TMR_INVALID_PERIOD      You specified an invalid period
     91          *                                 OS_ERR_TMR_ISR                 If the call was made from an ISR
     92          *                                 OS_ERR_OBJ_CREATED             If the timer was already created
     93          *
     94          * Returns    : none
     95          *
     96          * Note(s)    : 1) This function only creates the timer.  In other words, the timer is not started when created.  To
     97          *                 start the timer, call OSTmrStart().
     98          ************************************************************************************************************************
     99          */
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void  OSTmrCreate (OS_TMR               *p_tmr,
    102                             CPU_CHAR             *p_name,
    103                             OS_TICK               dly,
    104                             OS_TICK               period,
    105                             OS_OPT                opt,
    106                             OS_TMR_CALLBACK_PTR   p_callback,
    107                             void                 *p_callback_arg,
    108                             OS_ERR               *p_err)
    109          {
   \                     OSTmrCreate: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0xF8DD 0x802C      LDR      R8,[SP, #+44]
    110          #ifdef OS_SAFETY_CRITICAL
    111              if (p_err == (OS_ERR *)0) {
    112                  OS_SAFETY_CRITICAL_EXCEPTION();
    113                  return;
    114              }
    115          #endif
    116          
    117          #ifdef OS_SAFETY_CRITICAL_IEC61508
    118              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    119                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    120                  return;
    121              }
    122          #endif
    123          
    124          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    125              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSTmrCreate_0
    126                 *p_err = OS_ERR_TMR_ISR;
   \   00000018   0xF247 0x3043      MOVW     R0,#+29507
   \   0000001C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    127                  return;
   \   00000020   0xE068             B.N      ??OSTmrCreate_1
    128              }
    129          #endif
    130          
    131          #if (OS_CFG_ARG_CHK_EN > 0u)
    132              if (p_tmr == (OS_TMR *)0) {                                 /* Validate 'p_tmr'                                     */
   \                     ??OSTmrCreate_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSTmrCreate_2
    133                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000026   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000002A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    134                  return;
   \   0000002E   0xE061             B.N      ??OSTmrCreate_1
    135              }
   \                     ??OSTmrCreate_2: (+1)
   \   00000030   0xF8DD 0x9024      LDR      R9,[SP, #+36]
   \   00000034   0x9F08             LDR      R7,[SP, #+32]
    136          
    137              switch (opt) {
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD028             BEQ.N    ??OSTmrCreate_3
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xD12E             BNE.N    ??OSTmrCreate_4
    138                  case OS_OPT_TMR_PERIODIC:
    139                       if (period == 0u) {
   \                     ??OSTmrCreate_5: (+1)
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD104             BNE.N    ??OSTmrCreate_6
    140                          *p_err = OS_ERR_TMR_INVALID_PERIOD;
   \   00000046   0xF247 0x3040      MOVW     R0,#+29504
   \   0000004A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    141                           return;
   \   0000004E   0xE051             B.N      ??OSTmrCreate_1
    142                       }
    143          
    144                       if (p_callback == (OS_TMR_CALLBACK_PTR)0) {        /* No point in a periodic timer without a callback      */
   \                     ??OSTmrCreate_6: (+1)
   \   00000050   0x4648             MOV      R0,R9
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD104             BNE.N    ??OSTmrCreate_7
    145                          *p_err = OS_ERR_TMR_INVALID_CALLBACK;
   \   00000056   0xF247 0x304A      MOVW     R0,#+29514
   \   0000005A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    146                           return;
   \   0000005E   0xE049             B.N      ??OSTmrCreate_1
    147                       }
    148                       break;
    149          
    150                  case OS_OPT_TMR_ONE_SHOT:
    151                       if (dly == 0u) {
    152                          *p_err = OS_ERR_TMR_INVALID_DLY;
    153                           return;
    154                       }
    155                       break;
    156          
    157                  default:
    158                      *p_err = OS_ERR_OPT_INVALID;
    159                       return;
    160              }
    161          #endif
    162          
    163              if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only lock when the kernel is running                 */
   \                     ??OSTmrCreate_7: (+1)
   \                     ??OSTmrCreate_8: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD101             BNE.N    ??OSTmrCreate_9
    164                  OS_TmrLock();
   \   0000006A   0x.... 0x....      BL       OS_TmrLock
    165              }
    166          
    167          #if (OS_OBJ_TYPE_REQ > 0u)
    168          #if (OS_CFG_OBJ_CREATED_CHK_EN > 0u)
    169              if (p_tmr->Type == OS_OBJ_TYPE_TMR) {
   \                     ??OSTmrCreate_9: (+1)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD118             BNE.N    ??OSTmrCreate_10
    170                  if (OSRunning == OS_STATE_OS_RUNNING) {
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD101             BNE.N    ??OSTmrCreate_11
    171                      OS_TmrUnlock();
   \   00000082   0x.... 0x....      BL       OS_TmrUnlock
    172                  }
    173                  *p_err = OS_ERR_OBJ_CREATED;
   \                     ??OSTmrCreate_11: (+1)
   \   00000086   0xF645 0x50C1      MOVW     R0,#+24001
   \   0000008A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    174                  return;
   \   0000008E   0xE031             B.N      ??OSTmrCreate_1
    175              }
   \                     ??OSTmrCreate_3: (+1)
   \   00000090   0x2E00             CMP      R6,#+0
   \   00000092   0xD104             BNE.N    ??OSTmrCreate_12
   \   00000094   0xF247 0x303F      MOVW     R0,#+29503
   \   00000098   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000009C   0xE02A             B.N      ??OSTmrCreate_1
   \                     ??OSTmrCreate_12: (+1)
   \   0000009E   0xE7DF             B.N      ??OSTmrCreate_8
   \                     ??OSTmrCreate_4: (+1)
   \   000000A0   0xF645 0x6025      MOVW     R0,#+24101
   \   000000A4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000000A8   0xE024             B.N      ??OSTmrCreate_1
   \                     ??OSTmrCreate_10: (+1)
   \   000000AA   0x990A             LDR      R1,[SP, #+40]
    176          #endif
    177              p_tmr->Type           = OS_OBJ_TYPE_TMR;
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x20524d54
   \   000000B0   0x6020             STR      R0,[R4, #+0]
    178          #endif
    179          
    180              p_tmr->State          = OS_TMR_STATE_STOPPED;               /* Initialize the timer fields                          */
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xF884 0x0022      STRB     R0,[R4, #+34]
    181          #if (OS_CFG_DBG_EN > 0u)
    182              p_tmr->NamePtr        = p_name;
    183          #else
    184              (void)p_name;
    185          #endif
    186              p_tmr->Dly            =  dly    * OSTmrToTicksMult;         /* Convert to Timer Start Delay to ticks                */
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x4346             MULS     R6,R0,R6
   \   000000C0   0x61A6             STR      R6,[R4, #+24]
    187              p_tmr->Remain         =  0u;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x6160             STR      R0,[R4, #+20]
    188              p_tmr->Period         =  period * OSTmrToTicksMult;         /* Convert to Timer Period      to ticks                */
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x4345             MULS     R5,R0,R5
   \   000000CE   0x61E5             STR      R5,[R4, #+28]
    189              p_tmr->Opt            =  opt;
   \   000000D0   0x8427             STRH     R7,[R4, #+32]
    190              p_tmr->CallbackPtr    =  p_callback;
   \   000000D2   0xF8C4 0x9004      STR      R9,[R4, #+4]
    191              p_tmr->CallbackPtrArg =  p_callback_arg;
   \   000000D6   0x60A1             STR      R1,[R4, #+8]
    192              p_tmr->NextPtr        = (OS_TMR *)0;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x60E0             STR      R0,[R4, #+12]
    193              p_tmr->PrevPtr        = (OS_TMR *)0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x6120             STR      R0,[R4, #+16]
    194          
    195          #if (OS_CFG_DBG_EN > 0u)
    196              OS_TmrDbgListAdd(p_tmr);
    197          #endif
    198          #if (OS_CFG_DBG_EN > 0u)
    199              OSTmrQty++;                                                 /* Keep track of the number of timers created           */
    200          #endif
    201          
    202              if (OSRunning == OS_STATE_OS_RUNNING) {
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD101             BNE.N    ??OSTmrCreate_13
    203                  OS_TmrUnlock();
   \   000000EA   0x.... 0x....      BL       OS_TmrUnlock
    204              }
    205          
    206             *p_err = OS_ERR_NONE;
   \                     ??OSTmrCreate_13: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    207          }
   \                     ??OSTmrCreate_1: (+1)
   \   000000F4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    208          
    209          
    210          /*
    211          ************************************************************************************************************************
    212          *                                                   DELETE A TIMER
    213          *
    214          * Description: This function is called by your application code to delete a timer.
    215          *
    216          * Arguments  : p_tmr          Is a pointer to the timer to stop and delete.
    217          *
    218          *              p_err          Is a pointer to an error code.  '*p_err' will contain one of the following:
    219          *
    220          *                                 OS_ERR_NONE                    The call succeeded
    221          *                                 OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the timer after you called
    222          *                                                                  OSStart()
    223          *                                 OS_ERR_OBJ_TYPE                If 'p_tmr' is not pointing to a timer
    224          *                                 OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    225          *                                 OS_ERR_TMR_INACTIVE            If the timer was not created
    226          *                                 OS_ERR_TMR_INVALID             If 'p_tmr' is a NULL pointer
    227          *                                 OS_ERR_TMR_INVALID_STATE       The timer is in an invalid state
    228          *                                 OS_ERR_TMR_ISR                 If the function was called from an ISR
    229          *
    230          * Returns    : OS_TRUE   if the timer was deleted
    231          *              OS_FALSE  if not or upon an error
    232          *
    233          * Note(s)    : none
    234          ************************************************************************************************************************
    235          */
    236          
    237          #if (OS_CFG_TMR_DEL_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    238          CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
    239                                 OS_ERR  *p_err)
    240          {
   \                     OSTmrDel: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    241              CPU_BOOLEAN  success;
    242              OS_TICK      time;
    243              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    244          
    245          
    246          #ifdef OS_SAFETY_CRITICAL
    247              if (p_err == (OS_ERR *)0) {
    248                  OS_SAFETY_CRITICAL_EXCEPTION();
    249                  return (OS_FALSE);
    250              }
    251          #endif
    252          
    253          #ifdef OS_SAFETY_CRITICAL_IEC61508
    254              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    255                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    256                  return (OS_FALSE);
    257              }
    258          #endif
    259          
    260          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    261              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTmrDel_0
    262                 *p_err  = OS_ERR_TMR_ISR;
   \   00000012   0xF247 0x3043      MOVW     R0,#+29507
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    263                  return (OS_FALSE);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE059             B.N      ??OSTmrDel_1
    264              }
    265          #endif
    266          
    267          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    268              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTmrDel_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSTmrDel_2
    269                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    270                  return (OS_FALSE);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE04F             B.N      ??OSTmrDel_1
    271              }
    272          #endif
    273          
    274          #if (OS_CFG_ARG_CHK_EN > 0u)
    275              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrDel_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE.N    ??OSTmrDel_3
    276                 *p_err = OS_ERR_TMR_INVALID;
   \   00000034   0xF247 0x3042      MOVW     R0,#+29506
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    277                  return (OS_FALSE);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE048             B.N      ??OSTmrDel_1
    278              }
    279          #endif
    280          
    281          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    282              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
   \                     ??OSTmrDel_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD004             BEQ.N    ??OSTmrDel_4
    283                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000048   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
    284                  return (OS_FALSE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE03E             B.N      ??OSTmrDel_1
    285              }
    286          #endif
    287          
    288              OS_TmrLock();
   \                     ??OSTmrDel_4: (+1)
   \   00000052   0x.... 0x....      BL       OS_TmrLock
    289          
    290              CPU_CRITICAL_ENTER();
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
    291              if (OSTCBCurPtr == &OSTmrTaskTCB) {                         /* Callbacks operate on the Tmr Task's tick base.       */
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable16_5
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xD103             BNE.N    ??OSTmrDel_5
    292                  time = OSTmrTaskTickBase;
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   0000006E   0x680E             LDR      R6,[R1, #+0]
   \   00000070   0xE002             B.N      ??OSTmrDel_6
    293              } else {
    294          #if (OS_CFG_DYN_TICK_EN > 0u)
    295                  time = OSTickCtr + OS_DynTickGet();
    296          #else
    297                  time = OSTickCtr;
   \                     ??OSTmrDel_5: (+1)
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   00000076   0x680E             LDR      R6,[R1, #+0]
    298          #endif
    299              }
    300              CPU_CRITICAL_EXIT();
   \                     ??OSTmrDel_6: (+1)
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
    301          
    302          #if (OS_CFG_DBG_EN > 0u)
    303              OS_TmrDbgListRemove(p_tmr);
    304          #endif
    305          
    306              switch (p_tmr->State) {
   \   0000007C   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD018             BEQ.N    ??OSTmrDel_7
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xD004             BEQ.N    ??OSTmrDel_8
   \   00000088   0xD30E             BCC.N    ??OSTmrDel_9
   \   0000008A   0x2804             CMP      R0,#+4
   \   0000008C   0xD001             BEQ.N    ??OSTmrDel_8
   \   0000008E   0xD30B             BCC.N    ??OSTmrDel_9
   \   00000090   0xE016             B.N      ??OSTmrDel_10
    307                  case OS_TMR_STATE_RUNNING:
    308                  case OS_TMR_STATE_TIMEOUT:
    309                       OS_TmrUnlink(p_tmr, time);                         /* Remove from the list                                 */
   \                     ??OSTmrDel_8: (+1)
   \   00000092   0x0031             MOVS     R1,R6
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       OS_TmrUnlink
    310                       OS_TmrClr(p_tmr);
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       OS_TmrClr
    311          #if (OS_CFG_DBG_EN > 0u)
    312                       OSTmrQty--;                                        /* One less timer                                       */
    313          #endif
    314                      *p_err   = OS_ERR_NONE;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x8028             STRH     R0,[R5, #+0]
    315                       success = OS_TRUE;
   \   000000A4   0x2401             MOVS     R4,#+1
    316                       break;
   \   000000A6   0xE00F             B.N      ??OSTmrDel_11
    317          
    318                  case OS_TMR_STATE_STOPPED:                              /* Timer has not started or ...                         */
    319                  case OS_TMR_STATE_COMPLETED:                            /* ... timer has completed the ONE-SHOT time            */
    320                       OS_TmrClr(p_tmr);                                  /* Clear timer fields                                   */
   \                     ??OSTmrDel_9: (+1)
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       OS_TmrClr
    321          #if (OS_CFG_DBG_EN > 0u)
    322                       OSTmrQty--;                                        /* One less timer                                       */
    323          #endif
    324                      *p_err   = OS_ERR_NONE;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x8028             STRH     R0,[R5, #+0]
    325                       success = OS_TRUE;
   \   000000B2   0x2401             MOVS     R4,#+1
    326                       break;
   \   000000B4   0xE008             B.N      ??OSTmrDel_11
    327          
    328                  case OS_TMR_STATE_UNUSED:                               /* Already deleted                                      */
    329                      *p_err   = OS_ERR_TMR_INACTIVE;
   \                     ??OSTmrDel_7: (+1)
   \   000000B6   0xF247 0x303D      MOVW     R0,#+29501
   \   000000BA   0x8028             STRH     R0,[R5, #+0]
    330                       success = OS_FALSE;
   \   000000BC   0x2400             MOVS     R4,#+0
    331                       break;
   \   000000BE   0xE003             B.N      ??OSTmrDel_11
    332          
    333                  default:
    334                      *p_err   = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrDel_10: (+1)
   \   000000C0   0xF247 0x3041      MOVW     R0,#+29505
   \   000000C4   0x8028             STRH     R0,[R5, #+0]
    335                       success = OS_FALSE;
   \   000000C6   0x2400             MOVS     R4,#+0
    336                       break;
    337              }
    338          
    339              OS_TmrUnlock();
   \                     ??OSTmrDel_11: (+1)
   \   000000C8   0x.... 0x....      BL       OS_TmrUnlock
    340          
    341              return (success);
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrDel_1: (+1)
   \   000000D0   0xBD70             POP      {R4-R6,PC}       ;; return
    342          }
    343          #endif
    344          
    345          
    346          /*
    347          ************************************************************************************************************************
    348          *                                    GET HOW MUCH TIME IS LEFT BEFORE A TIMER EXPIRES
    349          *
    350          * Description: This function is called to get the number of timer increments before a timer times out.
    351          *
    352          * Arguments  : p_tmr    Is a pointer to the timer to obtain the remaining time from.
    353          *
    354          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    355          *
    356          *                           OS_ERR_NONE               The call succeeded
    357          *                           OS_ERR_OBJ_TYPE           If 'p_tmr' is not pointing to a timer
    358          *                           OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    359          *                           OS_ERR_TMR_INACTIVE       If 'p_tmr' points to a timer that is not active
    360          *                           OS_ERR_TMR_INVALID        If 'p_tmr' is a NULL pointer
    361          *                           OS_ERR_TMR_INVALID_STATE  The timer is in an invalid state
    362          *                           OS_ERR_TMR_ISR            If the call was made from an ISR
    363          *
    364          * Returns    : The time remaining for the timer to expire.  The time represents 'timer' increments (typically 1/10 sec).
    365          *
    366          * Note(s)    : none
    367          ************************************************************************************************************************
    368          */
    369          

   \                                 In section .text, align 2, keep-with-next
    370          OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
    371                                   OS_ERR  *p_err)
    372          {
   \                     OSTmrRemainGet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    373              OS_TMR   *p_tmr1;
    374              OS_TICK   remain;
    375          
    376          
    377          #ifdef OS_SAFETY_CRITICAL
    378              if (p_err == (OS_ERR *)0) {
    379                  OS_SAFETY_CRITICAL_EXCEPTION();
    380                  return (0u);
    381              }
    382          #endif
    383          
    384          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    385              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??OSTmrRemainGet_0
    386                 *p_err = OS_ERR_TMR_ISR;
   \   00000010   0xF247 0x3043      MOVW     R0,#+29507
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    387                  return (0u);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE068             B.N      ??OSTmrRemainGet_1
    388              }
    389          #endif
    390          
    391          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    392              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTmrRemainGet_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD004             BEQ.N    ??OSTmrRemainGet_2
    393                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000024   0xF645 0x6089      MOVW     R0,#+24201
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    394                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE05E             B.N      ??OSTmrRemainGet_1
    395              }
    396          #endif
    397          
    398          #if (OS_CFG_ARG_CHK_EN > 0u)
    399              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrRemainGet_2: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD104             BNE.N    ??OSTmrRemainGet_3
    400                 *p_err = OS_ERR_TMR_INVALID;
   \   00000032   0xF247 0x3042      MOVW     R0,#+29506
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    401                  return (0u);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE057             B.N      ??OSTmrRemainGet_1
    402              }
    403          #endif
    404          
    405          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    406              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
   \                     ??OSTmrRemainGet_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD004             BEQ.N    ??OSTmrRemainGet_4
    407                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000046   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004A   0x8028             STRH     R0,[R5, #+0]
    408                  return (0u);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE04D             B.N      ??OSTmrRemainGet_1
    409              }
    410          #endif
    411          
    412              OS_TmrLock();
   \                     ??OSTmrRemainGet_4: (+1)
   \   00000050   0x.... 0x....      BL       OS_TmrLock
    413          
    414              switch (p_tmr->State) {
   \   00000054   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD03B             BEQ.N    ??OSTmrRemainGet_5
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD004             BEQ.N    ??OSTmrRemainGet_6
   \   00000060   0xD317             BCC.N    ??OSTmrRemainGet_7
   \   00000062   0x2804             CMP      R0,#+4
   \   00000064   0xD032             BEQ.N    ??OSTmrRemainGet_8
   \   00000066   0xD331             BCC.N    ??OSTmrRemainGet_8
   \   00000068   0xE039             B.N      ??OSTmrRemainGet_9
    415                  case OS_TMR_STATE_RUNNING:
    416                       p_tmr1 = OSTmrListPtr;
   \                     ??OSTmrRemainGet_6: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
    417                       remain = 0u;
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0xE000             B.N      ??OSTmrRemainGet_10
    418                       while (p_tmr1 != (OS_TMR *)0) {                    /* Add up all the deltas up until the current timer     */
    419                           remain += p_tmr1->Remain;
    420                           if (p_tmr1 == p_tmr) {
    421                               break;
    422                           }
    423                           p_tmr1 = p_tmr1->NextPtr;
   \                     ??OSTmrRemainGet_11: (+1)
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \                     ??OSTmrRemainGet_10: (+1)
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD003             BEQ.N    ??OSTmrRemainGet_12
   \   0000007A   0x6941             LDR      R1,[R0, #+20]
   \   0000007C   0x188A             ADDS     R2,R1,R2
   \   0000007E   0x42A0             CMP      R0,R4
   \   00000080   0xD1F8             BNE.N    ??OSTmrRemainGet_11
    424                       }
    425                       remain /= OSTmrToTicksMult;
   \                     ??OSTmrRemainGet_12: (+1)
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0xFBB2 0xF4F0      UDIV     R4,R2,R0
    426                      *p_err   = OS_ERR_NONE;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
    427                       break;
   \   00000090   0xE029             B.N      ??OSTmrRemainGet_13
    428          
    429                  case OS_TMR_STATE_STOPPED:                              /* It's assumed that the timer has not started yet      */
    430                       if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
   \                     ??OSTmrRemainGet_7: (+1)
   \   00000092   0x8C20             LDRH     R0,[R4, #+32]
   \   00000094   0x2802             CMP      R0,#+2
   \   00000096   0xD110             BNE.N    ??OSTmrRemainGet_14
    431                           if (p_tmr->Dly == 0u) {
   \   00000098   0x69A0             LDR      R0,[R4, #+24]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD106             BNE.N    ??OSTmrRemainGet_15
    432                               remain = p_tmr->Period / OSTmrToTicksMult;
   \   0000009E   0x69E0             LDR      R0,[R4, #+28]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0xFBB0 0xF4F1      UDIV     R4,R0,R1
   \   000000AA   0xE00C             B.N      ??OSTmrRemainGet_16
    433                           } else {
    434                               remain = p_tmr->Dly / OSTmrToTicksMult;
   \                     ??OSTmrRemainGet_15: (+1)
   \   000000AC   0x69A0             LDR      R0,[R4, #+24]
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   000000B2   0x6809             LDR      R1,[R1, #+0]
   \   000000B4   0xFBB0 0xF4F1      UDIV     R4,R0,R1
   \   000000B8   0xE005             B.N      ??OSTmrRemainGet_16
    435                           }
    436                       } else {
    437                           remain = p_tmr->Dly / OSTmrToTicksMult;
   \                     ??OSTmrRemainGet_14: (+1)
   \   000000BA   0x69A0             LDR      R0,[R4, #+24]
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   000000C0   0x6809             LDR      R1,[R1, #+0]
   \   000000C2   0xFBB0 0xF4F1      UDIV     R4,R0,R1
    438                       }
    439                      *p_err = OS_ERR_NONE;
   \                     ??OSTmrRemainGet_16: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x8028             STRH     R0,[R5, #+0]
    440                       break;
   \   000000CA   0xE00C             B.N      ??OSTmrRemainGet_13
    441          
    442                  case OS_TMR_STATE_TIMEOUT:                              /* Within a callback, timers are in the TIMEOUT state   */
    443                  case OS_TMR_STATE_COMPLETED:                            /* Only ONE-SHOT timers can be in the COMPLETED state   */
    444                      *p_err  = OS_ERR_NONE;
   \                     ??OSTmrRemainGet_8: (+1)
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x8028             STRH     R0,[R5, #+0]
    445                       remain = 0u;
   \   000000D0   0x2400             MOVS     R4,#+0
    446                       break;
   \   000000D2   0xE008             B.N      ??OSTmrRemainGet_13
    447          
    448                  case OS_TMR_STATE_UNUSED:
    449                      *p_err  = OS_ERR_TMR_INACTIVE;
   \                     ??OSTmrRemainGet_5: (+1)
   \   000000D4   0xF247 0x303D      MOVW     R0,#+29501
   \   000000D8   0x8028             STRH     R0,[R5, #+0]
    450                       remain = 0u;
   \   000000DA   0x2400             MOVS     R4,#+0
    451                       break;
   \   000000DC   0xE003             B.N      ??OSTmrRemainGet_13
    452          
    453                  default:
    454                      *p_err = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrRemainGet_9: (+1)
   \   000000DE   0xF247 0x3041      MOVW     R0,#+29505
   \   000000E2   0x8028             STRH     R0,[R5, #+0]
    455                       remain = 0u;
   \   000000E4   0x2400             MOVS     R4,#+0
    456                       break;
    457              }
    458          
    459              OS_TmrUnlock();
   \                     ??OSTmrRemainGet_13: (+1)
   \   000000E6   0x.... 0x....      BL       OS_TmrUnlock
    460          
    461              return (remain);
   \   000000EA   0x0020             MOVS     R0,R4
   \                     ??OSTmrRemainGet_1: (+1)
   \   000000EC   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    462          }
    463          
    464          
    465          /*
    466          ************************************************************************************************************************
    467          *                                                    SET A TIMER
    468          *
    469          * Description: This function is called by your application code to set a timer.
    470          *
    471          * Arguments  : p_tmr           Is a pointer to a timer control block
    472          *
    473          *              dly             Initial delay.
    474          *                              If the timer is configured for ONE-SHOT mode, this is the timeout used
    475          *                              If the timer is configured for PERIODIC mode, this is the first timeout to wait for
    476          *                              before the timer starts entering periodic mode
    477          *
    478          *              period          The 'period' being repeated for the timer.
    479          *                              If you specified 'OS_OPT_TMR_PERIODIC' as an option, when the timer expires, it will
    480          *                              automatically restart with the same period.
    481          *
    482          *              p_callback      Is a pointer to a callback function that will be called when the timer expires.  The
    483          *                              callback function must be declared as follows:
    484          *
    485          *                                  void  MyCallback (OS_TMR *p_tmr, void *p_arg);
    486          *
    487          *              p_callback_arg  Is an argument (a pointer) that is passed to the callback function when it is called.
    488          *
    489          *              p_err           Is a pointer to an error code.  '*p_err' will contain one of the following:
    490          *
    491          *                                 OS_ERR_NONE                    The timer was configured as expected
    492          *                                 OS_ERR_OBJ_TYPE                If the object type is invalid
    493          *                                 OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    494          *                                 OS_ERR_TMR_INVALID             If 'p_tmr' is a NULL pointer or invalid option
    495          *                                 OS_ERR_TMR_INVALID_CALLBACK    you specified an invalid callback for a periodic timer
    496          *                                 OS_ERR_TMR_INVALID_DLY         You specified an invalid delay
    497          *                                 OS_ERR_TMR_INVALID_PERIOD      You specified an invalid period
    498          *                                 OS_ERR_TMR_ISR                 If the call was made from an ISR
    499          *
    500          * Returns    : none
    501          *
    502          * Note(s)    : 1) This function can be called on a running timer. The change to the delay and period will only
    503          *                 take effect after the current period or delay has passed. Change to the callback will take
    504          *                 effect immediately.
    505          ************************************************************************************************************************
    506          */
    507          

   \                                 In section .text, align 2, keep-with-next
    508          void  OSTmrSet (OS_TMR               *p_tmr,
    509                          OS_TICK               dly,
    510                          OS_TICK               period,
    511                          OS_TMR_CALLBACK_PTR   p_callback,
    512                          void                 *p_callback_arg,
    513                          OS_ERR               *p_err)
    514          {
   \                     OSTmrSet: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9F09             LDR      R7,[SP, #+36]
    515          #ifdef OS_SAFETY_CRITICAL
    516              if (p_err == (OS_ERR *)0) {
    517                  OS_SAFETY_CRITICAL_EXCEPTION();
    518                  return;
    519              }
    520          #endif
    521          
    522          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    523              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSTmrSet_0
    524                 *p_err = OS_ERR_TMR_ISR;
   \   00000018   0xF247 0x3043      MOVW     R0,#+29507
   \   0000001C   0x8038             STRH     R0,[R7, #+0]
    525                  return;
   \   0000001E   0xE03F             B.N      ??OSTmrSet_1
    526              }
    527          #endif
    528          
    529          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    530              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTmrSet_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ.N    ??OSTmrSet_2
    531                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002A   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002E   0x8038             STRH     R0,[R7, #+0]
    532                  return;
   \   00000030   0xE036             B.N      ??OSTmrSet_1
    533              }
    534          #endif
    535          
    536          #if (OS_CFG_ARG_CHK_EN > 0u)
    537              if (p_tmr == (OS_TMR *)0) {                                 /* Validate 'p_tmr'                                     */
   \                     ??OSTmrSet_2: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD103             BNE.N    ??OSTmrSet_3
    538                 *p_err = OS_ERR_TMR_INVALID;
   \   00000036   0xF247 0x3042      MOVW     R0,#+29506
   \   0000003A   0x8038             STRH     R0,[R7, #+0]
    539                  return;
   \   0000003C   0xE030             B.N      ??OSTmrSet_1
    540              }
    541          #endif
    542          
    543          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    544              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
   \                     ??OSTmrSet_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD003             BEQ.N    ??OSTmrSet_4
    545                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000048   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004C   0x8038             STRH     R0,[R7, #+0]
    546                  return;
   \   0000004E   0xE027             B.N      ??OSTmrSet_1
    547              }
    548          #endif
    549          
    550          #if (OS_CFG_ARG_CHK_EN > 0u)
    551              switch (p_tmr->Opt) {
   \                     ??OSTmrSet_4: (+1)
   \   00000050   0x8C20             LDRH     R0,[R4, #+32]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD026             BEQ.N    ??OSTmrSet_5
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD12B             BNE.N    ??OSTmrSet_6
    552                  case OS_OPT_TMR_PERIODIC:
    553                       if (period == 0u) {
   \                     ??OSTmrSet_7: (+1)
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD103             BNE.N    ??OSTmrSet_8
    554                          *p_err = OS_ERR_TMR_INVALID_PERIOD;
   \   0000005E   0xF247 0x3040      MOVW     R0,#+29504
   \   00000062   0x8038             STRH     R0,[R7, #+0]
    555                           return;
   \   00000064   0xE01C             B.N      ??OSTmrSet_1
    556                       }
    557          
    558                       if (p_callback == (OS_TMR_CALLBACK_PTR)0) {        /* No point in a periodic timer without a callback      */
   \                     ??OSTmrSet_8: (+1)
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD103             BNE.N    ??OSTmrSet_9
    559                          *p_err = OS_ERR_TMR_INVALID_CALLBACK;
   \   0000006C   0xF247 0x304A      MOVW     R0,#+29514
   \   00000070   0x8038             STRH     R0,[R7, #+0]
    560                           return;
   \   00000072   0xE015             B.N      ??OSTmrSet_1
    561                       }
    562                       break;
   \                     ??OSTmrSet_9: (+1)
   \                     ??OSTmrSet_10: (+1)
   \   00000074   0xF8DD 0x9020      LDR      R9,[SP, #+32]
    563          
    564                  case OS_OPT_TMR_ONE_SHOT:
    565                       if (dly == 0u) {
    566                          *p_err = OS_ERR_TMR_INVALID_DLY;
    567                           return;
    568                       }
    569                       break;
    570          
    571                  default:
    572                      *p_err = OS_ERR_TMR_INVALID;
    573                       return;
    574              }
    575          #endif
    576          
    577              OS_TmrLock();
   \   00000078   0x.... 0x....      BL       OS_TmrLock
    578          
    579              p_tmr->Dly            = dly    * OSTmrToTicksMult;             /* Convert Timer Delay  to ticks                     */
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x4346             MULS     R6,R0,R6
   \   00000084   0x61A6             STR      R6,[R4, #+24]
    580              p_tmr->Period         = period * OSTmrToTicksMult;             /* Convert Timer Period to ticks                     */
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x4345             MULS     R5,R0,R5
   \   0000008E   0x61E5             STR      R5,[R4, #+28]
    581              p_tmr->CallbackPtr    = p_callback;
   \   00000090   0xF8C4 0x8004      STR      R8,[R4, #+4]
    582              p_tmr->CallbackPtrArg = p_callback_arg;
   \   00000094   0xF8C4 0x9008      STR      R9,[R4, #+8]
    583          
    584             *p_err                 = OS_ERR_NONE;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x8038             STRH     R0,[R7, #+0]
    585          
    586              OS_TmrUnlock();
   \   0000009C   0x.... 0x....      BL       OS_TmrUnlock
    587          }
   \                     ??OSTmrSet_1: (+1)
   \   000000A0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??OSTmrSet_5: (+1)
   \   000000A4   0x2E00             CMP      R6,#+0
   \   000000A6   0xD103             BNE.N    ??OSTmrSet_11
   \   000000A8   0xF247 0x303F      MOVW     R0,#+29503
   \   000000AC   0x8038             STRH     R0,[R7, #+0]
   \   000000AE   0xE7F7             B.N      ??OSTmrSet_1
   \                     ??OSTmrSet_11: (+1)
   \   000000B0   0xE7E0             B.N      ??OSTmrSet_10
   \                     ??OSTmrSet_6: (+1)
   \   000000B2   0xF247 0x3042      MOVW     R0,#+29506
   \   000000B6   0x8038             STRH     R0,[R7, #+0]
   \   000000B8   0xE7F2             B.N      ??OSTmrSet_1
    588          
    589          
    590          /*
    591          ************************************************************************************************************************
    592          *                                                   START A TIMER
    593          *
    594          * Description: This function is called by your application code to start a timer.
    595          *
    596          * Arguments  : p_tmr    Is a pointer to an OS_TMR
    597          *
    598          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    599          *
    600          *                           OS_ERR_NONE                The timer was started
    601          *                           OS_ERR_OBJ_TYPE            If 'p_tmr' is not pointing to a timer
    602          *                           OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    603          *                           OS_ERR_TMR_INACTIVE        If the timer was not created
    604          *                           OS_ERR_TMR_INVALID         If 'p_tmr' is a NULL pointer
    605          *                           OS_ERR_TMR_INVALID_STATE   The timer is in an invalid state
    606          *                           OS_ERR_TMR_ISR             If the call was made from an ISR
    607          *
    608          * Returns    : OS_TRUE   is the timer was started
    609          *              OS_FALSE  if not or upon an error
    610          *
    611          * Note(s)    : 1) When starting/restarting a timer, regardless if it is in PERIODIC or ONE-SHOT mode, the timer is
    612          *                 linked to the timer list with the OS_OPT_LINK_DLY option. This option sets the initial expiration
    613          *                 time for the timer. For timers in PERIODIC mode, subsequent expiration times are handled by
    614          *                 the OS_TmrTask().
    615          ************************************************************************************************************************
    616          */
    617          

   \                                 In section .text, align 2, keep-with-next
    618          CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
    619                                   OS_ERR  *p_err)
    620          {
   \                     OSTmrStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    621              CPU_BOOLEAN  success;
    622              OS_TICK      time;
    623              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    624          
    625          
    626          #ifdef OS_SAFETY_CRITICAL
    627              if (p_err == (OS_ERR *)0) {
    628                  OS_SAFETY_CRITICAL_EXCEPTION();
    629                  return (OS_FALSE);
    630              }
    631          #endif
    632          
    633          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    634              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTmrStart_0
    635                 *p_err = OS_ERR_TMR_ISR;
   \   00000012   0xF247 0x3043      MOVW     R0,#+29507
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    636                  return (OS_FALSE);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE071             B.N      ??OSTmrStart_1
    637              }
    638          #endif
    639          
    640          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    641              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTmrStart_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSTmrStart_2
    642                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    643                  return (OS_FALSE);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE067             B.N      ??OSTmrStart_1
    644              }
    645          #endif
    646          
    647          #if (OS_CFG_ARG_CHK_EN > 0u)
    648              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrStart_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE.N    ??OSTmrStart_3
    649                 *p_err = OS_ERR_TMR_INVALID;
   \   00000034   0xF247 0x3042      MOVW     R0,#+29506
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    650                  return (OS_FALSE);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE060             B.N      ??OSTmrStart_1
    651              }
    652          #endif
    653          
    654          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    655              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
   \                     ??OSTmrStart_3: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD004             BEQ.N    ??OSTmrStart_4
    656                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000048   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
    657                  return (OS_FALSE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE056             B.N      ??OSTmrStart_1
    658              }
    659          #endif
    660          
    661              OS_TmrLock();
   \                     ??OSTmrStart_4: (+1)
   \   00000052   0x.... 0x....      BL       OS_TmrLock
    662          
    663              CPU_CRITICAL_ENTER();
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
    664              if (OSTCBCurPtr == &OSTmrTaskTCB) {                         /* Callbacks operate on the Tmr Task's tick base.       */
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x.... 0x....      LDR.W    R2,??DataTable16_5
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xD103             BNE.N    ??OSTmrStart_5
    665                  time = OSTmrTaskTickBase;
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   0000006E   0x680E             LDR      R6,[R1, #+0]
   \   00000070   0xE002             B.N      ??OSTmrStart_6
    666              } else {
    667          #if (OS_CFG_DYN_TICK_EN > 0u)
    668                  time = OSTickCtr + OS_DynTickGet();
    669          #else
    670                  time = OSTickCtr;
   \                     ??OSTmrStart_5: (+1)
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   00000076   0x680E             LDR      R6,[R1, #+0]
    671          #endif
    672              }
    673              CPU_CRITICAL_EXIT();
   \                     ??OSTmrStart_6: (+1)
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
    674          
    675          
    676              switch (p_tmr->State) {
   \   0000007C   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD030             BEQ.N    ??OSTmrStart_7
   \   00000084   0x2802             CMP      R0,#+2
   \   00000086   0xD004             BEQ.N    ??OSTmrStart_8
   \   00000088   0xD31A             BCC.N    ??OSTmrStart_9
   \   0000008A   0x2804             CMP      R0,#+4
   \   0000008C   0xD001             BEQ.N    ??OSTmrStart_8
   \   0000008E   0xD317             BCC.N    ??OSTmrStart_9
   \   00000090   0xE02E             B.N      ??OSTmrStart_10
    677                  case OS_TMR_STATE_RUNNING:                              /* Restart the timer                                    */
    678                  case OS_TMR_STATE_TIMEOUT:
    679                       p_tmr->State = OS_TMR_STATE_RUNNING;
   \                     ??OSTmrStart_8: (+1)
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0xF884 0x0022      STRB     R0,[R4, #+34]
    680                       OS_TmrUnlink(p_tmr, time);                         /* Remove from current position in List                 */
   \   00000098   0x0031             MOVS     R1,R6
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       OS_TmrUnlink
    681                       if (p_tmr->Dly == 0u) {
   \   000000A0   0x69A0             LDR      R0,[R4, #+24]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD102             BNE.N    ??OSTmrStart_11
    682                           p_tmr->Remain = p_tmr->Period;
   \   000000A6   0x69E0             LDR      R0,[R4, #+28]
   \   000000A8   0x6160             STR      R0,[R4, #+20]
   \   000000AA   0xE001             B.N      ??OSTmrStart_12
    683                       } else {
    684                           p_tmr->Remain = p_tmr->Dly;
   \                     ??OSTmrStart_11: (+1)
   \   000000AC   0x69A0             LDR      R0,[R4, #+24]
   \   000000AE   0x6160             STR      R0,[R4, #+20]
    685                       }
    686                       OS_TmrLink(p_tmr, time);                           /* Add timer to List                                    */
   \                     ??OSTmrStart_12: (+1)
   \   000000B0   0x0031             MOVS     R1,R6
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       OS_TmrLink
    687                      *p_err   = OS_ERR_NONE;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x8028             STRH     R0,[R5, #+0]
    688                       success = OS_TRUE;
   \   000000BC   0x2401             MOVS     R4,#+1
    689                       break;
   \   000000BE   0xE01B             B.N      ??OSTmrStart_13
    690          
    691                  case OS_TMR_STATE_STOPPED:                              /* Start the timer                                      */
    692                  case OS_TMR_STATE_COMPLETED:
    693                       p_tmr->State = OS_TMR_STATE_RUNNING;
   \                     ??OSTmrStart_9: (+1)
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0xF884 0x0022      STRB     R0,[R4, #+34]
    694                       if (p_tmr->Dly == 0u) {
   \   000000C6   0x69A0             LDR      R0,[R4, #+24]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD102             BNE.N    ??OSTmrStart_14
    695                           p_tmr->Remain = p_tmr->Period;
   \   000000CC   0x69E0             LDR      R0,[R4, #+28]
   \   000000CE   0x6160             STR      R0,[R4, #+20]
   \   000000D0   0xE001             B.N      ??OSTmrStart_15
    696                       } else {
    697                           p_tmr->Remain = p_tmr->Dly;
   \                     ??OSTmrStart_14: (+1)
   \   000000D2   0x69A0             LDR      R0,[R4, #+24]
   \   000000D4   0x6160             STR      R0,[R4, #+20]
    698                       }
    699                       OS_TmrLink(p_tmr, time);                           /* Add timer to List                                    */
   \                     ??OSTmrStart_15: (+1)
   \   000000D6   0x0031             MOVS     R1,R6
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       OS_TmrLink
    700                      *p_err   = OS_ERR_NONE;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x8028             STRH     R0,[R5, #+0]
    701                       success = OS_TRUE;
   \   000000E2   0x2401             MOVS     R4,#+1
    702                       break;
   \   000000E4   0xE008             B.N      ??OSTmrStart_13
    703          
    704                  case OS_TMR_STATE_UNUSED:                               /* Timer not created                                    */
    705                      *p_err   = OS_ERR_TMR_INACTIVE;
   \                     ??OSTmrStart_7: (+1)
   \   000000E6   0xF247 0x303D      MOVW     R0,#+29501
   \   000000EA   0x8028             STRH     R0,[R5, #+0]
    706                       success = OS_FALSE;
   \   000000EC   0x2400             MOVS     R4,#+0
    707                       break;
   \   000000EE   0xE003             B.N      ??OSTmrStart_13
    708          
    709                  default:
    710                      *p_err   = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrStart_10: (+1)
   \   000000F0   0xF247 0x3041      MOVW     R0,#+29505
   \   000000F4   0x8028             STRH     R0,[R5, #+0]
    711                       success = OS_FALSE;
   \   000000F6   0x2400             MOVS     R4,#+0
    712                       break;
    713              }
    714          
    715              OS_TmrUnlock();
   \                     ??OSTmrStart_13: (+1)
   \   000000F8   0x.... 0x....      BL       OS_TmrUnlock
    716          
    717              return (success);
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStart_1: (+1)
   \   00000100   0xBD70             POP      {R4-R6,PC}       ;; return
    718          }
    719          
    720          
    721          /*
    722          ************************************************************************************************************************
    723          *                                           FIND OUT WHAT STATE A TIMER IS IN
    724          *
    725          * Description: This function is called to determine what state the timer is in:
    726          *
    727          *                  OS_TMR_STATE_UNUSED     the timer has not been created
    728          *                  OS_TMR_STATE_STOPPED    the timer has been created but has not been started or has been stopped
    729          *                  OS_TMR_STATE_COMPLETED  the timer is in ONE-SHOT mode and has completed it's timeout
    730          *                  OS_TMR_SATE_RUNNING     the timer is currently running
    731          *
    732          * Arguments  : p_tmr    Is a pointer to the desired timer
    733          *
    734          *              p_err    Is a pointer to an error code.  '*p_err' will contain one of the following:
    735          *
    736          *                           OS_ERR_NONE               The return value reflects the state of the timer
    737          *                           OS_ERR_OBJ_TYPE           If 'p_tmr' is not pointing to a timer
    738          *                           OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    739          *                           OS_ERR_TMR_INVALID        If 'p_tmr' is a NULL pointer
    740          *                           OS_ERR_TMR_INVALID_STATE  If the timer is not in a valid state
    741          *                           OS_ERR_TMR_ISR            If the call was made from an ISR
    742          *
    743          * Returns    : The current state of the timer (see description).
    744          *
    745          * Note(s)    : none
    746          ************************************************************************************************************************
    747          */
    748          

   \                                 In section .text, align 2, keep-with-next
    749          OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
    750                                   OS_ERR  *p_err)
    751          {
   \                     OSTmrStateGet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    752              OS_STATE  state;
    753          
    754          
    755          
    756          #ifdef OS_SAFETY_CRITICAL
    757              if (p_err == (OS_ERR *)0) {
    758                  OS_SAFETY_CRITICAL_EXCEPTION();
    759                  return (OS_TMR_STATE_UNUSED);
    760              }
    761          #endif
    762          
    763          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    764              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD004             BEQ.N    ??OSTmrStateGet_0
    765                 *p_err = OS_ERR_TMR_ISR;
   \   00000010   0xF247 0x3043      MOVW     R0,#+29507
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    766                  return (OS_TMR_STATE_UNUSED);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE02D             B.N      ??OSTmrStateGet_1
    767              }
    768          #endif
    769          
    770          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    771              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTmrStateGet_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD004             BEQ.N    ??OSTmrStateGet_2
    772                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000024   0xF645 0x6089      MOVW     R0,#+24201
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    773                  return (OS_TMR_STATE_UNUSED);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE023             B.N      ??OSTmrStateGet_1
    774              }
    775          #endif
    776          
    777          #if (OS_CFG_ARG_CHK_EN > 0u)
    778              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrStateGet_2: (+1)
   \   0000002E   0x2C00             CMP      R4,#+0
   \   00000030   0xD104             BNE.N    ??OSTmrStateGet_3
    779                 *p_err = OS_ERR_TMR_INVALID;
   \   00000032   0xF247 0x3042      MOVW     R0,#+29506
   \   00000036   0x8028             STRH     R0,[R5, #+0]
    780                  return (OS_TMR_STATE_UNUSED);
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE01C             B.N      ??OSTmrStateGet_1
    781              }
    782          #endif
    783          
    784          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    785              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
   \                     ??OSTmrStateGet_3: (+1)
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD004             BEQ.N    ??OSTmrStateGet_4
    786                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000046   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000004A   0x8028             STRH     R0,[R5, #+0]
    787                  return (OS_TMR_STATE_UNUSED);
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE012             B.N      ??OSTmrStateGet_1
    788              }
    789          #endif
    790          
    791              OS_TmrLock();
   \                     ??OSTmrStateGet_4: (+1)
   \   00000050   0x.... 0x....      BL       OS_TmrLock
    792          
    793              state = p_tmr->State;
   \   00000054   0xF894 0x4022      LDRB     R4,[R4, #+34]
    794              switch (state) {
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0x2804             CMP      R0,#+4
   \   00000060   0xD802             BHI.N    ??OSTmrStateGet_5
    795                  case OS_TMR_STATE_UNUSED:
    796                  case OS_TMR_STATE_STOPPED:
    797                  case OS_TMR_STATE_COMPLETED:
    798                  case OS_TMR_STATE_RUNNING:
    799                  case OS_TMR_STATE_TIMEOUT:
    800                      *p_err = OS_ERR_NONE;
   \                     ??OSTmrStateGet_6: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x8028             STRH     R0,[R5, #+0]
    801                       break;
   \   00000066   0xE002             B.N      ??OSTmrStateGet_7
    802          
    803                  default:
    804                      *p_err = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrStateGet_5: (+1)
   \   00000068   0xF247 0x3041      MOVW     R0,#+29505
   \   0000006C   0x8028             STRH     R0,[R5, #+0]
    805                       break;
    806              }
    807          
    808              OS_TmrUnlock();
   \                     ??OSTmrStateGet_7: (+1)
   \   0000006E   0x.... 0x....      BL       OS_TmrUnlock
    809          
    810              return (state);
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStateGet_1: (+1)
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    811          }
    812          
    813          
    814          /*
    815          ************************************************************************************************************************
    816          *                                                    STOP A TIMER
    817          *
    818          * Description: This function is called by your application code to stop a timer.
    819          *
    820          * Arguments  : p_tmr          Is a pointer to the timer to stop.
    821          *
    822          *              opt            Allows you to specify an option to this functions which can be:
    823          *
    824          *                               OS_OPT_TMR_NONE            Do nothing special but stop the timer
    825          *                               OS_OPT_TMR_CALLBACK        Execute the callback function, pass it the callback argument
    826          *                                                          specified when the timer was created.
    827          *                               OS_OPT_TMR_CALLBACK_ARG    Execute the callback function, pass it the callback argument
    828          *                                                          specified in THIS function call
    829          *
    830          *              callback_arg   Is a pointer to a 'new' callback argument that can be passed to the callback function
    831          *                               instead of the timer's callback argument.  In other words, use 'callback_arg' passed in
    832          *                               THIS function INSTEAD of p_tmr->OSTmrCallbackArg
    833          *
    834          *              p_err          Is a pointer to an error code.  '*p_err' will contain one of the following:
    835          *
    836          *                               OS_ERR_NONE                The timer has stopped
    837          *                               OS_ERR_OBJ_TYPE            If 'p_tmr' is not pointing to a timer
    838          *                               OS_ERR_OPT_INVALID         If you specified an invalid option for 'opt'
    839          *                               OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    840          *                               OS_ERR_TMR_INACTIVE        If the timer was not created
    841          *                               OS_ERR_TMR_INVALID         If 'p_tmr' is a NULL pointer
    842          *                               OS_ERR_TMR_INVALID_STATE   The timer is in an invalid state
    843          *                               OS_ERR_TMR_ISR             If the function was called from an ISR
    844          *                               OS_ERR_TMR_NO_CALLBACK     If the timer does not have a callback function defined
    845          *                               OS_ERR_TMR_STOPPED         If the timer was already stopped
    846          *
    847          * Returns    : OS_TRUE   If we stopped the timer (if the timer is already stopped, we also return OS_TRUE)
    848          *              OS_FALSE  If not
    849          *
    850          * Note(s)    : none
    851          ************************************************************************************************************************
    852          */
    853          

   \                                 In section .text, align 2, keep-with-next
    854          CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
    855                                  OS_OPT   opt,
    856                                  void    *p_callback_arg,
    857                                  OS_ERR  *p_err)
    858          {
   \                     OSTmrStop: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001D             MOVS     R5,R3
    859              OS_TMR_CALLBACK_PTR  p_fnct;
    860              CPU_BOOLEAN          success;
    861              OS_TICK              time;
    862              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
    863          
    864          
    865          #ifdef OS_SAFETY_CRITICAL
    866              if (p_err == (OS_ERR *)0) {
    867                  OS_SAFETY_CRITICAL_EXCEPTION();
    868                  return (OS_FALSE);
    869              }
    870          #endif
    871          
    872          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    873              if (OSIntNestingCtr > 0u) {                                 /* See if trying to call from an ISR                    */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD004             BEQ.N    ??OSTmrStop_0
    874                 *p_err = OS_ERR_TMR_ISR;
   \   00000018   0xF247 0x3043      MOVW     R0,#+29507
   \   0000001C   0x8028             STRH     R0,[R5, #+0]
    875                  return (OS_FALSE);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE08B             B.N      ??OSTmrStop_1
    876              }
    877          #endif
    878          
    879          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    880              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTmrStop_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD004             BEQ.N    ??OSTmrStop_2
    881                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002C   0xF645 0x6089      MOVW     R0,#+24201
   \   00000030   0x8028             STRH     R0,[R5, #+0]
    882                  return (OS_FALSE);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE081             B.N      ??OSTmrStop_1
    883              }
    884          #endif
    885          
    886          #if (OS_CFG_ARG_CHK_EN > 0u)
    887              if (p_tmr == (OS_TMR *)0) {
   \                     ??OSTmrStop_2: (+1)
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD104             BNE.N    ??OSTmrStop_3
    888                 *p_err = OS_ERR_TMR_INVALID;
   \   0000003A   0xF247 0x3042      MOVW     R0,#+29506
   \   0000003E   0x8028             STRH     R0,[R5, #+0]
    889                  return (OS_FALSE);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE07A             B.N      ??OSTmrStop_1
    890              }
    891          #endif
    892          
    893          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    894              if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                       /* Make sure timer was created                          */
   \                     ??OSTmrStop_3: (+1)
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable16_2  ;; 0x20524d54
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD004             BEQ.N    ??OSTmrStop_4
    895                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000004E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000052   0x8028             STRH     R0,[R5, #+0]
    896                  return (OS_FALSE);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE070             B.N      ??OSTmrStop_1
    897              }
    898          #endif
    899          
    900              OS_TmrLock();
   \                     ??OSTmrStop_4: (+1)
   \   00000058   0x.... 0x....      BL       OS_TmrLock
    901          
    902              CPU_CRITICAL_ENTER();
   \   0000005C   0x2040             MOVS     R0,#+64
   \   0000005E   0x.... 0x....      BL       CPU_SR_Save
    903              if (OSTCBCurPtr == &OSTmrTaskTCB) {                         /* Callbacks operate on the Tmr Task's tick base.       */
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x.... 0x....      LDR.W    R2,??DataTable16_5
   \   0000006C   0x4291             CMP      R1,R2
   \   0000006E   0xD104             BNE.N    ??OSTmrStop_5
    904                  time = OSTmrTaskTickBase;
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000074   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   \   00000078   0xE003             B.N      ??OSTmrStop_6
    905              } else {
    906          #if (OS_CFG_DYN_TICK_EN > 0u)
    907                  time = OSTickCtr + OS_DynTickGet();
    908          #else
    909                  time = OSTickCtr;
   \                     ??OSTmrStop_5: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable16_7
   \   0000007E   0xF8D1 0x8000      LDR      R8,[R1, #+0]
    910          #endif
    911              }
    912              CPU_CRITICAL_EXIT();
   \                     ??OSTmrStop_6: (+1)
   \   00000082   0x.... 0x....      BL       CPU_SR_Restore
    913          
    914              switch (p_tmr->State) {
   \   00000086   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD048             BEQ.N    ??OSTmrStop_7
   \   0000008E   0x2802             CMP      R0,#+2
   \   00000090   0xD004             BEQ.N    ??OSTmrStop_8
   \   00000092   0xD33D             BCC.N    ??OSTmrStop_9
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD001             BEQ.N    ??OSTmrStop_8
   \   00000098   0xD33A             BCC.N    ??OSTmrStop_9
   \   0000009A   0xE046             B.N      ??OSTmrStop_10
    915                  case OS_TMR_STATE_RUNNING:
    916                  case OS_TMR_STATE_TIMEOUT:
    917                       p_tmr->State = OS_TMR_STATE_STOPPED;               /* Ensure that any callbacks see the stop state         */
   \                     ??OSTmrStop_8: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xF884 0x0022      STRB     R0,[R4, #+34]
    918                       switch (opt) {
   \   000000A2   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A4   0x2F00             CMP      R7,#+0
   \   000000A6   0xD027             BEQ.N    ??OSTmrStop_11
   \   000000A8   0x2F03             CMP      R7,#+3
   \   000000AA   0xD002             BEQ.N    ??OSTmrStop_12
   \   000000AC   0x2F04             CMP      R7,#+4
   \   000000AE   0xD013             BEQ.N    ??OSTmrStop_13
   \   000000B0   0xE027             B.N      ??OSTmrStop_14
    919                           case OS_OPT_TMR_CALLBACK:
    920                                OS_TmrUnlink(p_tmr, time);                /* Remove from timer list                               */
   \                     ??OSTmrStop_12: (+1)
   \   000000B2   0x4641             MOV      R1,R8
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       OS_TmrUnlink
    921                                p_fnct = p_tmr->CallbackPtr;              /* Execute callback function ...                        */
   \   000000BA   0x6862             LDR      R2,[R4, #+4]
    922                                if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {   /* ... if available                                     */
   \   000000BC   0x0010             MOVS     R0,R2
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD003             BEQ.N    ??OSTmrStop_15
    923                                  (*p_fnct)(p_tmr, p_tmr->CallbackPtrArg);/* Use callback arg when timer was created              */
   \   000000C2   0x68A1             LDR      R1,[R4, #+8]
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x4790             BLX      R2
   \   000000C8   0xE002             B.N      ??OSTmrStop_16
    924                                } else {
    925                                   *p_err = OS_ERR_TMR_NO_CALLBACK;
   \                     ??OSTmrStop_15: (+1)
   \   000000CA   0xF247 0x3044      MOVW     R0,#+29508
   \   000000CE   0x8028             STRH     R0,[R5, #+0]
    926                                }
    927                                break;
    928          
    929                           case OS_OPT_TMR_CALLBACK_ARG:
    930                                OS_TmrUnlink(p_tmr, time);                /* Remove from timer list                               */
    931                                p_fnct = p_tmr->CallbackPtr;              /* Execute callback function if available ...           */
    932                                if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
    933                                  (*p_fnct)(p_tmr, p_callback_arg);       /* .. using the 'callback_arg' provided in call         */
    934                                } else {
    935                                   *p_err = OS_ERR_TMR_NO_CALLBACK;
    936                                }
    937                                break;
    938          
    939                           case OS_OPT_TMR_NONE:
    940                                OS_TmrUnlink(p_tmr, time);                /* Remove from timer list                               */
    941                                break;
    942          
    943                           default:
    944                                OS_TmrUnlock();
    945                               *p_err = OS_ERR_OPT_INVALID;
    946                                return (OS_FALSE);
    947                       }
    948                      *p_err        = OS_ERR_NONE;
   \                     ??OSTmrStop_16: (+1)
   \                     ??OSTmrStop_17: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x8028             STRH     R0,[R5, #+0]
    949                       success      = OS_TRUE;
   \   000000D4   0x2401             MOVS     R4,#+1
    950                       break;
   \   000000D6   0xE02C             B.N      ??OSTmrStop_18
   \                     ??OSTmrStop_13: (+1)
   \   000000D8   0x4641             MOV      R1,R8
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       OS_TmrUnlink
   \   000000E0   0x6862             LDR      R2,[R4, #+4]
   \   000000E2   0x0010             MOVS     R0,R2
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD003             BEQ.N    ??OSTmrStop_19
   \   000000E8   0x0031             MOVS     R1,R6
   \   000000EA   0x0020             MOVS     R0,R4
   \   000000EC   0x4790             BLX      R2
   \   000000EE   0xE002             B.N      ??OSTmrStop_20
   \                     ??OSTmrStop_19: (+1)
   \   000000F0   0xF247 0x3044      MOVW     R0,#+29508
   \   000000F4   0x8028             STRH     R0,[R5, #+0]
   \                     ??OSTmrStop_20: (+1)
   \   000000F6   0xE7EB             B.N      ??OSTmrStop_17
   \                     ??OSTmrStop_11: (+1)
   \   000000F8   0x4641             MOV      R1,R8
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       OS_TmrUnlink
   \   00000100   0xE7E6             B.N      ??OSTmrStop_17
   \                     ??OSTmrStop_14: (+1)
   \   00000102   0x.... 0x....      BL       OS_TmrUnlock
   \   00000106   0xF645 0x6025      MOVW     R0,#+24101
   \   0000010A   0x8028             STRH     R0,[R5, #+0]
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0xE014             B.N      ??OSTmrStop_1
    951          
    952                  case OS_TMR_STATE_COMPLETED:                            /* Timer has already completed the ONE-SHOT or          */
    953                  case OS_TMR_STATE_STOPPED:                              /* ... timer has not started yet.                       */
    954                       p_tmr->State = OS_TMR_STATE_STOPPED;
   \                     ??OSTmrStop_9: (+1)
   \   00000110   0x2001             MOVS     R0,#+1
   \   00000112   0xF884 0x0022      STRB     R0,[R4, #+34]
    955                      *p_err        = OS_ERR_TMR_STOPPED;
   \   00000116   0xF247 0x3049      MOVW     R0,#+29513
   \   0000011A   0x8028             STRH     R0,[R5, #+0]
    956                       success      = OS_TRUE;
   \   0000011C   0x2401             MOVS     R4,#+1
    957                       break;
   \   0000011E   0xE008             B.N      ??OSTmrStop_18
    958          
    959                  case OS_TMR_STATE_UNUSED:                               /* Timer was not created                                */
    960                      *p_err        = OS_ERR_TMR_INACTIVE;
   \                     ??OSTmrStop_7: (+1)
   \   00000120   0xF247 0x303D      MOVW     R0,#+29501
   \   00000124   0x8028             STRH     R0,[R5, #+0]
    961                       success      = OS_FALSE;
   \   00000126   0x2400             MOVS     R4,#+0
    962                       break;
   \   00000128   0xE003             B.N      ??OSTmrStop_18
    963          
    964                  default:
    965                      *p_err        = OS_ERR_TMR_INVALID_STATE;
   \                     ??OSTmrStop_10: (+1)
   \   0000012A   0xF247 0x3041      MOVW     R0,#+29505
   \   0000012E   0x8028             STRH     R0,[R5, #+0]
    966                       success      = OS_FALSE;
   \   00000130   0x2400             MOVS     R4,#+0
    967                       break;
    968              }
    969          
    970              OS_TmrUnlock();
   \                     ??OSTmrStop_18: (+1)
   \   00000132   0x.... 0x....      BL       OS_TmrUnlock
    971          
    972              return (success);
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTmrStop_1: (+1)
   \   0000013A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    973          }
    974          
    975          
    976          /*
    977          ************************************************************************************************************************
    978          *                                                 CLEAR TIMER FIELDS
    979          *
    980          * Description: This function is called to clear all timer fields.
    981          *
    982          * Argument(s): p_tmr    Is a pointer to the timer to clear
    983          *              -----
    984          *
    985          * Returns    : none
    986          *
    987          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    988          ************************************************************************************************************************
    989          */
    990          

   \                                 In section .text, align 2, keep-with-next
    991          void  OS_TmrClr (OS_TMR  *p_tmr)
    992          {
    993              p_tmr->State          = OS_TMR_STATE_UNUSED;                /* Clear timer fields                                   */
   \                     OS_TmrClr: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x1022      STRB     R1,[R0, #+34]
    994          #if (OS_OBJ_TYPE_REQ > 0u)
    995              p_tmr->Type           = OS_OBJ_TYPE_NONE;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_9  ;; 0x454e4f4e
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    996          #endif
    997          #if (OS_CFG_DBG_EN > 0u)
    998              p_tmr->NamePtr        = (CPU_CHAR *)((void *)"?TMR");
    999          #endif
   1000              p_tmr->Dly            =                      0u;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6181             STR      R1,[R0, #+24]
   1001              p_tmr->Remain         =                      0u;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6141             STR      R1,[R0, #+20]
   1002              p_tmr->Period         =                      0u;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x61C1             STR      R1,[R0, #+28]
   1003              p_tmr->Opt            =                      0u;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8401             STRH     R1,[R0, #+32]
   1004              p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x6041             STR      R1,[R0, #+4]
   1005              p_tmr->CallbackPtrArg = (void              *)0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x6081             STR      R1,[R0, #+8]
   1006              p_tmr->NextPtr        = (OS_TMR            *)0;
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x60C1             STR      R1,[R0, #+12]
   1007              p_tmr->PrevPtr        = (OS_TMR            *)0;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6101             STR      R1,[R0, #+16]
   1008          }
   \   0000002C   0x4770             BX       LR               ;; return
   1009          
   1010          
   1011          /*
   1012          ************************************************************************************************************************
   1013          *                                         ADD/REMOVE TIMER TO/FROM DEBUG TABLE
   1014          *
   1015          * Description: These functions are called by uC/OS-III to add or remove a timer to/from a timer debug table.
   1016          *
   1017          * Arguments  : p_tmr     is a pointer to the timer to add/remove
   1018          *
   1019          * Returns    : none
   1020          *
   1021          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1022          ************************************************************************************************************************
   1023          */
   1024          
   1025          
   1026          #if (OS_CFG_DBG_EN > 0u)
   1027          void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
   1028          {
   1029              p_tmr->DbgPrevPtr               = (OS_TMR *)0;
   1030              if (OSTmrDbgListPtr == (OS_TMR *)0) {
   1031                  p_tmr->DbgNextPtr           = (OS_TMR *)0;
   1032              } else {
   1033                  p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
   1034                  OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
   1035              }
   1036              OSTmrDbgListPtr                 =  p_tmr;
   1037          }
   1038          
   1039          
   1040          
   1041          void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
   1042          {
   1043              OS_TMR  *p_tmr_next;
   1044              OS_TMR  *p_tmr_prev;
   1045          
   1046          
   1047              p_tmr_prev = p_tmr->DbgPrevPtr;
   1048              p_tmr_next = p_tmr->DbgNextPtr;
   1049          
   1050              if (p_tmr_prev == (OS_TMR *)0) {
   1051                  OSTmrDbgListPtr = p_tmr_next;
   1052                  if (p_tmr_next != (OS_TMR *)0) {
   1053                      p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
   1054                  }
   1055                  p_tmr->DbgNextPtr = (OS_TMR *)0;
   1056          
   1057              } else if (p_tmr_next == (OS_TMR *)0) {
   1058                  p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
   1059                  p_tmr->DbgPrevPtr      = (OS_TMR *)0;
   1060          
   1061              } else {
   1062                  p_tmr_prev->DbgNextPtr =  p_tmr_next;
   1063                  p_tmr_next->DbgPrevPtr =  p_tmr_prev;
   1064                  p_tmr->DbgNextPtr      = (OS_TMR *)0;
   1065                  p_tmr->DbgPrevPtr      = (OS_TMR *)0;
   1066              }
   1067          }
   1068          #endif
   1069          
   1070          
   1071          /*
   1072          ************************************************************************************************************************
   1073          *                                             INITIALIZE THE TIMER MANAGER
   1074          *
   1075          * Description: This function is called by OSInit() to initialize the timer manager module.
   1076          *
   1077          * Argument(s): p_err    is a pointer to a variable that will contain an error code returned by this function.
   1078          *
   1079          *                           OS_ERR_NONE
   1080          *                           OS_ERR_TMR_STK_INVALID       if you didn't specify a stack for the timer task
   1081          *                           OS_ERR_TMR_STK_SIZE_INVALID  if you didn't allocate enough space for the timer stack
   1082          *                           OS_ERR_PRIO_INVALID          if you specified the same priority as the idle task
   1083          *                           OS_ERR_xxx                   any error code returned by OSTaskCreate()
   1084          *
   1085          * Returns    : none
   1086          *
   1087          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1088          ************************************************************************************************************************
   1089          */
   1090          

   \                                 In section .text, align 2, keep-with-next
   1091          void  OS_TmrInit (OS_ERR  *p_err)
   1092          {
   \                     OS_TmrInit: (+1)
   \   00000000   0xB518             PUSH     {R3,R4,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   \   00000004   0x0004             MOVS     R4,R0
   1093          #if (OS_CFG_DBG_EN > 0u)
   1094              OSTmrQty             =           0u;                        /* Keep track of the number of timers created           */
   1095              OSTmrDbgListPtr      = (OS_TMR *)0;
   1096          #endif
   1097          
   1098              OSTmrListPtr         = (OS_TMR *)0;                         /* Create an empty timer list                           */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1099          #if (OS_CFG_DBG_EN > 0u)
   1100              OSTmrListEntries     =           0u;
   1101          #endif
   1102                                                                          /* Calculate Timer to Ticks multiplier                  */
   1103              OSTmrToTicksMult = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1104          
   1105          #if (OS_CFG_TS_EN > 0u)
   1106              OSTmrTaskTime        =           0u;
   1107              OSTmrTaskTimeMax     =           0u;
   1108          #endif
   1109          
   1110              OSMutexCreate(&OSTmrMutex,                                  /* Use a mutex to protect the timers                    */
   1111          #if  (OS_CFG_DBG_EN == 0u)
   1112                            (CPU_CHAR *)0,
   1113          #else
   1114                            (CPU_CHAR *)"OS Tmr Mutex",
   1115          #endif
   1116                            p_err);
   \   00000024   0x0022             MOVS     R2,R4
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   0000002C   0x.... 0x....      BL       OSMutexCreate
   1117              if (*p_err != OS_ERR_NONE) {
   \   00000030   0x8820             LDRH     R0,[R4, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD140             BNE.N    ??OS_TmrInit_0
   1118                  return;
   1119              }
   1120          
   1121              OS_TmrCondCreate();
   \                     ??OS_TmrInit_1: (+1)
   \   00000036   0x.... 0x....      BL       OS_TmrCondCreate
   1122                                                                          /* -------------- CREATE THE TIMER TASK --------------- */
   1123              if (OSCfg_TmrTaskStkBasePtr == (CPU_STK *)0) {
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD103             BNE.N    ??OS_TmrInit_2
   1124                 *p_err = OS_ERR_TMR_STK_INVALID;
   \   00000044   0xF247 0x3047      MOVW     R0,#+29511
   \   00000048   0x8020             STRH     R0,[R4, #+0]
   1125                  return;
   \   0000004A   0xE035             B.N      ??OS_TmrInit_0
   1126              }
   1127          
   1128              if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
   \                     ??OS_TmrInit_2: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable16_15
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD203             BCS.N    ??OS_TmrInit_3
   1129                 *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
   \   0000005C   0xF247 0x3048      MOVW     R0,#+29512
   \   00000060   0x8020             STRH     R0,[R4, #+0]
   1130                  return;
   \   00000062   0xE029             B.N      ??OS_TmrInit_0
   1131              }
   1132          
   1133              if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OS_TmrInit_3: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_16
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x283F             CMP      R0,#+63
   \   0000006C   0xD303             BCC.N    ??OS_TmrInit_4
   1134                 *p_err = OS_ERR_TMR_PRIO_INVALID;
   \   0000006E   0xF247 0x3046      MOVW     R0,#+29510
   \   00000072   0x8020             STRH     R0,[R4, #+0]
   1135                  return;
   \   00000074   0xE020             B.N      ??OS_TmrInit_0
   1136              }
   1137          
   1138              OSTaskCreate(&OSTmrTaskTCB,
   1139          #if  (OS_CFG_DBG_EN == 0u)
   1140                           (CPU_CHAR *)0,
   1141          #else
   1142                           (CPU_CHAR *)"uC/OS-III Timer Task",
   1143          #endif
   1144                            OS_TmrTask,
   1145                           (void     *)0,
   1146                            OSCfg_TmrTaskPrio,
   1147                            OSCfg_TmrTaskStkBasePtr,
   1148                            OSCfg_TmrTaskStkLimit,
   1149                            OSCfg_TmrTaskStkSize,
   1150                            0u,
   1151                            0u,
   1152                           (void     *)0,
   1153                           (OS_OPT_TASK_STK_CHK | (OS_OPT)(OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS)),
   1154                            p_err);
   \                     ??OS_TmrInit_4: (+1)
   \   00000076   0x9408             STR      R4,[SP, #+32]
   \   00000078   0x200B             MOVS     R0,#+11
   \   0000007A   0x9007             STR      R0,[SP, #+28]
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x9006             STR      R0,[SP, #+24]
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x9005             STR      R0,[SP, #+20]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9004             STR      R0,[SP, #+16]
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable16_14
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x9003             STR      R0,[SP, #+12]
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable16_17
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0x9002             STR      R0,[SP, #+8]
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x9001             STR      R0,[SP, #+4]
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable16_16
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0x2300             MOVS     R3,#+0
   \   000000AA   0x.... 0x....      ADR.W    R2,OS_TmrTask
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000000B4   0x.... 0x....      BL       OSTaskCreate
   1155          }
   \                     ??OS_TmrInit_0: (+1)
   \   000000B8   0xB00A             ADD      SP,SP,#+40
   \   000000BA   0xBD10             POP      {R4,PC}          ;; return
   1156          
   1157          
   1158          /*
   1159          ************************************************************************************************************************
   1160          *                                         ADD A TIMER TO THE TIMER LIST
   1161          *
   1162          * Description: This function is called to add a timer to the timer list.
   1163          *
   1164          * Arguments  : p_tmr          Is a pointer to the timer to add.
   1165          *
   1166          *              time           Is the system time when this timer was linked.
   1167          *              -----
   1168          *
   1169          * Returns    : none
   1170          *
   1171          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1172          ************************************************************************************************************************
   1173          */
   1174          

   \                                 In section .text, align 2, keep-with-next
   1175          void OS_TmrLink (OS_TMR   *p_tmr,
   1176                           OS_TICK   time)
   1177          {
   \                     OS_TmrLink: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0002             MOVS     R2,R0
   1178              OS_TMR   *p_tmr1;
   1179              OS_TMR   *p_tmr2;
   1180              OS_TICK   remain;
   1181              OS_TICK   delta;
   1182          
   1183          
   1184              if (OSTmrListPtr == (OS_TMR *)0) {                          /* Is the list empty?                                   */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD10C             BNE.N    ??OS_TmrLink_0
   1185                  p_tmr->NextPtr    = (OS_TMR *)0;                        /* Yes, this is the first entry                         */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x60D0             STR      R0,[R2, #+12]
   1186                  p_tmr->PrevPtr    = (OS_TMR *)0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6110             STR      R0,[R2, #+16]
   1187                  OSTmrListPtr      = p_tmr;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000001A   0x6002             STR      R2,[R0, #+0]
   1188          #if (OS_CFG_DBG_EN > 0u)
   1189                  OSTmrListEntries  = 1u;
   1190          #endif
   1191                  OSTmrTaskTickBase = time;
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000020   0x6001             STR      R1,[R0, #+0]
   1192                  OS_TmrCondSignal();
   \   00000022   0x.... 0x....      BL       OS_TmrCondSignal
   1193          
   1194                  return;
   \   00000026   0xE03A             B.N      ??OS_TmrLink_1
   1195              }
   1196          
   1197          #if (OS_CFG_DBG_EN > 0u)
   1198              OSTmrListEntries++;
   1199          #endif
   1200          
   1201              delta = (time + p_tmr->Remain) - OSTmrTaskTickBase;
   \                     ??OS_TmrLink_0: (+1)
   \   00000028   0x6950             LDR      R0,[R2, #+20]
   \   0000002A   0x1840             ADDS     R0,R0,R1
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable16_6
   \   00000030   0x681D             LDR      R5,[R3, #+0]
   \   00000032   0x1B45             SUBS     R5,R0,R5
   1202          
   1203              p_tmr2 = OSTmrListPtr;                                      /* No,  Insert somewhere in the list in delta order     */
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000038   0x6803             LDR      R3,[R0, #+0]
   1204              remain = p_tmr2->Remain;
   \   0000003A   0x695C             LDR      R4,[R3, #+20]
   1205          
   1206              if ((delta           <     remain) &&
   1207                  (p_tmr2->PrevPtr == (OS_TMR *)0)) {                     /* Are we the new head of the list?                     */
   \   0000003C   0x42A5             CMP      R5,R4
   \   0000003E   0xD211             BCS.N    ??OS_TmrLink_2
   \   00000040   0x6918             LDR      R0,[R3, #+16]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD10E             BNE.N    ??OS_TmrLink_2
   1208                  p_tmr2->Remain    =  remain - delta;
   \   00000046   0x1B64             SUBS     R4,R4,R5
   \   00000048   0x615C             STR      R4,[R3, #+20]
   1209                  p_tmr->PrevPtr    = (OS_TMR *)0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6110             STR      R0,[R2, #+16]
   1210                  p_tmr->NextPtr    =  p_tmr2;
   \   0000004E   0x60D3             STR      R3,[R2, #+12]
   1211                  p_tmr2->PrevPtr   =  p_tmr;
   \   00000050   0x611A             STR      R2,[R3, #+16]
   1212                  OSTmrListPtr      =  p_tmr;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000056   0x6002             STR      R2,[R0, #+0]
   1213          
   1214                  OSTmrTaskTickBase = time;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000005C   0x6001             STR      R1,[R0, #+0]
   1215                  OS_TmrCondSignal();
   \   0000005E   0x.... 0x....      BL       OS_TmrCondSignal
   1216          
   1217                  return;
   \   00000062   0xE01C             B.N      ??OS_TmrLink_1
   1218              }
   1219          
   1220                                                                          /* No                                                   */
   1221              delta  -= remain;                                           /* Make delta relative to the current head.             */
   \                     ??OS_TmrLink_2: (+1)
   \   00000064   0x1B2C             SUBS     R4,R5,R4
   1222              p_tmr1  = p_tmr2;
   1223              p_tmr2  = p_tmr1->NextPtr;
   \   00000066   0x68D8             LDR      R0,[R3, #+12]
   \   00000068   0xE003             B.N      ??OS_TmrLink_3
   1224          
   1225          
   1226              while ((p_tmr2 !=        (OS_TMR *)0) &&                    /* Find the appropriate position in the delta list.     */
   1227                     (delta  >= p_tmr2->Remain)) {
   1228                  delta  -= p_tmr2->Remain;                               /* Update our delta as we traverse the list.            */
   \                     ??OS_TmrLink_4: (+1)
   \   0000006A   0x6941             LDR      R1,[R0, #+20]
   \   0000006C   0x1A64             SUBS     R4,R4,R1
   1229                  p_tmr1  = p_tmr2;
   \   0000006E   0x0003             MOVS     R3,R0
   1230                  p_tmr2  = p_tmr2->NextPtr;
   \   00000070   0x68C0             LDR      R0,[R0, #+12]
   1231              }
   \                     ??OS_TmrLink_3: (+1)
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD002             BEQ.N    ??OS_TmrLink_5
   \   00000076   0x6941             LDR      R1,[R0, #+20]
   \   00000078   0x428C             CMP      R4,R1
   \   0000007A   0xD2F6             BCS.N    ??OS_TmrLink_4
   1232          
   1233          
   1234              if (p_tmr2 != (OS_TMR *)0) {                                /* Our entry is not the last element in the list.       */
   \                     ??OS_TmrLink_5: (+1)
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD009             BEQ.N    ??OS_TmrLink_6
   1235                  p_tmr1           = p_tmr2->PrevPtr;
   \   00000080   0x6901             LDR      R1,[R0, #+16]
   1236                  p_tmr->Remain    = delta;                               /* Store remaining time                                 */
   \   00000082   0x6154             STR      R4,[R2, #+20]
   1237                  p_tmr->PrevPtr   = p_tmr1;
   \   00000084   0x6111             STR      R1,[R2, #+16]
   1238                  p_tmr->NextPtr   = p_tmr2;
   \   00000086   0x60D0             STR      R0,[R2, #+12]
   1239                  p_tmr2->Remain  -= delta;                               /* Reduce time of next entry in the list                */
   \   00000088   0x6943             LDR      R3,[R0, #+20]
   \   0000008A   0x1B1C             SUBS     R4,R3,R4
   \   0000008C   0x6144             STR      R4,[R0, #+20]
   1240                  p_tmr2->PrevPtr  = p_tmr;
   \   0000008E   0x6102             STR      R2,[R0, #+16]
   1241                  p_tmr1->NextPtr  = p_tmr;
   \   00000090   0x60CA             STR      R2,[R1, #+12]
   \   00000092   0xE004             B.N      ??OS_TmrLink_7
   1242          
   1243              } else {                                                    /* Our entry belongs at the end of the list.            */
   1244                  p_tmr->Remain    = delta;
   \                     ??OS_TmrLink_6: (+1)
   \   00000094   0x6154             STR      R4,[R2, #+20]
   1245                  p_tmr->PrevPtr   = p_tmr1;
   \   00000096   0x6113             STR      R3,[R2, #+16]
   1246                  p_tmr->NextPtr   = (OS_TMR *)0;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x60D0             STR      R0,[R2, #+12]
   1247                  p_tmr1->NextPtr  = p_tmr;
   \   0000009C   0x60DA             STR      R2,[R3, #+12]
   1248              }
   1249          }
   \                     ??OS_TmrLink_7: (+1)
   \                     ??OS_TmrLink_1: (+1)
   \   0000009E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1250          
   1251          
   1252          /*
   1253          ************************************************************************************************************************
   1254          *                                         REMOVE A TIMER FROM THE TIMER LIST
   1255          *
   1256          * Description: This function is called to remove the timer from the timer list.
   1257          *
   1258          * Arguments  : p_tmr          Is a pointer to the timer to remove.
   1259          *
   1260          *              time           Is the system time when this timer was unlinked.
   1261          *              -----
   1262          *
   1263          * Returns    : none
   1264          *
   1265          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1266          ************************************************************************************************************************
   1267          */
   1268          

   \                                 In section .text, align 2, keep-with-next
   1269          void  OS_TmrUnlink (OS_TMR   *p_tmr,
   1270                              OS_TICK   time)
   1271          {
   \                     OS_TmrUnlink: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000A             MOVS     R2,R1
   1272              OS_TMR   *p_tmr1;
   1273              OS_TMR   *p_tmr2;
   1274              OS_TICK   elapsed;
   1275          
   1276          
   1277              p_tmr1                          = p_tmr->PrevPtr;
   \   00000006   0x6921             LDR      R1,[R4, #+16]
   1278              p_tmr2                          = p_tmr->NextPtr;
   \   00000008   0x68E0             LDR      R0,[R4, #+12]
   1279              if (p_tmr1 == (OS_TMR *)0) {
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD13C             BNE.N    ??OS_TmrUnlink_0
   1280                  if (p_tmr2 == (OS_TMR *)0) {                            /* Remove the ONLY entry in the list?                   */
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD109             BNE.N    ??OS_TmrUnlink_1
   1281                      OSTmrListPtr            = (OS_TMR *)0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable16_8
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1282          #if (OS_CFG_DBG_EN > 0u)
   1283                      OSTmrListEntries        = 0u;
   1284          #endif
   1285                      p_tmr->Remain           = 0u;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6160             STR      R0,[R4, #+20]
   1286          
   1287                      OSTmrTaskTickBase       = time;
   \   0000001C   0x....             LDR.N    R0,??DataTable16_6
   \   0000001E   0x6002             STR      R2,[R0, #+0]
   1288                      OS_TmrCondSignal();
   \   00000020   0x.... 0x....      BL       OS_TmrCondSignal
   \   00000024   0xE03E             B.N      ??OS_TmrUnlink_2
   1289                  } else {
   1290          #if (OS_CFG_DBG_EN > 0u)
   1291                      OSTmrListEntries--;
   1292          #endif
   1293                      elapsed                 = time - OSTmrTaskTickBase;
   \                     ??OS_TmrUnlink_1: (+1)
   \   00000026   0x....             LDR.N    R1,??DataTable16_6
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x1A51             SUBS     R1,R2,R1
   1294                      p_tmr2->PrevPtr         = (OS_TMR *)0;
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x6103             STR      R3,[R0, #+16]
   1295                      p_tmr2->Remain         += p_tmr->Remain;            /* Add back the ticks to the delta                      */
   \   00000030   0x6945             LDR      R5,[R0, #+20]
   \   00000032   0x6963             LDR      R3,[R4, #+20]
   \   00000034   0x195D             ADDS     R5,R3,R5
   \   00000036   0x6145             STR      R5,[R0, #+20]
   1296                      OSTmrListPtr            = p_tmr2;
   \   00000038   0x....             LDR.N    R3,??DataTable16_8
   \   0000003A   0x6018             STR      R0,[R3, #+0]
   \   0000003C   0xE00C             B.N      ??OS_TmrUnlink_3
   1297          
   1298                      while ((elapsed >           0u) &&
   1299                             (p_tmr2  != (OS_TMR *)0)) {
   1300          
   1301                          if (elapsed > p_tmr2->Remain) {
   1302                              elapsed        -= p_tmr2->Remain;
   1303                              p_tmr2->Remain  = 0u;
   1304                          } else {
   1305                              p_tmr2->Remain -= elapsed;
   \                     ??OS_TmrUnlink_4: (+1)
   \   0000003E   0x6943             LDR      R3,[R0, #+20]
   \   00000040   0x1A59             SUBS     R1,R3,R1
   \   00000042   0x6141             STR      R1,[R0, #+20]
   1306                              elapsed         = 0u;
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xE006             B.N      ??OS_TmrUnlink_5
   1307                          }
   \                     ??OS_TmrUnlink_6: (+1)
   \   00000048   0x6943             LDR      R3,[R0, #+20]
   \   0000004A   0x428B             CMP      R3,R1
   \   0000004C   0xD2F7             BCS.N    ??OS_TmrUnlink_4
   \   0000004E   0x6943             LDR      R3,[R0, #+20]
   \   00000050   0x1AC9             SUBS     R1,R1,R3
   \   00000052   0x2300             MOVS     R3,#+0
   \   00000054   0x6143             STR      R3,[R0, #+20]
   1308          
   1309          
   1310                          p_tmr1              = p_tmr2;
   1311                          p_tmr2              = p_tmr1->NextPtr;
   \                     ??OS_TmrUnlink_5: (+1)
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   1312                      }
   \                     ??OS_TmrUnlink_3: (+1)
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD001             BEQ.N    ??OS_TmrUnlink_7
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD1F3             BNE.N    ??OS_TmrUnlink_6
   1313          
   1314                      if ((OSTmrListPtr->Remain != p_tmr->Remain) ||      /* Reload if new head has a different delay         ... */
   1315                          (OSTmrListPtr->Remain ==            0u)) {      /* ... or has already timed out.                        */
   \                     ??OS_TmrUnlink_7: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable16_8
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6940             LDR      R0,[R0, #+20]
   \   00000066   0x6961             LDR      R1,[R4, #+20]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD104             BNE.N    ??OS_TmrUnlink_8
   \   0000006C   0x....             LDR.N    R0,??DataTable16_8
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x6940             LDR      R0,[R0, #+20]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD103             BNE.N    ??OS_TmrUnlink_9
   1316                          OSTmrTaskTickBase   = time;
   \                     ??OS_TmrUnlink_8: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable16_6
   \   00000078   0x6002             STR      R2,[R0, #+0]
   1317                          OS_TmrCondSignal();
   \   0000007A   0x.... 0x....      BL       OS_TmrCondSignal
   1318                      }
   1319          
   1320                      p_tmr->NextPtr          = (OS_TMR *)0;
   \                     ??OS_TmrUnlink_9: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x60E0             STR      R0,[R4, #+12]
   1321                      p_tmr->Remain           =           0u;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x6160             STR      R0,[R4, #+20]
   \   00000086   0xE00D             B.N      ??OS_TmrUnlink_2
   1322                  }
   1323              } else {
   1324          #if (OS_CFG_DBG_EN > 0u)
   1325                  OSTmrListEntries--;
   1326          #endif
   1327                  p_tmr1->NextPtr             = p_tmr2;
   \                     ??OS_TmrUnlink_0: (+1)
   \   00000088   0x60C8             STR      R0,[R1, #+12]
   1328                  if (p_tmr2 != (OS_TMR *)0) {
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD004             BEQ.N    ??OS_TmrUnlink_10
   1329                      p_tmr2->PrevPtr         = p_tmr1;
   \   0000008E   0x6101             STR      R1,[R0, #+16]
   1330                      p_tmr2->Remain         += p_tmr->Remain;            /* Add back the ticks to the delta list                 */
   \   00000090   0x6942             LDR      R2,[R0, #+20]
   \   00000092   0x6961             LDR      R1,[R4, #+20]
   \   00000094   0x188A             ADDS     R2,R1,R2
   \   00000096   0x6142             STR      R2,[R0, #+20]
   1331                  }
   1332                  p_tmr->PrevPtr              = (OS_TMR *)0;
   \                     ??OS_TmrUnlink_10: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x6120             STR      R0,[R4, #+16]
   1333                  p_tmr->NextPtr              = (OS_TMR *)0;
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x60E0             STR      R0,[R4, #+12]
   1334                  p_tmr->Remain               =           0u;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x6160             STR      R0,[R4, #+20]
   1335              }
   1336          }
   \                     ??OS_TmrUnlink_2: (+1)
   \   000000A4   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1337          
   1338          
   1339          /*
   1340          ************************************************************************************************************************
   1341          *                                                 TIMER MANAGEMENT TASK
   1342          *
   1343          * Description: This task is created by OS_TmrInit().
   1344          *
   1345          * Arguments  : none
   1346          *
   1347          * Returns    : none
   1348          *
   1349          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1350          *
   1351          *              2) The timer list is processed in two stages.
   1352          *                   a) Subtract the expired time from the delta list, which leaves expired timers at the head.
   1353          *                   b) Process each of the expired timers by invoking its callback (if any) and removing it.
   1354          *                 This method allows timer callbacks to Link/Unlink timers while maintaining the correct delta values.
   1355          *
   1356          *              3) Timer callbacks are allowed to make calls to the Timer APIs.
   1357          ************************************************************************************************************************
   1358          */
   1359          

   \                                 In section .text, align 4, keep-with-next
   1360          void  OS_TmrTask (void  *p_arg)
   1361          {
   \                     OS_TmrTask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1362              OS_TMR_CALLBACK_PTR   p_fnct;
   1363              OS_TMR               *p_tmr;
   1364              OS_TICK               timeout;
   1365              OS_TICK               elapsed;
   1366              OS_TICK               time;
   1367          #if (OS_CFG_TS_EN > 0u)
   1368              CPU_TS                ts_start;
   1369          #endif
   1370              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
   1371          
   1372          
   1373              (void)p_arg;                                                /* Not using 'p_arg', prevent compiler warning          */
   1374          
   1375              OS_TmrLock();
   \   00000004   0x.... 0x....      BL       OS_TmrLock
   \   00000008   0xE7FF             B.N      ??OS_TmrTask_0
   1376          
   1377              for (;;) {
   1378                  if (OSTmrListPtr == (OS_TMR *)0) {
   1379                      timeout                = 0u;
   1380                  } else {
   1381                      timeout                = OSTmrListPtr->Remain;
   1382                  }
   1383          
   1384                  OS_TmrCondWait(timeout);                                /* Suspend the timer task until it needs to process ... */
   1385                                                                          /* ... the timer list again. Also release the mutex ... */
   1386                                                                          /* ... so that application tasks can add/remove timers. */
   1387          
   1388                  if (OSTmrListPtr == (OS_TMR *)0) {                      /* Suppresses static analyzer warnings.                 */
   1389                      continue;
   \                     ??OS_TmrTask_1: (+1)
   \                     ??OS_TmrTask_0: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable16_8
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??OS_TmrTask_2
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE002             B.N      ??OS_TmrTask_3
   \                     ??OS_TmrTask_2: (+1)
   \   00000016   0x....             LDR.N    R0,??DataTable16_8
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6940             LDR      R0,[R0, #+20]
   \                     ??OS_TmrTask_3: (+1)
   \   0000001C   0x.... 0x....      BL       OS_TmrCondWait
   \   00000020   0x....             LDR.N    R0,??DataTable16_8
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD0F0             BEQ.N    ??OS_TmrTask_1
   1390                  }
   1391          
   1392          #if (OS_CFG_TS_EN > 0u)
   1393                  ts_start = OS_TS_GET();
   1394          #endif
   1395          
   1396                  CPU_CRITICAL_ENTER();
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   1397          #if (OS_CFG_DYN_TICK_EN > 0u)
   1398                  time                       = OSTickCtr + OS_DynTickGet();
   1399          #else
   1400                  time                       = OSTickCtr;
   \   0000002E   0x....             LDR.N    R1,??DataTable16_7
   \   00000030   0x680C             LDR      R4,[R1, #+0]
   1401          #endif
   1402                  CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
   1403                  elapsed                    = time - OSTmrTaskTickBase;
   \   00000036   0x....             LDR.N    R0,??DataTable16_6
   \   00000038   0x6801             LDR      R1,[R0, #+0]
   \   0000003A   0x1A61             SUBS     R1,R4,R1
   1404                  OSTmrTaskTickBase          = time;
   \   0000003C   0x....             LDR.N    R0,??DataTable16_6
   \   0000003E   0x6004             STR      R4,[R0, #+0]
   1405          
   1406                                                                          /* Update the delta values.                             */
   1407                  p_tmr = OSTmrListPtr;
   \   00000040   0x....             LDR.N    R0,??DataTable16_8
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xE00C             B.N      ??OS_TmrTask_4
   1408                  while ((elapsed !=          0u) &&
   1409                         (p_tmr   != (OS_TMR *)0)) {
   1410          
   1411                      if (elapsed > p_tmr->Remain) {
   1412                          elapsed           -= p_tmr->Remain;
   1413                          p_tmr->Remain      = 0u;
   1414                      } else {
   1415                          p_tmr->Remain     -= elapsed;
   \                     ??OS_TmrTask_5: (+1)
   \   00000046   0x6942             LDR      R2,[R0, #+20]
   \   00000048   0x1A51             SUBS     R1,R2,R1
   \   0000004A   0x6141             STR      R1,[R0, #+20]
   1416                          elapsed            = 0u;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xE006             B.N      ??OS_TmrTask_6
   1417                      }
   \                     ??OS_TmrTask_7: (+1)
   \   00000050   0x6942             LDR      R2,[R0, #+20]
   \   00000052   0x428A             CMP      R2,R1
   \   00000054   0xD2F7             BCS.N    ??OS_TmrTask_5
   \   00000056   0x6942             LDR      R2,[R0, #+20]
   \   00000058   0x1A89             SUBS     R1,R1,R2
   \   0000005A   0x2200             MOVS     R2,#+0
   \   0000005C   0x6142             STR      R2,[R0, #+20]
   1418          
   1419                      p_tmr                  = p_tmr->NextPtr;
   \                     ??OS_TmrTask_6: (+1)
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   1420                  }
   \                     ??OS_TmrTask_4: (+1)
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xD001             BEQ.N    ??OS_TmrTask_8
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD1F3             BNE.N    ??OS_TmrTask_7
   1421          
   1422                                                                          /* Process timers that have expired.                    */
   1423                  p_tmr                      = OSTmrListPtr;
   \                     ??OS_TmrTask_8: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable16_8
   \   0000006A   0x6804             LDR      R4,[R0, #+0]
   1424          
   1425                  while ((p_tmr         != (OS_TMR *)0) &&
   1426                         (p_tmr->Remain ==          0u)) {
   \                     ??OS_TmrTask_9: (+1)
   \   0000006C   0x2C00             CMP      R4,#+0
   \   0000006E   0xD0CC             BEQ.N    ??OS_TmrTask_0
   \   00000070   0x6960             LDR      R0,[R4, #+20]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD1C9             BNE.N    ??OS_TmrTask_0
   1427                      p_tmr->State           = OS_TMR_STATE_TIMEOUT;
   \   00000076   0x2004             MOVS     R0,#+4
   \   00000078   0xF884 0x0022      STRB     R0,[R4, #+34]
   1428                                                                          /* Execute callback function if available               */
   1429                      p_fnct                 = p_tmr->CallbackPtr;
   \   0000007C   0x6862             LDR      R2,[R4, #+4]
   1430                      if (p_fnct != (OS_TMR_CALLBACK_PTR)0u) {
   \   0000007E   0x0010             MOVS     R0,R2
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??OS_TmrTask_10
   1431                          (*p_fnct)(p_tmr, p_tmr->CallbackPtrArg);
   \   00000084   0x68A1             LDR      R1,[R4, #+8]
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x4790             BLX      R2
   1432                      }
   1433          
   1434                      if (p_tmr->State == OS_TMR_STATE_TIMEOUT) {
   \                     ??OS_TmrTask_10: (+1)
   \   0000008A   0xF894 0x0022      LDRB     R0,[R4, #+34]
   \   0000008E   0x2804             CMP      R0,#+4
   \   00000090   0xD11B             BNE.N    ??OS_TmrTask_11
   1435                          OS_TmrUnlink(p_tmr, OSTmrTaskTickBase);
   \   00000092   0x....             LDR.N    R0,??DataTable16_6
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       OS_TmrUnlink
   1436          
   1437                          if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
   \   0000009C   0x8C20             LDRH     R0,[R4, #+32]
   \   0000009E   0x2802             CMP      R0,#+2
   \   000000A0   0xD009             BEQ.N    ??OS_TmrTask_12
   1438                              p_tmr->State   = OS_TMR_STATE_RUNNING;
   1439                              p_tmr->Remain  = p_tmr->Period;
   1440                              OS_TmrLink(p_tmr, OSTmrTaskTickBase);
   1441                          } else {
   1442                              p_tmr->PrevPtr = (OS_TMR *)0;
   \                     ??OS_TmrTask_13: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x6120             STR      R0,[R4, #+16]
   1443                              p_tmr->NextPtr = (OS_TMR *)0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x60E0             STR      R0,[R4, #+12]
   1444                              p_tmr->Remain  = 0u;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x6160             STR      R0,[R4, #+20]
   1445                              p_tmr->State   = OS_TMR_STATE_COMPLETED;
   \   000000AE   0x2003             MOVS     R0,#+3
   \   000000B0   0xF884 0x0022      STRB     R0,[R4, #+34]
   \   000000B4   0xE009             B.N      ??OS_TmrTask_11
   1446                          }
   \                     ??OS_TmrTask_12: (+1)
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0xF884 0x0022      STRB     R0,[R4, #+34]
   \   000000BC   0x69E0             LDR      R0,[R4, #+28]
   \   000000BE   0x6160             STR      R0,[R4, #+20]
   \   000000C0   0x....             LDR.N    R0,??DataTable16_6
   \   000000C2   0x6801             LDR      R1,[R0, #+0]
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       OS_TmrLink
   1447                      }
   1448          
   1449                      p_tmr                  = OSTmrListPtr;
   \                     ??OS_TmrTask_11: (+1)
   \   000000CA   0x....             LDR.N    R0,??DataTable16_8
   \   000000CC   0x6804             LDR      R4,[R0, #+0]
   \   000000CE   0xE7CD             B.N      ??OS_TmrTask_9
   1450                  }
   1451          
   1452          #if (OS_CFG_TS_EN > 0u)
   1453                  OSTmrTaskTime = OS_TS_GET() - ts_start;                 /* Measure execution time of timer task                 */
   1454                  if (OSTmrTaskTimeMax < OSTmrTaskTime) {
   1455                      OSTmrTaskTimeMax       = OSTmrTaskTime;
   1456                  }
   1457          #endif
   1458              }
   1459          }
   1460          
   1461          
   1462          /*
   1463          ************************************************************************************************************************
   1464          *                                          TIMER MANAGEMENT LOCKING MECHANISM
   1465          *
   1466          * Description: These functions are used to handle timer critical sections.  The method uses a mutex
   1467          *              to protect access to the global timer list.
   1468          *
   1469          * Arguments  : none
   1470          *
   1471          * Returns    : none
   1472          *
   1473          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application MUST NOT call them.
   1474          ************************************************************************************************************************
   1475          */
   1476          

   \                                 In section .text, align 2, keep-with-next
   1477          static  void  OS_TmrLock (void)
   1478          {
   \                     OS_TmrLock: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
   1479              OS_ERR  err;
   1480          
   1481          
   1482              OSMutexPend(&OSTmrMutex, 0u, OS_OPT_PEND_BLOCKING, (CPU_TS *)0, &err);
   \   00000002   0xA801             ADD      R0,SP,#+4
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_12
   \   0000000E   0x.... 0x....      BL       OSMutexPend
   1483          }
   \   00000012   0xBD07             POP      {R0-R2,PC}       ;; return
   1484          
   1485          

   \                                 In section .text, align 2, keep-with-next
   1486          static  void  OS_TmrUnlock (void)
   1487          {
   \                     OS_TmrUnlock: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1488              OS_ERR  err;
   1489          
   1490          
   1491              OSMutexPost(&OSTmrMutex, OS_OPT_POST_NONE, &err);
   \   00000002   0x466A             MOV      R2,SP
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR.N    R0,??DataTable16_12
   \   00000008   0x.... 0x....      BL       OSMutexPost
   1492          }
   \   0000000C   0xBD01             POP      {R0,PC}          ;; return
   1493          
   1494          
   1495          /*
   1496          ************************************************************************************************************************
   1497          *                                         CREATE TIMER TASK CONDITION VARIABLE
   1498          *
   1499          * Description: Initializes a condition variable for INTERNAL use ONLY.
   1500          *
   1501          * Arguments  : none
   1502          *
   1503          * Returns    : none
   1504          *
   1505          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1506          ************************************************************************************************************************
   1507          */
   1508          

   \                                 In section .text, align 2, keep-with-next
   1509          static  void  OS_TmrCondCreate (void)
   1510          {
   \                     OS_TmrCondCreate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1511              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
   1512          
   1513          
   1514              CPU_CRITICAL_ENTER();
   \   00000004   0x2040             MOVS     R0,#+64
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0004             MOVS     R4,R0
   1515          #if (OS_OBJ_TYPE_REQ > 0u)
   1516              OSTmrCond.Type  = OS_OBJ_TYPE_COND;                         /* Mark the data structure as a condition variable.     */
   \   0000000C   0x....             LDR.N    R0,??DataTable16_18  ;; 0x444e4f43
   \   0000000E   0x....             LDR.N    R1,??DataTable16_19
   \   00000010   0x6008             STR      R0,[R1, #+0]
   1517          #endif
   1518              OSTmrCond.Mutex = &OSTmrMutex;                              /* Bind the timer mutex to the condition variable.      */
   \   00000012   0x....             LDR.N    R0,??DataTable16_12
   \   00000014   0x....             LDR.N    R1,??DataTable16_19
   \   00000016   0x60C8             STR      R0,[R1, #+12]
   1519              OS_PendListInit(&OSTmrCond.PendList);                       /* Initialize the waiting list                          */
   \   00000018   0x....             LDR.N    R0,??DataTable16_20
   \   0000001A   0x.... 0x....      BL       OS_PendListInit
   1520              CPU_CRITICAL_EXIT();
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       CPU_SR_Restore
   1521          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1522          
   1523          
   1524          /*
   1525          ************************************************************************************************************************
   1526          *                                         WAIT ON TIMER TASK CONDITION VARIABLE
   1527          *
   1528          * Description: Allows the timer task to release the global mutex and pend atomically. This ensures that
   1529          *              timers are only added/removed after the timer task has processed the current list and pended
   1530          *              for the next timeout. The timer task will always acquire the mutex before returning from this function.
   1531          *
   1532          * Arguments  : timeout                   The number of ticks before the timer task will wake up.
   1533          *                                        A value of zero signifies an indefinite pend.
   1534          *
   1535          * Returns    : none
   1536          *
   1537          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1538          ************************************************************************************************************************
   1539          */
   1540          

   \                                 In section .text, align 2, keep-with-next
   1541          static  void  OS_TmrCondWait (OS_TICK  timeout)
   1542          {
   \                     OS_TmrCondWait: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1543              OS_TCB        *p_tcb;
   1544              OS_PEND_LIST  *p_pend_list;
   1545              CPU_TS         ts;
   1546              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
   1547          
   1548          
   1549              CPU_CRITICAL_ENTER();
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0005             MOVS     R5,R0
   1550          #if (OS_CFG_TS_EN > 0u)
   1551              ts             = OS_TS_GET();                               /* Get timestamp                                        */
   1552              OSTmrMutex.TS  = ts;
   1553          #else
   1554              ts             = 0u;
   \   0000000E   0x2600             MOVS     R6,#+0
   1555          #endif
   1556                                                                          /* Release mutex to other tasks.                        */
   1557              OS_MutexGrpRemove(&OSTmrTaskTCB, &OSTmrMutex);
   \   00000010   0x....             LDR.N    R1,??DataTable16_12
   \   00000012   0x....             LDR.N    R0,??DataTable16_5
   \   00000014   0x.... 0x....      BL       OS_MutexGrpRemove
   1558              p_pend_list                    = &OSTmrMutex.PendList;
   \   00000018   0x....             LDR.N    R1,??DataTable16_21
   1559          
   1560              if (OSTmrTaskTCB.Prio != OSTmrTaskTCB.BasePrio) {           /* Restore our original prio.                           */
   \   0000001A   0x....             LDR.N    R0,??DataTable16_5
   \   0000001C   0xF890 0x002F      LDRB     R0,[R0, #+47]
   \   00000020   0x....             LDR.N    R2,??DataTable16_5
   \   00000022   0xF892 0x2030      LDRB     R2,[R2, #+48]
   \   00000026   0x4290             CMP      R0,R2
   \   00000028   0xD00A             BEQ.N    ??OS_TmrCondWait_0
   1561                  OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(&OSTmrTaskTCB, OSTmrTaskTCB.Prio);
   1562                  OSTmrTaskTCB.Prio          = OSTmrTaskTCB.BasePrio;
   \   0000002A   0x....             LDR.N    R0,??DataTable16_5
   \   0000002C   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   00000030   0x....             LDR.N    R2,??DataTable16_5
   \   00000032   0xF882 0x002F      STRB     R0,[R2, #+47]
   1563                  OSPrioCur                  = OSTmrTaskTCB.BasePrio;
   \   00000036   0x....             LDR.N    R0,??DataTable16_5
   \   00000038   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   0000003C   0x....             LDR.N    R2,??DataTable16_22
   \   0000003E   0x7010             STRB     R0,[R2, #+0]
   1564              }
   1565          
   1566              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on mutex?                           */
   \                     ??OS_TmrCondWait_0: (+1)
   \   00000040   0x6808             LDR      R0,[R1, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD106             BNE.N    ??OS_TmrCondWait_1
   1567                  OSTmrMutex.OwnerTCBPtr     = (OS_TCB *)0;               /* No                                                   */
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable16_12
   \   0000004A   0x6108             STR      R0,[R1, #+16]
   1568                  OSTmrMutex.OwnerNestingCtr =           0u;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x....             LDR.N    R1,??DataTable16_12
   \   00000050   0x7508             STRB     R0,[R1, #+20]
   \   00000052   0xE010             B.N      ??OS_TmrCondWait_2
   1569              } else {
   1570                  p_tcb                      = p_pend_list->HeadPtr;      /* Yes, give mutex to new owner                         */
   \                     ??OS_TmrCondWait_1: (+1)
   \   00000054   0x680F             LDR      R7,[R1, #+0]
   1571                  OSTmrMutex.OwnerTCBPtr     = p_tcb;
   \   00000056   0x....             LDR.N    R0,??DataTable16_12
   \   00000058   0x6107             STR      R7,[R0, #+16]
   1572                  OSTmrMutex.OwnerNestingCtr =           1u;
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x....             LDR.N    R1,??DataTable16_12
   \   0000005E   0x7508             STRB     R0,[R1, #+20]
   1573                  OS_MutexGrpAdd(p_tcb, &OSTmrMutex);
   \   00000060   0x....             LDR.N    R1,??DataTable16_12
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       OS_MutexGrpAdd
   1574                                                                          /* Post to mutex                                        */
   1575                  OS_Post((OS_PEND_OBJ *)((void *)&OSTmrMutex),
   1576                                                   p_tcb,
   1577                                          (void *) 0,
   1578                                                   0u,
   1579                                                   ts);
   \   00000068   0x9600             STR      R6,[SP, #+0]
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x0039             MOVS     R1,R7
   \   00000070   0x....             LDR.N    R0,??DataTable16_12
   \   00000072   0x.... 0x....      BL       OS_Post
   1580              }
   1581          
   1582              OS_Pend((OS_PEND_OBJ *)((void *)&OSTmrCond),                /* Pend on the condition variable.                      */
   1583                                             &OSTmrTaskTCB,
   1584                                              OS_TASK_PEND_ON_COND,
   1585                                              timeout);
   \                     ??OS_TmrCondWait_2: (+1)
   \   00000076   0x0023             MOVS     R3,R4
   \   00000078   0x2203             MOVS     R2,#+3
   \   0000007A   0x....             LDR.N    R1,??DataTable16_5
   \   0000007C   0x....             LDR.N    R0,??DataTable16_19
   \   0000007E   0x.... 0x....      BL       OS_Pend
   1586              CPU_CRITICAL_EXIT();
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      BL       CPU_SR_Restore
   1587          
   1588              OSSched();
   \   00000088   0x.... 0x....      BL       OSSched
   1589          
   1590              CPU_CRITICAL_ENTER();                                       /* Either we timed out, or were signaled.               */
   \   0000008C   0x2040             MOVS     R0,#+64
   \   0000008E   0x.... 0x....      BL       CPU_SR_Save
   \   00000092   0x0004             MOVS     R4,R0
   1591          
   1592              if (OSTmrMutex.OwnerTCBPtr == (OS_TCB *)0) {                /* Can we grab the mutex?                               */
   \   00000094   0x....             LDR.N    R0,??DataTable16_12
   \   00000096   0x6900             LDR      R0,[R0, #+16]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD10D             BNE.N    ??OS_TmrCondWait_3
   1593                  OS_MutexGrpAdd(&OSTmrTaskTCB, &OSTmrMutex);             /* Yes, no-one else pending.                            */
   \   0000009C   0x....             LDR.N    R1,??DataTable16_12
   \   0000009E   0x....             LDR.N    R0,??DataTable16_5
   \   000000A0   0x.... 0x....      BL       OS_MutexGrpAdd
   1594                  OSTmrMutex.OwnerTCBPtr     = &OSTmrTaskTCB;
   \   000000A4   0x....             LDR.N    R0,??DataTable16_5
   \   000000A6   0x....             LDR.N    R1,??DataTable16_12
   \   000000A8   0x6108             STR      R0,[R1, #+16]
   1595                  OSTmrMutex.OwnerNestingCtr = 1u;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x....             LDR.N    R1,??DataTable16_12
   \   000000AE   0x7508             STRB     R0,[R1, #+20]
   1596                  CPU_CRITICAL_EXIT();
   \   000000B0   0x0020             MOVS     R0,R4
   \   000000B2   0x.... 0x....      BL       CPU_SR_Restore
   \   000000B6   0xE018             B.N      ??OS_TmrCondWait_4
   1597              } else {
   1598                  p_tcb = OSTmrMutex.OwnerTCBPtr;                         /* No, we need to wait for it.                          */
   \                     ??OS_TmrCondWait_3: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable16_12
   \   000000BA   0x6900             LDR      R0,[R0, #+16]
   1599                  if (p_tcb->Prio > OSTmrTaskTCB.Prio) {                  /* See if mutex owner has a lower priority than TmrTask.*/
   \   000000BC   0x....             LDR.N    R1,??DataTable16_5
   \   000000BE   0xF891 0x102F      LDRB     R1,[R1, #+47]
   \   000000C2   0xF890 0x202F      LDRB     R2,[R0, #+47]
   \   000000C6   0x4291             CMP      R1,R2
   \   000000C8   0xD204             BCS.N    ??OS_TmrCondWait_5
   1600                      OS_TaskChangePrio(p_tcb, OSTmrTaskTCB.Prio);
   \   000000CA   0x....             LDR.N    R1,??DataTable16_5
   \   000000CC   0xF891 0x102F      LDRB     R1,[R1, #+47]
   \   000000D0   0x.... 0x....      BL       OS_TaskChangePrio
   1601                  }
   1602          
   1603                  OS_Pend((OS_PEND_OBJ *)((void *)&OSTmrMutex),           /* Block TmrTask until it gets the Mutex.               */
   1604                                                  &OSTmrTaskTCB,
   1605                                                   OS_TASK_PEND_ON_MUTEX,
   1606                                                   0u);
   \                     ??OS_TmrCondWait_5: (+1)
   \   000000D4   0x2300             MOVS     R3,#+0
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0x....             LDR.N    R1,??DataTable16_5
   \   000000DA   0x....             LDR.N    R0,??DataTable16_12
   \   000000DC   0x.... 0x....      BL       OS_Pend
   1607                  CPU_CRITICAL_EXIT();
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
   1608          
   1609                  OSSched();
   \   000000E6   0x.... 0x....      BL       OSSched
   1610              }
   1611          }
   \                     ??OS_TmrCondWait_4: (+1)
   \   000000EA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1612          
   1613          
   1614          /*
   1615          ************************************************************************************************************************
   1616          *                                       SIGNAL THE TIMER TASK CONDITION VARIABLE
   1617          *
   1618          * Description: Used to signal the timer task when a timer is added/removed which requires the task to reload
   1619          *              its timeout. We ensure that this function is always called with the timer mutex locked.
   1620          *
   1621          * Arguments  : none.
   1622          *
   1623          * Returns    : none
   1624          *
   1625          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1626          ************************************************************************************************************************
   1627          */
   1628          

   \                                 In section .text, align 2, keep-with-next
   1629          static  void  OS_TmrCondSignal (void)
   1630          {
   \                     OS_TmrCondSignal: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   1631              OS_PEND_LIST  *p_pend_list;
   1632              CPU_TS         ts;
   1633              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
   1634          
   1635          
   1636              CPU_CRITICAL_ENTER();
   \   00000004   0x2040             MOVS     R0,#+64
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0004             MOVS     R4,R0
   1637          #if (OS_CFG_TS_EN > 0u)
   1638              ts             = OS_TS_GET();                               /* Get timestamp                                        */
   1639              OSTmrMutex.TS  = ts;
   1640          #else
   1641              ts             = 0u;
   \   0000000C   0x2100             MOVS     R1,#+0
   1642          #endif
   1643          
   1644              p_pend_list    = &OSTmrCond.PendList;
   \   0000000E   0x....             LDR.N    R0,??DataTable16_20
   1645          
   1646              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Timer task waiting on cond?                          */
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD103             BNE.N    ??OS_TmrCondSignal_0
   1647                  CPU_CRITICAL_EXIT();
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       CPU_SR_Restore
   1648                  return;                                                 /* No, nothing to signal.                               */
   \   0000001C   0xE009             B.N      ??OS_TmrCondSignal_1
   1649              } else {
   1650                                                                          /* Yes, signal the timer task.                          */
   1651                  OS_Post((OS_PEND_OBJ *)((void *)&OSTmrCond),
   1652                                                  &OSTmrTaskTCB,
   1653                                          (void *) 0,
   1654                                                   0u,
   1655                                                   ts);
   \                     ??OS_TmrCondSignal_0: (+1)
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable16_5
   \   00000026   0x....             LDR.N    R0,??DataTable16_19
   \   00000028   0x.... 0x....      BL       OS_Post
   1656              }
   1657          
   1658              CPU_CRITICAL_EXIT();
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
   1659          }
   \                     ??OS_TmrCondSignal_1: (+1)
   \   00000032   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x20524D54         DC32     0x20524d54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     OSTmrToTicksMult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     OSTmrTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     OSTmrTaskTickBase

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     OSTmrListPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     OSCfg_TmrTaskRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     OSTmrMutex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     OSCfg_TmrTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x........         DC32     OSCfg_TmrTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x........         DC32     OSCfg_TmrTaskPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x........         DC32     OSCfg_TmrTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x444E4F43         DC32     0x444e4f43

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x........         DC32     OSTmrCond

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   0x........         DC32     OSTmrCond+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   0x........         DC32     OSTmrMutex+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   0x........         DC32     OSPrioCur
   1660          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   OSTmrCreate
        32   -> OS_TmrLock
        32   -> OS_TmrUnlock
      16   OSTmrDel
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_TmrClr
        16   -> OS_TmrLock
        16   -> OS_TmrUnlink
        16   -> OS_TmrUnlock
      16   OSTmrRemainGet
        16   -> OS_TmrLock
        16   -> OS_TmrUnlock
      32   OSTmrSet
        32   -> OS_TmrLock
        32   -> OS_TmrUnlock
      16   OSTmrStart
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_TmrLink
        16   -> OS_TmrLock
        16   -> OS_TmrUnlink
        16   -> OS_TmrUnlock
      16   OSTmrStateGet
        16   -> OS_TmrLock
        16   -> OS_TmrUnlock
      24   OSTmrStop
        24   -- Indirect call
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_TmrLock
        24   -> OS_TmrUnlink
        24   -> OS_TmrUnlock
       0   OS_TmrClr
       8   OS_TmrCondCreate
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_PendListInit
      16   OS_TmrCondSignal
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_Post
      24   OS_TmrCondWait
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_MutexGrpAdd
        24   -> OS_MutexGrpRemove
        24   -> OS_Pend
        24   -> OS_Post
        24   -> OS_TaskChangePrio
      48   OS_TmrInit
        48   -> OSMutexCreate
        48   -> OSTaskCreate
        48   -> OS_TmrCondCreate
      16   OS_TmrLink
        16   -> OS_TmrCondSignal
      16   OS_TmrLock
        16   -> OSMutexPend
       8   OS_TmrTask
         8   -- Indirect call
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OS_TmrCondWait
         8   -> OS_TmrLink
         8   -> OS_TmrLock
         8   -> OS_TmrUnlink
      16   OS_TmrUnlink
        16   -> OS_TmrCondSignal
       8   OS_TmrUnlock
         8   -> OSMutexPost


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
     248  OSTmrCreate
     210  OSTmrDel
     238  OSTmrRemainGet
     186  OSTmrSet
     258  OSTmrStart
     120  OSTmrStateGet
     318  OSTmrStop
      46  OS_TmrClr
      38  OS_TmrCondCreate
      52  OS_TmrCondSignal
     236  OS_TmrCondWait
     188  OS_TmrInit
     160  OS_TmrLink
      20  OS_TmrLock
     208  OS_TmrTask
     166  OS_TmrUnlink
      14  OS_TmrUnlock

 
 2 798 bytes in section .text
 
 2 798 bytes of CODE memory

Errors: none
Warnings: none
