###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_mutex.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3B0B.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_mutex.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_mutex.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_mutex.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_mutex.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                           MUTEX MANAGEMENT
     20          *
     21          * File    : os_mutex.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_mutex__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_MUTEX_EN > 0u)
     35          /*
     36          ************************************************************************************************************************
     37          *                                                   CREATE A MUTEX
     38          *
     39          * Description: This function creates a mutex.
     40          *
     41          * Arguments  : p_mutex       is a pointer to the mutex to initialize.  Your application is responsible for allocating
     42          *                            storage for the mutex.
     43          *
     44          *              p_name        is a pointer to the name you would like to give the mutex.
     45          *
     46          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     47          *
     48          *                                OS_ERR_NONE                    If the call was successful
     49          *                                OS_ERR_CREATE_ISR              If you called this function from an ISR
     50          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the mutex after you called
     51          *                                                                 OSSafetyCriticalStart()
     52          *                                OS_ERR_OBJ_PTR_NULL            If 'p_mutex' is a NULL pointer
     53          *                                OS_ERR_OBJ_CREATED             If the mutex was already created
     54          *
     55          * Returns    : none
     56          *
     57          * Note(s)    : none
     58          ************************************************************************************************************************
     59          */
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void  OSMutexCreate (OS_MUTEX  *p_mutex,
     62                               CPU_CHAR  *p_name,
     63                               OS_ERR    *p_err)
     64          {
   \                     OSMutexCreate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
     65              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
     66          
     67          
     68          #ifdef OS_SAFETY_CRITICAL
     69              if (p_err == (OS_ERR *)0) {
     70                  OS_SAFETY_CRITICAL_EXCEPTION();
     71                  return;
     72              }
     73          #endif
     74          
     75          #ifdef OS_SAFETY_CRITICAL_IEC61508
     76              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     77                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     78                  return;
     79              }
     80          #endif
     81          
     82          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
     83              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSMutexCreate_0
     84                 *p_err = OS_ERR_CREATE_ISR;
   \   00000012   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000016   0x8028             STRH     R0,[R5, #+0]
     85                  return;
   \   00000018   0xE026             B.N      ??OSMutexCreate_1
     86              }
     87          #endif
     88          
     89          #if (OS_CFG_ARG_CHK_EN > 0u)
     90              if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                   */
   \                     ??OSMutexCreate_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD103             BNE.N    ??OSMutexCreate_2
     91                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001E   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000022   0x8028             STRH     R0,[R5, #+0]
     92                  return;
   \   00000024   0xE020             B.N      ??OSMutexCreate_1
     93              }
     94          #endif
     95          
     96              CPU_CRITICAL_ENTER();
   \                     ??OSMutexCreate_2: (+1)
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0006             MOVS     R6,R0
     97          #if (OS_OBJ_TYPE_REQ > 0u)
     98          #if (OS_CFG_OBJ_CREATED_CHK_EN > 0u)
     99              if (p_mutex->Type == OS_OBJ_TYPE_MUTEX) {
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x5854554d
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xD106             BNE.N    ??OSMutexCreate_3
    100                  CPU_CRITICAL_EXIT();
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0x.... 0x....      BL       CPU_SR_Restore
    101                  *p_err = OS_ERR_OBJ_CREATED;
   \   0000003E   0xF645 0x50C1      MOVW     R0,#+24001
   \   00000042   0x8028             STRH     R0,[R5, #+0]
    102                  return;
   \   00000044   0xE010             B.N      ??OSMutexCreate_1
    103              }
    104          #endif
    105              p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;            /* Mark the data structure as a mutex                   */
   \                     ??OSMutexCreate_3: (+1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable5_1  ;; 0x5854554d
   \   0000004A   0x6020             STR      R0,[R4, #+0]
    106          #endif
    107          #if (OS_CFG_DBG_EN > 0u)
    108              p_mutex->NamePtr           =  p_name;
    109          #else
    110              (void)p_name;
    111          #endif
    112              p_mutex->MutexGrpNextPtr   = (OS_MUTEX *)0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x60E0             STR      R0,[R4, #+12]
    113              p_mutex->OwnerTCBPtr       = (OS_TCB   *)0;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6120             STR      R0,[R4, #+16]
    114              p_mutex->OwnerNestingCtr   =             0u;                /* Mutex is available                                   */
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x7520             STRB     R0,[R4, #+20]
    115          #if (OS_CFG_TS_EN > 0u)
    116              p_mutex->TS                =             0u;
    117          #endif
    118              OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
   \   00000058   0x1D20             ADDS     R0,R4,#+4
   \   0000005A   0x.... 0x....      BL       OS_PendListInit
    119          
    120          #if (OS_CFG_DBG_EN > 0u)
    121              OS_MutexDbgListAdd(p_mutex);
    122              OSMutexQty++;
    123          #endif
    124          
    125              OS_TRACE_MUTEX_CREATE(p_mutex, p_name);
    126              CPU_CRITICAL_EXIT();
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0x.... 0x....      BL       CPU_SR_Restore
    127             *p_err = OS_ERR_NONE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x8028             STRH     R0,[R5, #+0]
    128          }
   \                     ??OSMutexCreate_1: (+1)
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    129          
    130          
    131          /*
    132          ************************************************************************************************************************
    133          *                                                   DELETE A MUTEX
    134          *
    135          * Description: This function deletes a mutex and readies all tasks pending on the mutex.
    136          *
    137          * Arguments  : p_mutex       is a pointer to the mutex to delete
    138          *
    139          *              opt           determines delete options as follows:
    140          *
    141          *                                OS_OPT_DEL_NO_PEND          Delete mutex ONLY if no task pending
    142          *                                OS_OPT_DEL_ALWAYS           Deletes the mutex even if tasks are waiting.
    143          *                                                            In this case, all the tasks pending will be readied.
    144          *
    145          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    146          *
    147          *                                OS_ERR_NONE                    The call was successful and the mutex was deleted
    148          *                                OS_ERR_DEL_ISR                 If you attempted to delete the mutex from an ISR
    149          *                                OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the mutex after you called
    150          *                                                                 OSStart()
    151          *                                OS_ERR_OBJ_PTR_NULL            If 'p_mutex' is a NULL pointer
    152          *                                OS_ERR_OBJ_TYPE                If 'p_mutex' is not pointing to a mutex
    153          *                                OS_ERR_OPT_INVALID             An invalid option was specified
    154          *                                OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    155          *                                OS_ERR_TASK_WAITING            One or more tasks were waiting on the mutex
    156          *
    157          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    158          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    159          *
    160          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the mutex MUST
    161          *                 check the return code of OSMutexPend().
    162          *
    163          *              2) Because ALL tasks pending on the mutex will be readied, you MUST be careful in applications where the
    164          *                 mutex is used for mutual exclusion because the resource(s) will no longer be guarded by the mutex.
    165          ************************************************************************************************************************
    166          */
    167          
    168          #if (OS_CFG_MUTEX_DEL_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    169          OS_OBJ_QTY  OSMutexDel (OS_MUTEX  *p_mutex,
    170                                  OS_OPT     opt,
    171                                  OS_ERR    *p_err)
    172          {
   \                     OSMutexDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0016             MOVS     R6,R2
    173              OS_OBJ_QTY     nbr_tasks;
    174              OS_PEND_LIST  *p_pend_list;
    175              OS_TCB        *p_tcb;
    176              OS_TCB        *p_tcb_owner;
    177              CPU_TS         ts;
    178          #if (OS_CFG_MUTEX_EN > 0u)
    179              OS_PRIO        prio_new;
    180          #endif
    181              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    182          
    183          
    184          #ifdef OS_SAFETY_CRITICAL
    185              if (p_err == (OS_ERR *)0) {
    186                  OS_SAFETY_CRITICAL_EXCEPTION();
    187                  return (0u);
    188              }
    189          #endif
    190          
    191              OS_TRACE_MUTEX_DEL_ENTER(p_mutex, opt);
    192          
    193          #ifdef OS_SAFETY_CRITICAL_IEC61508
    194              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    195                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    196                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    197                  return (0u);
    198              }
    199          #endif
    200          
    201          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    202              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to delete a mutex from an ISR            */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSMutexDel_0
    203                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_DEL_ISR);
    204                 *p_err = OS_ERR_DEL_ISR;
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    205                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE084             B.N      ??OSMutexDel_1
    206              }
    207          #endif
    208          
    209          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    210              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSMutexDel_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD004             BEQ.N    ??OSMutexDel_2
    211                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    212                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002A   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002E   0x8030             STRH     R0,[R6, #+0]
    213                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE07A             B.N      ??OSMutexDel_1
    214              }
    215          #endif
    216          
    217          #if (OS_CFG_ARG_CHK_EN > 0u)
    218              if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                   */
   \                     ??OSMutexDel_2: (+1)
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD104             BNE.N    ??OSMutexDel_3
    219                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    220                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000038   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000003C   0x8030             STRH     R0,[R6, #+0]
    221                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE073             B.N      ??OSMutexDel_1
    222              }
    223          #endif
    224          
    225          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    226              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexDel_3: (+1)
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x5854554d
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD004             BEQ.N    ??OSMutexDel_4
    227                  OS_TRACE_MUTEX_DEL_EXIT(OS_ERR_OBJ_TYPE);
    228                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000004C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000050   0x8030             STRH     R0,[R6, #+0]
    229                  return (0u);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE069             B.N      ??OSMutexDel_1
    230              }
    231          #endif
    232          
    233              CPU_CRITICAL_ENTER();
   \                     ??OSMutexDel_4: (+1)
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
   \   0000005C   0x0007             MOVS     R7,R0
    234              p_pend_list = &p_mutex->PendList;
   \   0000005E   0x1D2C             ADDS     R4,R5,#+4
    235              nbr_tasks   = 0u;
   \   00000060   0xF05F 0x0800      MOVS     R8,#+0
    236              switch (opt) {
   \   00000064   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000068   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006C   0xD003             BEQ.N    ??OSMutexDel_5
   \   0000006E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000072   0xD01A             BEQ.N    ??OSMutexDel_6
   \   00000074   0xE051             B.N      ??OSMutexDel_7
    237                  case OS_OPT_DEL_NO_PEND:                                /* Delete mutex only if no task waiting                 */
    238                       if (p_pend_list->HeadPtr == (OS_TCB *)0) {
   \                     ??OSMutexDel_5: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD10F             BNE.N    ??OSMutexDel_8
    239          #if (OS_CFG_DBG_EN > 0u)
    240                           OS_MutexDbgListRemove(p_mutex);
    241                           OSMutexQty--;
    242          #endif
    243                           OS_TRACE_MUTEX_DEL(p_mutex);
    244                           if (p_mutex->OwnerTCBPtr != (OS_TCB *)0) {     /* Does the mutex belong to a task?                     */
   \   0000007C   0x6928             LDR      R0,[R5, #+16]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD003             BEQ.N    ??OSMutexDel_9
    245                               OS_MutexGrpRemove(p_mutex->OwnerTCBPtr, p_mutex); /* yes, remove it from the task group.           */
   \   00000082   0x0029             MOVS     R1,R5
   \   00000084   0x6928             LDR      R0,[R5, #+16]
   \   00000086   0x.... 0x....      BL       OS_MutexGrpRemove
    246                           }
    247                           OS_MutexClr(p_mutex);
   \                     ??OSMutexDel_9: (+1)
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0x.... 0x....      BL       OS_MutexClr
    248                           CPU_CRITICAL_EXIT();
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    249                          *p_err = OS_ERR_NONE;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x8030             STRH     R0,[R6, #+0]
   \   0000009A   0xE005             B.N      ??OSMutexDel_10
    250                       } else {
    251                           CPU_CRITICAL_EXIT();
   \                     ??OSMutexDel_8: (+1)
   \   0000009C   0x0038             MOVS     R0,R7
   \   0000009E   0x.... 0x....      BL       CPU_SR_Restore
    252                          *p_err = OS_ERR_TASK_WAITING;
   \   000000A2   0xF247 0x105F      MOVW     R0,#+29023
   \   000000A6   0x8030             STRH     R0,[R6, #+0]
    253                       }
    254                       break;
   \                     ??OSMutexDel_10: (+1)
   \   000000A8   0xE03D             B.N      ??OSMutexDel_11
    255          
    256                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the mutex                              */
    257          #if (OS_CFG_TS_EN > 0u)
    258                       ts = OS_TS_GET();                                  /* Get timestamp                                        */
    259          #else
    260                       ts = 0u;
   \                     ??OSMutexDel_6: (+1)
   \   000000AA   0xF05F 0x0900      MOVS     R9,#+0
   \   000000AE   0xE006             B.N      ??OSMutexDel_12
    261          #endif
    262                       while (p_pend_list->HeadPtr != (OS_TCB *)0) {      /* Remove all tasks from the pend list                  */
    263                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSMutexDel_13: (+1)
   \   000000B0   0x6820             LDR      R0,[R4, #+0]
    264                           OS_PendAbort(p_tcb,
    265                                        ts,
    266                                        OS_STATUS_PEND_DEL);
   \   000000B2   0x2202             MOVS     R2,#+2
   \   000000B4   0x4649             MOV      R1,R9
   \   000000B6   0x.... 0x....      BL       OS_PendAbort
    267                           nbr_tasks++;
   \   000000BA   0xF118 0x0801      ADDS     R8,R8,#+1
    268                       }
   \                     ??OSMutexDel_12: (+1)
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD1F5             BNE.N    ??OSMutexDel_13
    269          #if (OS_CFG_DBG_EN > 0u)
    270                       OS_MutexDbgListRemove(p_mutex);
    271                       OSMutexQty--;
    272          #endif
    273                       OS_TRACE_MUTEX_DEL(p_mutex);
    274                       p_tcb_owner = p_mutex->OwnerTCBPtr;
   \   000000C4   0x692C             LDR      R4,[R5, #+16]
    275                       if (p_tcb_owner != (OS_TCB *)0) {                  /* Does the mutex belong to a task?                     */
   \   000000C6   0x2C00             CMP      R4,#+0
   \   000000C8   0xD003             BEQ.N    ??OSMutexDel_14
    276                           OS_MutexGrpRemove(p_tcb_owner, p_mutex);       /* yes, remove it from the task group.                  */
   \   000000CA   0x0029             MOVS     R1,R5
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       OS_MutexGrpRemove
    277                       }
    278          
    279          
    280                       if (p_tcb_owner != (OS_TCB *)0) {                  /* Did we had to change the prio of owner?              */
   \                     ??OSMutexDel_14: (+1)
   \   000000D2   0x2C00             CMP      R4,#+0
   \   000000D4   0xD016             BEQ.N    ??OSMutexDel_15
    281                           if (p_tcb_owner->Prio != p_tcb_owner->BasePrio) {
   \   000000D6   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   000000DA   0xF894 0x1030      LDRB     R1,[R4, #+48]
   \   000000DE   0x4288             CMP      R0,R1
   \   000000E0   0xD010             BEQ.N    ??OSMutexDel_15
    282                               prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
    283                               prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   000000E8   0xF894 0x1030      LDRB     R1,[R4, #+48]
   \   000000EC   0x0002             MOVS     R2,R0
   \   000000EE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F0   0x4291             CMP      R1,R2
   \   000000F2   0xD202             BCS.N    ??OSMutexDel_16
   \   000000F4   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   000000F8   0xE7FF             B.N      ??OSMutexDel_17
    284                               OS_TaskChangePrio(p_tcb_owner, prio_new);
   \                     ??OSMutexDel_16: (+1)
   \                     ??OSMutexDel_17: (+1)
   \   000000FA   0x0001             MOVS     R1,R0
   \   000000FC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       OS_TaskChangePrio
    285                               OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    286                           }
    287                       }
    288          
    289                       OS_MutexClr(p_mutex);
   \                     ??OSMutexDel_15: (+1)
   \   00000104   0x0028             MOVS     R0,R5
   \   00000106   0x.... 0x....      BL       OS_MutexClr
    290                       CPU_CRITICAL_EXIT();
   \   0000010A   0x0038             MOVS     R0,R7
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
    291                       OSSched();                                         /* Find highest priority task ready to run              */
   \   00000110   0x.... 0x....      BL       OSSched
    292                      *p_err = OS_ERR_NONE;
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x8030             STRH     R0,[R6, #+0]
    293                       break;
   \   00000118   0xE005             B.N      ??OSMutexDel_11
    294          
    295                  default:
    296                       CPU_CRITICAL_EXIT();
   \                     ??OSMutexDel_7: (+1)
   \   0000011A   0x0038             MOVS     R0,R7
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
    297                      *p_err = OS_ERR_OPT_INVALID;
   \   00000120   0xF645 0x6025      MOVW     R0,#+24101
   \   00000124   0x8030             STRH     R0,[R6, #+0]
    298                       break;
    299              }
    300              OS_TRACE_MUTEX_DEL_EXIT(*p_err);
    301              return (nbr_tasks);
   \                     ??OSMutexDel_11: (+1)
   \   00000126   0x4640             MOV      R0,R8
   \   00000128   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexDel_1: (+1)
   \   0000012A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    302          }
    303          #endif
    304          
    305          
    306          /*
    307          ************************************************************************************************************************
    308          *                                                    PEND ON MUTEX
    309          *
    310          * Description: This function waits for a mutex.
    311          *
    312          * Arguments  : p_mutex       is a pointer to the mutex
    313          *
    314          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    315          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    316          *                            0, however, your task will wait forever at the specified mutex or, until the resource
    317          *                            becomes available.
    318          *
    319          *              opt           determines whether the user wants to block if the mutex is available or not:
    320          *
    321          *                                OS_OPT_PEND_BLOCKING
    322          *                                OS_OPT_PEND_NON_BLOCKING
    323          *
    324          *              p_ts          is a pointer to a variable that will receive the timestamp of when the mutex was posted or
    325          *                            pend aborted or the mutex deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you
    326          *                            will not get the timestamp.  In other words, passing a NULL pointer is valid and indicates
    327          *                            that you don't need the timestamp.
    328          *
    329          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    330          *
    331          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    332          *                                OS_ERR_MUTEX_OWNER        If calling task already owns the mutex
    333          *                                OS_ERR_MUTEX_OVF          Mutex nesting counter overflowed
    334          *                                OS_ERR_OBJ_DEL            If 'p_mutex' was deleted
    335          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    336          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    337          *                                OS_ERR_OPT_INVALID        If you didn't specify a valid option
    338          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    339          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    340          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    341          *                                                          would lead to a suspension
    342          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the mutex was not
    343          *                                                          available
    344          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    345          *                                OS_ERR_STATUS_INVALID     If the pend status has an invalid value
    346          *                                OS_ERR_TIMEOUT            The mutex was not received within the specified timeout
    347          *                                OS_ERR_TICK_DISABLED      If kernel ticks are disabled and a timeout is specified
    348          *
    349          * Returns    : none
    350          *
    351          * Note(s)    : This API 'MUST NOT' be called from a timer callback function.
    352          ************************************************************************************************************************
    353          */
    354          

   \                                 In section .text, align 2, keep-with-next
    355          void  OSMutexPend (OS_MUTEX  *p_mutex,
    356                             OS_TICK    timeout,
    357                             OS_OPT     opt,
    358                             CPU_TS    *p_ts,
    359                             OS_ERR    *p_err)
    360          {
   \                     OSMutexPend: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x9D06             LDR      R5,[SP, #+24]
    361              OS_TCB  *p_tcb;
    362              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
    363          
    364          
    365          #if (OS_CFG_TS_EN == 0u)
    366              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
    367          #endif
    368          
    369          #ifdef OS_SAFETY_CRITICAL
    370              if (p_err == (OS_ERR *)0) {
    371                  OS_SAFETY_CRITICAL_EXCEPTION();
    372                  return;
    373              }
    374          #endif
    375          
    376              OS_TRACE_MUTEX_PEND_ENTER(p_mutex, timeout, opt, p_ts);
    377          
    378          #if (OS_CFG_TICK_EN == 0u)
    379              if (timeout != 0u) {
    380                 *p_err = OS_ERR_TICK_DISABLED;
    381                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    382                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_TICK_DISABLED);
    383                  return;
    384              }
    385          #endif
    386          
    387          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    388              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSMutexPend_0
    389                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    390                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_PEND_ISR);
    391                 *p_err = OS_ERR_PEND_ISR;
   \   00000018   0xF246 0x10AE      MOVW     R0,#+25006
   \   0000001C   0x8028             STRH     R0,[R5, #+0]
    392                  return;
   \   0000001E   0xE0AC             B.N      ??OSMutexPend_1
    393              }
    394          #endif
    395          
    396          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    397              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSMutexPend_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD003             BEQ.N    ??OSMutexPend_2
    398                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    399                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002A   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    400                  return;
   \   00000030   0xE0A3             B.N      ??OSMutexPend_1
    401              }
    402          #endif
    403          
    404          #if (OS_CFG_ARG_CHK_EN > 0u)
    405              if (p_mutex == (OS_MUTEX *)0) {                             /* Validate arguments                                   */
   \                     ??OSMutexPend_2: (+1)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD103             BNE.N    ??OSMutexPend_3
    406                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    407                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    408                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000036   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    409                  return;
   \   0000003C   0xE09D             B.N      ??OSMutexPend_1
    410              }
    411              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPend_3: (+1)
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD002             BEQ.N    ??OSMutexPend_4
   \   00000046   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000004A   0xD11D             BNE.N    ??OSMutexPend_5
    412                  case OS_OPT_PEND_BLOCKING:
    413                  case OS_OPT_PEND_NON_BLOCKING:
    414                       break;
    415          
    416                  default:
    417                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    418                       OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OPT_INVALID);
    419                      *p_err = OS_ERR_OPT_INVALID;
    420                       return;
    421              }
    422          #endif
    423          
    424          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    425              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPend_4: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable5_1  ;; 0x5854554d
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD11C             BNE.N    ??OSMutexPend_6
    426                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    427                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_OBJ_TYPE);
    428                 *p_err = OS_ERR_OBJ_TYPE;
    429                  return;
    430              }
    431          #endif
    432          
    433              CPU_CRITICAL_ENTER();
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
   \   0000005C   0x4680             MOV      R8,R0
    434              if (p_mutex->OwnerNestingCtr == 0u) {                       /* Resource available?                                  */
   \   0000005E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD119             BNE.N    ??OSMutexPend_7
    435                  p_mutex->OwnerTCBPtr     = OSTCBCurPtr;                 /* Yes, caller may proceed                              */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x6120             STR      R0,[R4, #+16]
    436                  p_mutex->OwnerNestingCtr = 1u;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x7520             STRB     R0,[R4, #+20]
    437          #if (OS_CFG_TS_EN > 0u)
    438                  if (p_ts != (CPU_TS *)0) {
    439                     *p_ts = p_mutex->TS;
    440                  }
    441          #endif
    442                  OS_MutexGrpAdd(OSTCBCurPtr, p_mutex);                   /* Add mutex to owner's group                           */
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x.... 0x....      BL       OS_MutexGrpAdd
    443                  CPU_CRITICAL_EXIT();
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x.... 0x....      BL       CPU_SR_Restore
    444                  OS_TRACE_MUTEX_PEND(p_mutex);
    445                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_NONE);
    446                 *p_err = OS_ERR_NONE;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x8028             STRH     R0,[R5, #+0]
    447                  return;
   \   00000086   0xE078             B.N      ??OSMutexPend_1
    448              }
   \                     ??OSMutexPend_5: (+1)
   \   00000088   0xF645 0x6025      MOVW     R0,#+24101
   \   0000008C   0x8028             STRH     R0,[R5, #+0]
   \   0000008E   0xE074             B.N      ??OSMutexPend_1
   \                     ??OSMutexPend_6: (+1)
   \   00000090   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000094   0x8028             STRH     R0,[R5, #+0]
   \   00000096   0xE070             B.N      ??OSMutexPend_1
    449          
    450              if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {                  /* See if current task is already the owner of the mutex*/
   \                     ??OSMutexPend_7: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x6921             LDR      R1,[R4, #+16]
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD113             BNE.N    ??OSMutexPend_8
    451                  if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)-1) {
   \   000000A4   0x7D20             LDRB     R0,[R4, #+20]
   \   000000A6   0x28FF             CMP      R0,#+255
   \   000000A8   0xD106             BNE.N    ??OSMutexPend_9
    452                      CPU_CRITICAL_EXIT();
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x.... 0x....      BL       CPU_SR_Restore
    453                      OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    454                      OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_MUTEX_OVF);
    455                     *p_err = OS_ERR_MUTEX_OVF;
   \   000000B0   0xF245 0x7084      MOVW     R0,#+22404
   \   000000B4   0x8028             STRH     R0,[R5, #+0]
    456                      return;
   \   000000B6   0xE060             B.N      ??OSMutexPend_1
    457                  }
    458                  p_mutex->OwnerNestingCtr++;
   \                     ??OSMutexPend_9: (+1)
   \   000000B8   0x7D20             LDRB     R0,[R4, #+20]
   \   000000BA   0x1C40             ADDS     R0,R0,#+1
   \   000000BC   0x7520             STRB     R0,[R4, #+20]
    459          #if (OS_CFG_TS_EN > 0u)
    460                  if (p_ts != (CPU_TS *)0) {
    461                     *p_ts = p_mutex->TS;
    462                  }
    463          #endif
    464                  CPU_CRITICAL_EXIT();
   \   000000BE   0x4640             MOV      R0,R8
   \   000000C0   0x.... 0x....      BL       CPU_SR_Restore
    465                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    466                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_MUTEX_OWNER);
    467                 *p_err = OS_ERR_MUTEX_OWNER;                             /* Indicate that current task already owns the mutex    */
   \   000000C4   0xF245 0x7082      MOVW     R0,#+22402
   \   000000C8   0x8028             STRH     R0,[R5, #+0]
    468                  return;
   \   000000CA   0xE056             B.N      ??OSMutexPend_1
    469              }
    470          
    471              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSMutexPend_8: (+1)
   \   000000CC   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000CE   0x0438             LSLS     R0,R7,#+16
   \   000000D0   0xD506             BPL.N    ??OSMutexPend_10
    472                  CPU_CRITICAL_EXIT();
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0x.... 0x....      BL       CPU_SR_Restore
    473          #if (OS_CFG_TS_EN > 0u)
    474                  if (p_ts != (CPU_TS *)0) {
    475                     *p_ts = 0u;
    476                  }
    477          #endif
    478                  OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    479                  OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    480                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \   000000D8   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000DC   0x8028             STRH     R0,[R5, #+0]
    481                  return;
   \   000000DE   0xE04C             B.N      ??OSMutexPend_1
    482              } else {
    483                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSMutexPend_10: (+1)
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable5_4
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD006             BEQ.N    ??OSMutexPend_11
    484                      CPU_CRITICAL_EXIT();
   \   000000EA   0x4640             MOV      R0,R8
   \   000000EC   0x.... 0x....      BL       CPU_SR_Restore
    485          #if (OS_CFG_TS_EN > 0u)
    486                      if (p_ts != (CPU_TS *)0) {
    487                         *p_ts = 0u;
    488                      }
    489          #endif
    490                      OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    491                      OS_TRACE_MUTEX_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    492                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000F0   0xF646 0x5063      MOVW     R0,#+28003
   \   000000F4   0x8028             STRH     R0,[R5, #+0]
    493                      return;
   \   000000F6   0xE040             B.N      ??OSMutexPend_1
    494                  }
    495              }
    496          
    497              p_tcb = p_mutex->OwnerTCBPtr;                               /* Point to the TCB of the Mutex owner                  */
   \                     ??OSMutexPend_11: (+1)
   \   000000F8   0x6920             LDR      R0,[R4, #+16]
    498              if (p_tcb->Prio > OSTCBCurPtr->Prio) {                      /* See if mutex owner has a lower priority than current */
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable5_3
   \   000000FE   0x6809             LDR      R1,[R1, #+0]
   \   00000100   0xF891 0x102F      LDRB     R1,[R1, #+47]
   \   00000104   0xF890 0x202F      LDRB     R2,[R0, #+47]
   \   00000108   0x4291             CMP      R1,R2
   \   0000010A   0xD206             BCS.N    ??OSMutexPend_12
    499                  OS_TaskChangePrio(p_tcb, OSTCBCurPtr->Prio);
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable5_3
   \   00000110   0x6809             LDR      R1,[R1, #+0]
   \   00000112   0xF891 0x102F      LDRB     R1,[R1, #+47]
   \   00000116   0x.... 0x....      BL       OS_TaskChangePrio
    500                  OS_TRACE_MUTEX_TASK_PRIO_INHERIT(p_tcb, p_tcb->Prio);
    501              }
    502          
    503              OS_Pend((OS_PEND_OBJ *)((void *)p_mutex),                   /* Block task pending on Mutex                          */
    504                       OSTCBCurPtr,
    505                       OS_TASK_PEND_ON_MUTEX,
    506                       timeout);
   \                     ??OSMutexPend_12: (+1)
   \   0000011A   0x0033             MOVS     R3,R6
   \   0000011C   0x2204             MOVS     R2,#+4
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000122   0x6801             LDR      R1,[R0, #+0]
   \   00000124   0x0020             MOVS     R0,R4
   \   00000126   0x.... 0x....      BL       OS_Pend
    507          
    508              CPU_CRITICAL_EXIT();
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0x.... 0x....      BL       CPU_SR_Restore
    509              OS_TRACE_MUTEX_PEND_BLOCK(p_mutex);
    510              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   00000130   0x.... 0x....      BL       OSSched
    511          
    512              CPU_CRITICAL_ENTER();
   \   00000134   0x2040             MOVS     R0,#+64
   \   00000136   0x.... 0x....      BL       CPU_SR_Save
    513              switch (OSTCBCurPtr->PendStatus) {
   \   0000013A   0x....             LDR.N    R1,??DataTable5_3
   \   0000013C   0x6809             LDR      R1,[R1, #+0]
   \   0000013E   0xF891 0x102D      LDRB     R1,[R1, #+45]
   \   00000142   0x2900             CMP      R1,#+0
   \   00000144   0xD005             BEQ.N    ??OSMutexPend_13
   \   00000146   0x2902             CMP      R1,#+2
   \   00000148   0xD00E             BEQ.N    ??OSMutexPend_14
   \   0000014A   0xD305             BCC.N    ??OSMutexPend_15
   \   0000014C   0x2903             CMP      R1,#+3
   \   0000014E   0xD007             BEQ.N    ??OSMutexPend_16
   \   00000150   0xE00E             B.N      ??OSMutexPend_17
    514                  case OS_STATUS_PEND_OK:                                 /* We got the mutex                                     */
    515          #if (OS_CFG_TS_EN > 0u)
    516                       if (p_ts != (CPU_TS *)0) {
    517                          *p_ts = OSTCBCurPtr->TS;
    518                       }
    519          #endif
    520                       OS_TRACE_MUTEX_PEND(p_mutex);
    521                      *p_err = OS_ERR_NONE;
   \                     ??OSMutexPend_13: (+1)
   \   00000152   0x2100             MOVS     R1,#+0
   \   00000154   0x8029             STRH     R1,[R5, #+0]
    522                       break;
   \   00000156   0xE00E             B.N      ??OSMutexPend_18
    523          
    524                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    525          #if (OS_CFG_TS_EN > 0u)
    526                       if (p_ts != (CPU_TS *)0) {
    527                          *p_ts = OSTCBCurPtr->TS;
    528                       }
    529          #endif
    530                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    531                      *p_err = OS_ERR_PEND_ABORT;
   \                     ??OSMutexPend_15: (+1)
   \   00000158   0xF246 0x11A9      MOVW     R1,#+25001
   \   0000015C   0x8029             STRH     R1,[R5, #+0]
    532                       break;
   \   0000015E   0xE00A             B.N      ??OSMutexPend_18
    533          
    534                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get mutex within timeout     */
    535          #if (OS_CFG_TS_EN > 0u)
    536                       if (p_ts != (CPU_TS *)0) {
    537                          *p_ts = 0u;
    538                       }
    539          #endif
    540                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    541                      *p_err = OS_ERR_TIMEOUT;
   \                     ??OSMutexPend_16: (+1)
   \   00000160   0xF247 0x21D9      MOVW     R1,#+29401
   \   00000164   0x8029             STRH     R1,[R5, #+0]
    542                       break;
   \   00000166   0xE006             B.N      ??OSMutexPend_18
    543          
    544                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    545          #if (OS_CFG_TS_EN > 0u)
    546                       if (p_ts != (CPU_TS *)0) {
    547                          *p_ts = OSTCBCurPtr->TS;
    548                       }
    549          #endif
    550                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    551                      *p_err = OS_ERR_OBJ_DEL;
   \                     ??OSMutexPend_14: (+1)
   \   00000168   0xF645 0x51C2      MOVW     R1,#+24002
   \   0000016C   0x8029             STRH     R1,[R5, #+0]
    552                       break;
   \   0000016E   0xE002             B.N      ??OSMutexPend_18
    553          
    554                  default:
    555                       OS_TRACE_MUTEX_PEND_FAILED(p_mutex);
    556                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSMutexPend_17: (+1)
   \   00000170   0xF646 0x612E      MOVW     R1,#+28206
   \   00000174   0x8029             STRH     R1,[R5, #+0]
    557                       break;
    558              }
    559              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPend_18: (+1)
   \   00000176   0x.... 0x....      BL       CPU_SR_Restore
    560              OS_TRACE_MUTEX_PEND_EXIT(*p_err);
    561          }
   \                     ??OSMutexPend_1: (+1)
   \   0000017A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    562          
    563          
    564          /*
    565          ************************************************************************************************************************
    566          *                                               ABORT WAITING ON A MUTEX
    567          *
    568          * Description: This function aborts & readies any tasks currently waiting on a mutex.  This function should be used
    569          *              to fault-abort the wait on the mutex, rather than to normally signal the mutex via OSMutexPost().
    570          *
    571          * Arguments  : p_mutex       is a pointer to the mutex
    572          *
    573          *              opt           determines the type of ABORT performed:
    574          *
    575          *                                OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the mutex
    576          *                                OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the mutex
    577          *                                OS_OPT_POST_NO_SCHED         Do not call the scheduler
    578          *
    579          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    580          *
    581          *                                OS_ERR_NONE               At least one task waiting on the mutex was readied and
    582          *                                                          informed of the aborted wait; check return value for the
    583          *                                                          number of tasks whose wait on the mutex was aborted
    584          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    585          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    586          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    587          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    588          *                                OS_ERR_PEND_ABORT_ISR     If you attempted to call this function from an ISR
    589          *                                OS_ERR_PEND_ABORT_NONE    No task were pending
    590          *
    591          * Returns    : == 0          if no tasks were waiting on the mutex, or upon error.
    592          *              >  0          if one or more tasks waiting on the mutex are now readied and informed.
    593          *
    594          * Note(s)    : none
    595          ************************************************************************************************************************
    596          */
    597          
    598          #if (OS_CFG_MUTEX_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    599          OS_OBJ_QTY  OSMutexPendAbort (OS_MUTEX  *p_mutex,
    600                                        OS_OPT     opt,
    601                                        OS_ERR    *p_err)
    602          {
   \                     OSMutexPendAbort: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0015             MOVS     R5,R2
    603              OS_PEND_LIST  *p_pend_list;
    604              OS_TCB        *p_tcb;
    605              OS_TCB        *p_tcb_owner;
    606              CPU_TS         ts;
    607              OS_OBJ_QTY     nbr_tasks;
    608              OS_PRIO        prio_new;
    609              CPU_SR_ALLOC();
   \   00000006   0x2200             MOVS     R2,#+0
    610          
    611          
    612          #ifdef OS_SAFETY_CRITICAL
    613              if (p_err == (OS_ERR *)0) {
    614                  OS_SAFETY_CRITICAL_EXCEPTION();
    615                  return ((OS_OBJ_QTY)0u);
    616              }
    617          #endif
    618          
    619          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    620              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   00000008   0x....             LDR.N    R2,??DataTable5
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD004             BEQ.N    ??OSMutexPendAbort_0
    621                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000010   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000014   0x8028             STRH     R0,[R5, #+0]
    622                  return (0u);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE088             B.N      ??OSMutexPendAbort_1
    623              }
    624          #endif
    625          
    626          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    627              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSMutexPendAbort_0: (+1)
   \   0000001A   0x....             LDR.N    R2,??DataTable5_2
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x2A01             CMP      R2,#+1
   \   00000020   0xD004             BEQ.N    ??OSMutexPendAbort_2
    628                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    629                  return (0u);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE07F             B.N      ??OSMutexPendAbort_1
    630              }
   \                     ??OSMutexPendAbort_2: (+1)
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    631          #endif
    632          
    633          #if (OS_CFG_ARG_CHK_EN > 0u)
    634              if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                   */
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD104             BNE.N    ??OSMutexPendAbort_3
    635                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    636                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE076             B.N      ??OSMutexPendAbort_1
    637              }
   \                     ??OSMutexPendAbort_3: (+1)
   \   0000003E   0x000C             MOVS     R4,R1
    638              switch (opt) {                                              /* Validate 'opt'                                       */
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD008             BEQ.N    ??OSMutexPendAbort_4
   \   00000048   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004C   0xD005             BEQ.N    ??OSMutexPendAbort_4
   \   0000004E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000052   0xD002             BEQ.N    ??OSMutexPendAbort_4
   \   00000054   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000058   0xD115             BNE.N    ??OSMutexPendAbort_5
    639                  case OS_OPT_PEND_ABORT_1:
    640                  case OS_OPT_PEND_ABORT_ALL:
    641                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    642                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    643                       break;
    644          
    645                  default:
    646                      *p_err =  OS_ERR_OPT_INVALID;
    647                       return (0u);
    648              }
    649          #endif
    650          
    651          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    652              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPendAbort_4: (+1)
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x....             LDR.N    R1,??DataTable5_1  ;; 0x5854554d
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD115             BNE.N    ??OSMutexPendAbort_6
    653                 *p_err =  OS_ERR_OBJ_TYPE;
    654                  return (0u);
    655              }
    656          #endif
    657          
    658              CPU_CRITICAL_ENTER();
   \   00000064   0x2040             MOVS     R0,#+64
   \   00000066   0x.... 0x....      BL       CPU_SR_Save
   \   0000006A   0x0007             MOVS     R7,R0
    659              p_pend_list = &p_mutex->PendList;
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x1D06             ADDS     R6,R0,#+4
    660              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on mutex?                           */
   \   00000070   0x6830             LDR      R0,[R6, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD111             BNE.N    ??OSMutexPendAbort_7
    661                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000076   0x0038             MOVS     R0,R7
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
    662                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   0000007C   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000080   0x8028             STRH     R0,[R5, #+0]
    663                  return (0u);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE052             B.N      ??OSMutexPendAbort_1
    664              }
   \                     ??OSMutexPendAbort_5: (+1)
   \   00000086   0xF645 0x6025      MOVW     R0,#+24101
   \   0000008A   0x8028             STRH     R0,[R5, #+0]
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE04D             B.N      ??OSMutexPendAbort_1
   \                     ??OSMutexPendAbort_6: (+1)
   \   00000090   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000094   0x8028             STRH     R0,[R5, #+0]
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE048             B.N      ??OSMutexPendAbort_1
    665          
    666              nbr_tasks = 0u;
   \                     ??OSMutexPendAbort_7: (+1)
   \   0000009A   0xF05F 0x0800      MOVS     R8,#+0
    667          #if (OS_CFG_TS_EN > 0u)
    668              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
    669          #else
    670              ts        = 0u;
   \   0000009E   0xF05F 0x0900      MOVS     R9,#+0
    671          #endif
    672              while (p_pend_list->HeadPtr != (OS_TCB *)0) {
   \                     ??OSMutexPendAbort_8: (+1)
   \   000000A2   0x6830             LDR      R0,[R6, #+0]
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD035             BEQ.N    ??OSMutexPendAbort_9
    673                  p_tcb = p_pend_list->HeadPtr;
   \   000000A8   0xF8D6 0xA000      LDR      R10,[R6, #+0]
    674          
    675                  OS_PendAbort(p_tcb,
    676                               ts,
    677                               OS_STATUS_PEND_ABORT);
   \   000000AC   0x2201             MOVS     R2,#+1
   \   000000AE   0x4649             MOV      R1,R9
   \   000000B0   0x4650             MOV      R0,R10
   \   000000B2   0x.... 0x....      BL       OS_PendAbort
    678                  p_tcb_owner = p_mutex->OwnerTCBPtr;
   \   000000B6   0x9800             LDR      R0,[SP, #+0]
   \   000000B8   0xF8D0 0xB010      LDR      R11,[R0, #+16]
    679                  prio_new    = p_tcb_owner->Prio;
   \   000000BC   0xF89B 0x002F      LDRB     R0,[R11, #+47]
    680                  if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    681                      (p_tcb_owner->Prio == p_tcb->Prio)) {               /* Has the owner inherited a priority?                  */
   \   000000C0   0xF89B 0x102F      LDRB     R1,[R11, #+47]
   \   000000C4   0xF89B 0x2030      LDRB     R2,[R11, #+48]
   \   000000C8   0x4291             CMP      R1,R2
   \   000000CA   0xD011             BEQ.N    ??OSMutexPendAbort_10
   \   000000CC   0xF89B 0x102F      LDRB     R1,[R11, #+47]
   \   000000D0   0xF89A 0x202F      LDRB     R2,[R10, #+47]
   \   000000D4   0x4291             CMP      R1,R2
   \   000000D6   0xD10B             BNE.N    ??OSMutexPendAbort_10
    682                      prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   000000D8   0x4658             MOV      R0,R11
   \   000000DA   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
    683                      prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   000000DE   0xF89B 0x1030      LDRB     R1,[R11, #+48]
   \   000000E2   0x0002             MOVS     R2,R0
   \   000000E4   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000E6   0x4291             CMP      R1,R2
   \   000000E8   0xD202             BCS.N    ??OSMutexPendAbort_11
   \   000000EA   0xF89B 0x0030      LDRB     R0,[R11, #+48]
   \   000000EE   0xE7FF             B.N      ??OSMutexPendAbort_10
    684                  }
    685          
    686                  if(prio_new != p_tcb_owner->Prio) {
   \                     ??OSMutexPendAbort_11: (+1)
   \                     ??OSMutexPendAbort_10: (+1)
   \   000000F0   0x0001             MOVS     R1,R0
   \   000000F2   0xF89B 0x202F      LDRB     R2,[R11, #+47]
   \   000000F6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000F8   0x4291             CMP      R1,R2
   \   000000FA   0xD004             BEQ.N    ??OSMutexPendAbort_12
    687                      OS_TaskChangePrio(p_tcb_owner, prio_new);
   \   000000FC   0x0001             MOVS     R1,R0
   \   000000FE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000100   0x4658             MOV      R0,R11
   \   00000102   0x.... 0x....      BL       OS_TaskChangePrio
    688                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    689                  }
    690          
    691                  nbr_tasks++;
   \                     ??OSMutexPendAbort_12: (+1)
   \   00000106   0xF118 0x0801      ADDS     R8,R8,#+1
    692                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   0000010A   0x0020             MOVS     R0,R4
   \   0000010C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000010E   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000112   0xD0C6             BEQ.N    ??OSMutexPendAbort_8
    693                      break;                                              /* No                                                   */
    694                  }
    695              }
    696              CPU_CRITICAL_EXIT();
   \                     ??OSMutexPendAbort_9: (+1)
   \   00000114   0x0038             MOVS     R0,R7
   \   00000116   0x.... 0x....      BL       CPU_SR_Restore
    697          
    698              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   0000011A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000011C   0x0420             LSLS     R0,R4,#+16
   \   0000011E   0xD401             BMI.N    ??OSMutexPendAbort_13
    699                  OSSched();                                              /* Run the scheduler                                    */
   \   00000120   0x.... 0x....      BL       OSSched
    700              }
    701          
    702             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPendAbort_13: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x8028             STRH     R0,[R5, #+0]
    703              return (nbr_tasks);
   \   00000128   0x4640             MOV      R0,R8
   \   0000012A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSMutexPendAbort_1: (+1)
   \   0000012C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    704          }
    705          #endif
    706          
    707          
    708          /*
    709          ************************************************************************************************************************
    710          *                                                   POST TO A MUTEX
    711          *
    712          * Description: This function signals a mutex.
    713          *
    714          * Arguments  : p_mutex       is a pointer to the mutex
    715          *
    716          *              opt           is an option you can specify to alter the behavior of the post.  The choices are:
    717          *
    718          *                                OS_OPT_POST_NONE        No special option selected
    719          *                                OS_OPT_POST_NO_SCHED    If you don't want the scheduler to be called after the post.
    720          *
    721          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    722          *
    723          *                                OS_ERR_NONE               The call was successful and the mutex was signaled
    724          *                                OS_ERR_MUTEX_NESTING      Mutex owner nested its use of the mutex
    725          *                                OS_ERR_MUTEX_NOT_OWNER    If the task posting is not the Mutex owner
    726          *                                OS_ERR_OBJ_PTR_NULL       If 'p_mutex' is a NULL pointer
    727          *                                OS_ERR_OBJ_TYPE           If 'p_mutex' is not pointing at a mutex
    728          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    729          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    730          *                                OS_ERR_POST_ISR           If you attempted to post from an ISR
    731          *
    732          * Returns    : none
    733          *
    734          * Note(s)    : none
    735          ************************************************************************************************************************
    736          */
    737          

   \                                 In section .text, align 2, keep-with-next
    738          void  OSMutexPost (OS_MUTEX  *p_mutex,
    739                             OS_OPT     opt,
    740                             OS_ERR    *p_err)
    741          {
   \                     OSMutexPost: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    742              OS_PEND_LIST  *p_pend_list;
    743              OS_TCB        *p_tcb;
    744              CPU_TS         ts;
    745              OS_PRIO        prio_new;
    746              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    747          
    748          
    749          #ifdef OS_SAFETY_CRITICAL
    750              if (p_err == (OS_ERR *)0) {
    751                  OS_SAFETY_CRITICAL_EXCEPTION();
    752                  return;
    753              }
    754          #endif
    755          
    756              OS_TRACE_MUTEX_POST_ENTER(p_mutex, opt);
    757          
    758          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    759              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000C   0x....             LDR.N    R0,??DataTable5
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSMutexPost_0
    760                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    761                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_POST_ISR);
    762                 *p_err = OS_ERR_POST_ISR;
   \   00000014   0xF246 0x200E      MOVW     R0,#+25102
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    763                  return;
   \   0000001A   0xE0A5             B.N      ??OSMutexPost_1
    764              }
    765          #endif
    766          
    767          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    768              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSMutexPost_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable5_2
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD003             BEQ.N    ??OSMutexPost_2
    769                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    770                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000024   0xF645 0x6089      MOVW     R0,#+24201
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    771                  return;
   \   0000002A   0xE09D             B.N      ??OSMutexPost_1
    772              }
    773          #endif
    774          
    775          #if (OS_CFG_ARG_CHK_EN > 0u)
    776              if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                   */
   \                     ??OSMutexPost_2: (+1)
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD103             BNE.N    ??OSMutexPost_3
    777                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    778                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    779                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000030   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000034   0x8028             STRH     R0,[R5, #+0]
    780                  return;
   \   00000036   0xE097             B.N      ??OSMutexPost_1
    781              }
    782              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSMutexPost_3: (+1)
   \   00000038   0x0030             MOVS     R0,R6
   \   0000003A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??OSMutexPost_4
   \   00000040   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000044   0xD113             BNE.N    ??OSMutexPost_5
    783                  case OS_OPT_POST_NONE:
    784                  case OS_OPT_POST_NO_SCHED:
    785                       break;
    786          
    787                  default:
    788                       OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    789                       OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OPT_INVALID);
    790                      *p_err =  OS_ERR_OPT_INVALID;
    791                       return;
    792              }
    793          #endif
    794          
    795          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    796              if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                          */
   \                     ??OSMutexPost_4: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable5_1  ;; 0x5854554d
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD113             BNE.N    ??OSMutexPost_6
    797                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    798                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_OBJ_TYPE);
    799                 *p_err = OS_ERR_OBJ_TYPE;
    800                  return;
    801              }
    802          #endif
    803          
    804              CPU_CRITICAL_ENTER();
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x4680             MOV      R8,R0
    805              if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {                  /* Make sure the mutex owner is releasing the mutex     */
   \   00000056   0x....             LDR.N    R0,??DataTable5_3
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x6921             LDR      R1,[R4, #+16]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD00E             BEQ.N    ??OSMutexPost_7
    806                  CPU_CRITICAL_EXIT();
   \   00000060   0x4640             MOV      R0,R8
   \   00000062   0x.... 0x....      BL       CPU_SR_Restore
    807                  OS_TRACE_MUTEX_POST_FAILED(p_mutex);
    808                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_MUTEX_NOT_OWNER);
    809                 *p_err = OS_ERR_MUTEX_NOT_OWNER;
   \   00000066   0xF245 0x7081      MOVW     R0,#+22401
   \   0000006A   0x8028             STRH     R0,[R5, #+0]
    810                  return;
   \   0000006C   0xE07C             B.N      ??OSMutexPost_1
    811              }
   \                     ??OSMutexPost_5: (+1)
   \   0000006E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000072   0x8028             STRH     R0,[R5, #+0]
   \   00000074   0xE078             B.N      ??OSMutexPost_1
   \                     ??OSMutexPost_6: (+1)
   \   00000076   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000007A   0x8028             STRH     R0,[R5, #+0]
   \   0000007C   0xE074             B.N      ??OSMutexPost_1
    812          
    813              OS_TRACE_MUTEX_POST(p_mutex);
    814          
    815          #if (OS_CFG_TS_EN > 0u)
    816              ts          = OS_TS_GET();                                  /* Get timestamp                                        */
    817              p_mutex->TS = ts;
    818          #else
    819              ts          = 0u;
   \                     ??OSMutexPost_7: (+1)
   \   0000007E   0x2700             MOVS     R7,#+0
    820          #endif
    821              p_mutex->OwnerNestingCtr--;                                 /* Decrement owner's nesting counter                    */
   \   00000080   0x7D20             LDRB     R0,[R4, #+20]
   \   00000082   0x1E40             SUBS     R0,R0,#+1
   \   00000084   0x7520             STRB     R0,[R4, #+20]
    822              if (p_mutex->OwnerNestingCtr > 0u) {                        /* Are we done with all nestings?                       */
   \   00000086   0x7D20             LDRB     R0,[R4, #+20]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD006             BEQ.N    ??OSMutexPost_8
    823                  CPU_CRITICAL_EXIT();                                     /* No                                                   */
   \   0000008C   0x4640             MOV      R0,R8
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
    824                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_MUTEX_NESTING);
    825                 *p_err = OS_ERR_MUTEX_NESTING;
   \   00000092   0xF245 0x7083      MOVW     R0,#+22403
   \   00000096   0x8028             STRH     R0,[R5, #+0]
    826                  return;
   \   00000098   0xE066             B.N      ??OSMutexPost_1
    827              }
    828          
    829              OS_MutexGrpRemove(OSTCBCurPtr, p_mutex);                    /* Remove mutex from owner's group                      */
   \                     ??OSMutexPost_8: (+1)
   \   0000009A   0x0021             MOVS     R1,R4
   \   0000009C   0x....             LDR.N    R0,??DataTable5_3
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x.... 0x....      BL       OS_MutexGrpRemove
    830          
    831              p_pend_list = &p_mutex->PendList;
   \   000000A4   0xF114 0x0904      ADDS     R9,R4,#+4
    832              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on mutex?                           */
   \   000000A8   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD109             BNE.N    ??OSMutexPost_9
    833                  p_mutex->OwnerTCBPtr     = (OS_TCB *)0;                 /* No                                                   */
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x6120             STR      R0,[R4, #+16]
    834                  p_mutex->OwnerNestingCtr =           0u;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x7520             STRB     R0,[R4, #+20]
    835                  CPU_CRITICAL_EXIT();
   \   000000B8   0x4640             MOV      R0,R8
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    836                  OS_TRACE_MUTEX_POST_EXIT(OS_ERR_NONE);
    837                 *p_err = OS_ERR_NONE;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x8028             STRH     R0,[R5, #+0]
    838                  return;
   \   000000C2   0xE051             B.N      ??OSMutexPost_1
    839              }
    840                                                                          /* Yes                                                  */
    841              if (OSTCBCurPtr->Prio != OSTCBCurPtr->BasePrio) {           /* Has owner inherited a priority?                      */
   \                     ??OSMutexPost_9: (+1)
   \   000000C4   0x....             LDR.N    R0,??DataTable5_3
   \   000000C6   0x6800             LDR      R0,[R0, #+0]
   \   000000C8   0xF890 0x002F      LDRB     R0,[R0, #+47]
   \   000000CC   0x....             LDR.N    R1,??DataTable5_3
   \   000000CE   0x6809             LDR      R1,[R1, #+0]
   \   000000D0   0xF891 0x1030      LDRB     R1,[R1, #+48]
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD02C             BEQ.N    ??OSMutexPost_10
    842                  prio_new = OS_MutexGrpPrioFindHighest(OSTCBCurPtr);     /* Yes, find highest priority pending                   */
   \   000000D8   0x....             LDR.N    R0,??DataTable5_3
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000E0   0x4682             MOV      R10,R0
    843                  prio_new = (prio_new > OSTCBCurPtr->BasePrio) ? OSTCBCurPtr->BasePrio : prio_new;
   \   000000E2   0x....             LDR.N    R0,??DataTable5_3
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF890 0x0030      LDRB     R0,[R0, #+48]
   \   000000EA   0x4651             MOV      R1,R10
   \   000000EC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD204             BCS.N    ??OSMutexPost_11
   \   000000F2   0x....             LDR.N    R0,??DataTable5_3
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0xF890 0xA030      LDRB     R10,[R0, #+48]
   \   000000FA   0xE7FF             B.N      ??OSMutexPost_12
    844                  if (prio_new > OSTCBCurPtr->Prio) {
   \                     ??OSMutexPost_11: (+1)
   \                     ??OSMutexPost_12: (+1)
   \   000000FC   0x....             LDR.N    R0,??DataTable5_3
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0xF890 0x002F      LDRB     R0,[R0, #+47]
   \   00000104   0x4651             MOV      R1,R10
   \   00000106   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xD212             BCS.N    ??OSMutexPost_10
    845                      OS_RdyListRemove(OSTCBCurPtr);
   \   0000010C   0x....             LDR.N    R0,??DataTable5_3
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0x.... 0x....      BL       OS_RdyListRemove
    846                      OSTCBCurPtr->Prio = prio_new;                       /* Lower owner's priority back to its original one      */
   \   00000114   0x....             LDR.N    R0,??DataTable5_3
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0xF880 0xA02F      STRB     R10,[R0, #+47]
    847                      OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(OSTCBCurPtr, prio_new);
    848                      OS_PrioInsert(prio_new);
   \   0000011C   0x4650             MOV      R0,R10
   \   0000011E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000120   0x.... 0x....      BL       OS_PrioInsert
    849                      OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority           */
   \   00000124   0x....             LDR.N    R0,??DataTable5_3
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0x.... 0x....      BL       OS_RdyListInsertTail
    850                      OSPrioCur         = prio_new;
   \   0000012C   0x....             LDR.N    R0,??DataTable5_5
   \   0000012E   0xF880 0xA000      STRB     R10,[R0, #+0]
    851                  }
    852              }
    853                                                                          /* Get TCB from head of pend list                       */
    854              p_tcb                    = p_pend_list->HeadPtr;
   \                     ??OSMutexPost_10: (+1)
   \   00000132   0xF8D9 0x9000      LDR      R9,[R9, #+0]
    855              p_mutex->OwnerTCBPtr     = p_tcb;                           /* Give mutex to new owner                              */
   \   00000136   0xF8C4 0x9010      STR      R9,[R4, #+16]
    856              p_mutex->OwnerNestingCtr = 1u;
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0x7520             STRB     R0,[R4, #+20]
    857              OS_MutexGrpAdd(p_tcb, p_mutex);
   \   0000013E   0x0021             MOVS     R1,R4
   \   00000140   0x4648             MOV      R0,R9
   \   00000142   0x.... 0x....      BL       OS_MutexGrpAdd
    858                                                                          /* Post to mutex                                        */
    859              OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
    860                                     p_tcb,
    861                                     (void *)0,
    862                                     0u,
    863                                     ts);
   \   00000146   0x9700             STR      R7,[SP, #+0]
   \   00000148   0x2300             MOVS     R3,#+0
   \   0000014A   0x2200             MOVS     R2,#+0
   \   0000014C   0x4649             MOV      R1,R9
   \   0000014E   0x0020             MOVS     R0,R4
   \   00000150   0x.... 0x....      BL       OS_Post
    864          
    865              CPU_CRITICAL_EXIT();
   \   00000154   0x4640             MOV      R0,R8
   \   00000156   0x.... 0x....      BL       CPU_SR_Restore
    866          
    867              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   0000015A   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000015C   0x0430             LSLS     R0,R6,#+16
   \   0000015E   0xD401             BMI.N    ??OSMutexPost_13
    868                  OSSched();                                              /* Run the scheduler                                    */
   \   00000160   0x.... 0x....      BL       OSSched
    869              }
    870              OS_TRACE_MUTEX_POST_EXIT(OS_ERR_NONE);
    871             *p_err = OS_ERR_NONE;
   \                     ??OSMutexPost_13: (+1)
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0x8028             STRH     R0,[R5, #+0]
    872          }
   \                     ??OSMutexPost_1: (+1)
   \   00000168   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    873          
    874          
    875          /*
    876          ************************************************************************************************************************
    877          *                                            CLEAR THE CONTENTS OF A MUTEX
    878          *
    879          * Description: This function is called by OSMutexDel() to clear the contents of a mutex
    880          *
    881          
    882          * Argument(s): p_mutex      is a pointer to the mutex to clear
    883          *              -------
    884          *
    885          * Returns    : none
    886          *
    887          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    888          ************************************************************************************************************************
    889          */
    890          

   \                                 In section .text, align 2, keep-with-next
    891          void  OS_MutexClr (OS_MUTEX  *p_mutex)
    892          {
   \                     OS_MutexClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    893          #if (OS_OBJ_TYPE_REQ > 0u)
    894              p_mutex->Type              =  OS_OBJ_TYPE_NONE;             /* Mark the data structure as a NONE                    */
   \   00000002   0x....             LDR.N    R1,??DataTable5_6  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
    895          #endif
    896          #if (OS_CFG_DBG_EN > 0u)
    897              p_mutex->NamePtr           = (CPU_CHAR *)((void *)"?MUTEX");
    898          #endif
    899              p_mutex->MutexGrpNextPtr   = (OS_MUTEX *)0;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    900              p_mutex->OwnerTCBPtr       = (OS_TCB   *)0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6101             STR      R1,[R0, #+16]
    901              p_mutex->OwnerNestingCtr   =             0u;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7501             STRB     R1,[R0, #+20]
    902          #if (OS_CFG_TS_EN > 0u)
    903              p_mutex->TS                =             0u;
    904          #endif
    905              OS_PendListInit(&p_mutex->PendList);                        /* Initialize the waiting list                          */
   \   00000012   0x1D00             ADDS     R0,R0,#+4
   \   00000014   0x.... 0x....      BL       OS_PendListInit
    906          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    907          
    908          
    909          /*
    910          ************************************************************************************************************************
    911          *                                          ADD/REMOVE MUTEX TO/FROM DEBUG LIST
    912          *
    913          * Description: These functions are called by uC/OS-III to add or remove a mutex to/from the debug list.
    914          *
    915          * Arguments  : p_mutex     is a pointer to the mutex to add/remove
    916          *
    917          * Returns    : none
    918          *
    919          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    920          ************************************************************************************************************************
    921          */
    922          
    923          #if (OS_CFG_DBG_EN > 0u)
    924          void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
    925          {
    926              p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    927              p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    928              if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
    929                  p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
    930              } else {
    931                  p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
    932                  OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
    933              }
    934              OSMutexDbgListPtr                 =  p_mutex;
    935          }
    936          
    937          
    938          void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
    939          {
    940              OS_MUTEX  *p_mutex_next;
    941              OS_MUTEX  *p_mutex_prev;
    942          
    943          
    944              p_mutex_prev = p_mutex->DbgPrevPtr;
    945              p_mutex_next = p_mutex->DbgNextPtr;
    946          
    947              if (p_mutex_prev == (OS_MUTEX *)0) {
    948                  OSMutexDbgListPtr = p_mutex_next;
    949                  if (p_mutex_next != (OS_MUTEX *)0) {
    950                      p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
    951                  }
    952                  p_mutex->DbgNextPtr = (OS_MUTEX *)0;
    953          
    954              } else if (p_mutex_next == (OS_MUTEX *)0) {
    955                  p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
    956                  p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
    957          
    958              } else {
    959                  p_mutex_prev->DbgNextPtr =  p_mutex_next;
    960                  p_mutex_next->DbgPrevPtr =  p_mutex_prev;
    961                  p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
    962                  p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
    963              }
    964          }
    965          #endif
    966          
    967          
    968          /*
    969          ************************************************************************************************************************
    970          *                                               MUTEX GROUP ADD
    971          *
    972          * Description: This function is called by the kernel to add a mutex to a task's mutex group.
    973          *
    974          
    975          * Argument(s): p_tcb        is a pointer to the tcb of the task to give the mutex to.
    976          *
    977          *              p_mutex      is a point to the mutex to add to the group.
    978          *
    979          *
    980          * Returns    : none
    981          *
    982          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    983          ************************************************************************************************************************
    984          */
    985          

   \                                 In section .text, align 2, keep-with-next
    986          void  OS_MutexGrpAdd (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
    987          {
    988              p_mutex->MutexGrpNextPtr = p_tcb->MutexGrpHeadPtr;      /* The mutex grp is not sorted add to head of list.       */
   \                     OS_MutexGrpAdd: (+1)
   \   00000000   0x6B42             LDR      R2,[R0, #+52]
   \   00000002   0x60CA             STR      R2,[R1, #+12]
    989              p_tcb->MutexGrpHeadPtr   = p_mutex;
   \   00000004   0x6341             STR      R1,[R0, #+52]
    990          }
   \   00000006   0x4770             BX       LR               ;; return
    991          
    992          
    993          /*
    994          ************************************************************************************************************************
    995          *                                              MUTEX GROUP REMOVE
    996          *
    997          * Description: This function is called by the kernel to remove a mutex to a task's mutex group.
    998          *
    999          
   1000          * Argument(s): p_tcb        is a pointer to the tcb of the task to remove the mutex from.
   1001          *
   1002          *              p_mutex      is a point to the mutex to remove from the group.
   1003          *
   1004          *
   1005          * Returns    : none
   1006          *
   1007          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1008          ************************************************************************************************************************
   1009          */
   1010          

   \                                 In section .text, align 2, keep-with-next
   1011          void  OS_MutexGrpRemove (OS_TCB  *p_tcb, OS_MUTEX  *p_mutex)
   1012          {
   1013              OS_MUTEX  **pp_mutex;
   1014          
   1015              pp_mutex = &p_tcb->MutexGrpHeadPtr;
   \                     OS_MutexGrpRemove: (+1)
   \   00000000   0x3034             ADDS     R0,R0,#+52
   \   00000002   0xE001             B.N      ??OS_MutexGrpRemove_0
   1016          
   1017              while(*pp_mutex != p_mutex) {
   1018                  pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
   \                     ??OS_MutexGrpRemove_1: (+1)
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x300C             ADDS     R0,R0,#+12
   1019              }
   \                     ??OS_MutexGrpRemove_0: (+1)
   \   00000008   0x6802             LDR      R2,[R0, #+0]
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD1FA             BNE.N    ??OS_MutexGrpRemove_1
   1020          
   1021              *pp_mutex = (*pp_mutex)->MutexGrpNextPtr;
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x68C9             LDR      R1,[R1, #+12]
   \   00000012   0x6001             STR      R1,[R0, #+0]
   1022          }
   \   00000014   0x4770             BX       LR               ;; return
   1023          
   1024          
   1025          /*
   1026          ************************************************************************************************************************
   1027          *                                              MUTEX FIND HIGHEST PENDING
   1028          *
   1029          * Description: This function is called by the kernel to find the highest task pending on any mutex from a group.
   1030          *
   1031          
   1032          * Argument(s): p_tcb        is a pointer to the tcb of the task to process.
   1033          *
   1034          *
   1035          * Returns    : Highest priority pending or OS_CFG_PRIO_MAX - 1u if none found.
   1036          *
   1037          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1038          ************************************************************************************************************************
   1039          */
   1040          

   \                                 In section .text, align 2, keep-with-next
   1041          OS_PRIO  OS_MutexGrpPrioFindHighest (OS_TCB  *p_tcb)
   1042          {
   \                     OS_MutexGrpPrioFindHighest: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   1043              OS_MUTEX  **pp_mutex;
   1044              OS_PRIO     highest_prio;
   1045              OS_PRIO     prio;
   1046              OS_TCB     *p_head;
   1047          
   1048          
   1049              highest_prio = (OS_PRIO)(OS_CFG_PRIO_MAX - 1u);
   \   00000004   0x203F             MOVS     R0,#+63
   1050              pp_mutex = &p_tcb->MutexGrpHeadPtr;
   \   00000006   0xF111 0x0234      ADDS     R2,R1,#+52
   \   0000000A   0xE00F             B.N      ??OS_MutexGrpPrioFindHighest_0
   1051          
   1052              while(*pp_mutex != (OS_MUTEX *)0) {
   1053                  p_head = (*pp_mutex)->PendList.HeadPtr;
   \                     ??OS_MutexGrpPrioFindHighest_1: (+1)
   \   0000000C   0x6811             LDR      R1,[R2, #+0]
   \   0000000E   0x6849             LDR      R1,[R1, #+4]
   1054                  if (p_head != (OS_TCB *)0) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD008             BEQ.N    ??OS_MutexGrpPrioFindHighest_2
   1055                      prio = p_head->Prio;
   \   00000014   0xF891 0x102F      LDRB     R1,[R1, #+47]
   1056                      if(prio < highest_prio) {
   \   00000018   0x000B             MOVS     R3,R1
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x42A3             CMP      R3,R4
   \   00000022   0xD200             BCS.N    ??OS_MutexGrpPrioFindHighest_2
   1057                          highest_prio = prio;
   \   00000024   0x0008             MOVS     R0,R1
   1058                      }
   1059                  }
   1060                  pp_mutex = &(*pp_mutex)->MutexGrpNextPtr;
   \                     ??OS_MutexGrpPrioFindHighest_2: (+1)
   \   00000026   0x6811             LDR      R1,[R2, #+0]
   \   00000028   0xF111 0x020C      ADDS     R2,R1,#+12
   1061              }
   \                     ??OS_MutexGrpPrioFindHighest_0: (+1)
   \   0000002C   0x6811             LDR      R1,[R2, #+0]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD1EC             BNE.N    ??OS_MutexGrpPrioFindHighest_1
   1062          
   1063              return (highest_prio);
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBC10             POP      {R4}
   \   00000036   0x4770             BX       LR               ;; return
   1064          }
   1065          
   1066          
   1067          /*
   1068          ************************************************************************************************************************
   1069          *                                               MUTEX GROUP POST ALL
   1070          *
   1071          * Description: This function is called by the kernel to post (release) all the mutex from a group. Used when deleting
   1072          *              a task.
   1073          *
   1074          
   1075          * Argument(s): p_tcb        is a pointer to the tcb of the task to process.
   1076          *
   1077          *
   1078          * Returns    : none.
   1079          *
   1080          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1081          ************************************************************************************************************************
   1082          */
   1083          

   \                                 In section .text, align 2, keep-with-next
   1084          void  OS_MutexGrpPostAll (OS_TCB  *p_tcb)
   1085          {
   \                     OS_MutexGrpPostAll: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   1086              OS_MUTEX      *p_mutex;
   1087              OS_MUTEX      *p_mutex_next;
   1088              CPU_TS         ts;
   1089              OS_PEND_LIST  *p_pend_list;
   1090              OS_TCB        *p_tcb_new;
   1091          
   1092          
   1093              p_mutex = p_tcb->MutexGrpHeadPtr;
   \   00000006   0x6B6C             LDR      R4,[R5, #+52]
   \   00000008   0xE01F             B.N      ??OS_MutexGrpPostAll_0
   1094          
   1095              while(p_mutex != (OS_MUTEX *)0) {
   1096          
   1097                  OS_TRACE_MUTEX_POST(p_mutex);
   1098          
   1099                  p_mutex_next = p_mutex->MutexGrpNextPtr;
   1100          #if (OS_CFG_TS_EN > 0u)
   1101                  ts           = OS_TS_GET();                             /* Get timestamp                                        */
   1102                  p_mutex->TS  = ts;
   1103          #else
   1104                  ts           = 0u;
   1105          #endif
   1106                  OS_MutexGrpRemove(p_tcb,  p_mutex);                     /* Remove mutex from owner's group                      */
   1107          
   1108                  p_pend_list = &p_mutex->PendList;
   1109                  if (p_pend_list->HeadPtr == (OS_TCB *)0) {              /* Any task waiting on mutex?                           */
   1110                      p_mutex->OwnerNestingCtr =           0u;            /* Decrement owner's nesting counter                    */
   1111                      p_mutex->OwnerTCBPtr     = (OS_TCB *)0;             /* No                                                   */
   1112                  } else {
   1113                                                                          /* Get TCB from head of pend list                       */
   1114                      p_tcb_new                = p_pend_list->HeadPtr;
   \                     ??OS_MutexGrpPostAll_1: (+1)
   \   0000000A   0xF8D1 0x8000      LDR      R8,[R1, #+0]
   1115                      p_mutex->OwnerTCBPtr     = p_tcb;                   /* Give mutex to new owner                              */
   \   0000000E   0x6125             STR      R5,[R4, #+16]
   1116                      p_mutex->OwnerNestingCtr = 1u;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x7520             STRB     R0,[R4, #+20]
   1117                      OS_MutexGrpAdd(p_tcb_new, p_mutex);
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x4640             MOV      R0,R8
   \   00000018   0x.... 0x....      BL       OS_MutexGrpAdd
   1118                                                                          /* Post to mutex                                        */
   1119                      OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
   1120                                             p_tcb_new,
   1121                                             (void *)0,
   1122                                             0u,
   1123                                             ts);
   \   0000001C   0x9700             STR      R7,[SP, #+0]
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       OS_Post
   \   0000002A   0xE00D             B.N      ??OS_MutexGrpPostAll_2
   1124                  }
   \                     ??OS_MutexGrpPostAll_3: (+1)
   \   0000002C   0x68E6             LDR      R6,[R4, #+12]
   \   0000002E   0x2700             MOVS     R7,#+0
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       OS_MutexGrpRemove
   \   00000038   0x1D21             ADDS     R1,R4,#+4
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1E4             BNE.N    ??OS_MutexGrpPostAll_1
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7520             STRB     R0,[R4, #+20]
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6120             STR      R0,[R4, #+16]
   1125          
   1126                  p_mutex = p_mutex_next;
   \                     ??OS_MutexGrpPostAll_2: (+1)
   \   00000048   0x0034             MOVS     R4,R6
   1127              }
   \                     ??OS_MutexGrpPostAll_0: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD1EE             BNE.N    ??OS_MutexGrpPostAll_3
   1128          
   1129          }
   \                     ??OS_MutexGrpPostAll_4: (+1)
   \   0000004E   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x5854554D         DC32     0x5854554d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e
   1130          
   1131          #endif /* OS_CFG_MUTEX_EN */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   OSMutexCreate
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_PendListInit
      32   OSMutexDel
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_MutexClr
        32   -> OS_MutexGrpPrioFindHighest
        32   -> OS_MutexGrpRemove
        32   -> OS_PendAbort
        32   -> OS_TaskChangePrio
      24   OSMutexPend
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_MutexGrpAdd
        24   -> OS_Pend
        24   -> OS_TaskChangePrio
      40   OSMutexPendAbort
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MutexGrpPrioFindHighest
        40   -> OS_PendAbort
        40   -> OS_TaskChangePrio
      40   OSMutexPost
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MutexGrpAdd
        40   -> OS_MutexGrpPrioFindHighest
        40   -> OS_MutexGrpRemove
        40   -> OS_Post
        40   -> OS_PrioInsert
        40   -> OS_RdyListInsertTail
        40   -> OS_RdyListRemove
       8   OS_MutexClr
         8   -> OS_PendListInit
       0   OS_MutexGrpAdd
      32   OS_MutexGrpPostAll
        32   -> OS_MutexGrpAdd
        32   -> OS_MutexGrpRemove
        32   -> OS_Post
       4   OS_MutexGrpPrioFindHighest
       0   OS_MutexGrpRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
     106  OSMutexCreate
     302  OSMutexDel
     382  OSMutexPend
     304  OSMutexPendAbort
     364  OSMutexPost
      26  OS_MutexClr
       8  OS_MutexGrpAdd
      82  OS_MutexGrpPostAll
      56  OS_MutexGrpPrioFindHighest
      22  OS_MutexGrpRemove

 
 1 680 bytes in section .text
 
 1 680 bytes of CODE memory

Errors: none
Warnings: none
