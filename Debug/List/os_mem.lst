###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  11:44:50
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_mem.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW2917.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_mem.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_mem.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_mem.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                      MEMORY PARTITION MANAGEMENT
     20          *
     21          * File    : os_mem.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define   MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_mem__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_MEM_EN > 0u)
     35          /*
     36          ************************************************************************************************************************
     37          *                                               CREATE A MEMORY PARTITION
     38          *
     39          * Description : Create a fixed-sized memory partition that will be managed by uC/OS-III.
     40          *
     41          * Arguments   : p_mem    is a pointer to a memory partition control block which is allocated in user memory space.
     42          *
     43          *               p_name   is a pointer to an ASCII string to provide a name to the memory partition.
     44          *
     45          *               p_addr   is the starting address of the memory partition
     46          *
     47          *               n_blks   is the number of memory blocks to create from the partition.
     48          *
     49          *               blk_size is the size (in bytes) of each block in the memory partition.
     50          *
     51          *               p_err    is a pointer to a variable containing an error message which will be set by this function to
     52          *                        either:
     53          *
     54          *                            OS_ERR_NONE                    If the memory partition has been created correctly
     55          *                            OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the memory partition after you
     56          *                                                             called OSSafetyCriticalStart()
     57          *                            OS_ERR_MEM_CREATE_ISR          If you called this function from an ISR
     58          *                            OS_ERR_MEM_INVALID_BLKS        User specified an invalid number of blocks (must be >= 2)
     59          *                            OS_ERR_MEM_INVALID_P_ADDR      If you are specifying an invalid address for the memory
     60          *                                                           storage of the partition or, the block does not align on a
     61          *                                                           pointer boundary
     62          *                            OS_ERR_MEM_INVALID_SIZE        User specified an invalid block size
     63          *                                                             - must be greater than the size of a pointer
     64          *                                                             - must be able to hold an integral number of pointers
     65          *                            OS_ERR_OBJ_CREATED             If the memory partition was already created
     66          * Returns    : none
     67          *
     68          * Note(s)    : none
     69          ************************************************************************************************************************
     70          */
     71          

   \                                 In section .text, align 2, keep-with-next
     72          void  OSMemCreate (OS_MEM       *p_mem,
     73                             CPU_CHAR     *p_name,
     74                             void         *p_addr,
     75                             OS_MEM_QTY    n_blks,
     76                             OS_MEM_SIZE   blk_size,
     77                             OS_ERR       *p_err)
     78          {
   \                     OSMemCreate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x4698             MOV      R8,R3
   \   0000000A   0x9F07             LDR      R7,[SP, #+28]
     79          #if (OS_CFG_ARG_CHK_EN > 0u)
     80              CPU_DATA       align_msk;
     81          #endif
     82              OS_MEM_QTY     i;
     83              OS_MEM_QTY     loops;
     84              CPU_INT08U    *p_blk;
     85              void         **p_link;
     86              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
     87          
     88          
     89          
     90          #ifdef OS_SAFETY_CRITICAL
     91              if (p_err == (OS_ERR *)0) {
     92                  OS_SAFETY_CRITICAL_EXCEPTION();
     93                  return;
     94              }
     95          #endif
     96          
     97          #ifdef OS_SAFETY_CRITICAL_IEC61508
     98              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     99                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    100                  return;
    101              }
    102          #endif
    103          
    104          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    105              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000E   0x....             LDR.N    R0,??DataTable2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD003             BEQ.N    ??OSMemCreate_0
    106                 *p_err = OS_ERR_MEM_CREATE_ISR;
   \   00000016   0xF245 0x60B9      MOVW     R0,#+22201
   \   0000001A   0x8038             STRH     R0,[R7, #+0]
    107                  return;
   \   0000001C   0xE058             B.N      ??OSMemCreate_1
    108              }
    109          #endif
    110          
    111          #if (OS_CFG_ARG_CHK_EN > 0u)
    112              if (p_addr == (void *)0) {                                  /* Must pass a valid address for the memory part.       */
   \                     ??OSMemCreate_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD103             BNE.N    ??OSMemCreate_2
    113                 *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
   \   00000022   0xF245 0x60BB      MOVW     R0,#+22203
   \   00000026   0x8038             STRH     R0,[R7, #+0]
    114                  return;
   \   00000028   0xE052             B.N      ??OSMemCreate_1
    115              }
    116              if (n_blks < 2u) {                                          /* Must have at least 2 blocks per partition            */
   \                     ??OSMemCreate_2: (+1)
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x2802             CMP      R0,#+2
   \   00000030   0xD203             BCS.N    ??OSMemCreate_3
    117                 *p_err = OS_ERR_MEM_INVALID_BLKS;
   \   00000032   0xF245 0x60BC      MOVW     R0,#+22204
   \   00000036   0x8038             STRH     R0,[R7, #+0]
    118                  return;
   \   00000038   0xE04A             B.N      ??OSMemCreate_1
    119              }
   \                     ??OSMemCreate_3: (+1)
   \   0000003A   0x9D06             LDR      R5,[SP, #+24]
    120              if (blk_size < sizeof(void *)) {                            /* Must contain space for at least a pointer            */
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000040   0x2804             CMP      R0,#+4
   \   00000042   0xD203             BCS.N    ??OSMemCreate_4
    121                 *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   00000044   0xF245 0x60C1      MOVW     R0,#+22209
   \   00000048   0x8038             STRH     R0,[R7, #+0]
    122                  return;
   \   0000004A   0xE041             B.N      ??OSMemCreate_1
    123              }
    124              align_msk = sizeof(void *) - 1u;
   \                     ??OSMemCreate_4: (+1)
   \   0000004C   0x2003             MOVS     R0,#+3
    125              if (align_msk > 0u) {
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD00D             BEQ.N    ??OSMemCreate_5
    126                  if (((CPU_ADDR)p_addr & align_msk) != 0u){              /* Must be pointer size aligned                         */
   \   00000052   0x4204             TST      R4,R0
   \   00000054   0xD003             BEQ.N    ??OSMemCreate_6
    127                     *p_err = OS_ERR_MEM_INVALID_P_ADDR;
   \   00000056   0xF245 0x60BB      MOVW     R0,#+22203
   \   0000005A   0x8038             STRH     R0,[R7, #+0]
    128                      return;
   \   0000005C   0xE038             B.N      ??OSMemCreate_1
    129                  }
    130                  if ((blk_size & align_msk) != 0u) {                     /* Block size must be a multiple address size           */
   \                     ??OSMemCreate_6: (+1)
   \   0000005E   0x0029             MOVS     R1,R5
   \   00000060   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000062   0x4201             TST      R1,R0
   \   00000064   0xD003             BEQ.N    ??OSMemCreate_5
    131                     *p_err = OS_ERR_MEM_INVALID_SIZE;
   \   00000066   0xF245 0x60C1      MOVW     R0,#+22209
   \   0000006A   0x8038             STRH     R0,[R7, #+0]
    132                      return;
   \   0000006C   0xE030             B.N      ??OSMemCreate_1
    133                  }
    134              }
    135          #endif
    136          
    137              p_link = (void **)p_addr;                                   /* Create linked list of free memory blocks             */
   \                     ??OSMemCreate_5: (+1)
   \   0000006E   0x0023             MOVS     R3,R4
    138              p_blk  = (CPU_INT08U *)p_addr;
   \   00000070   0x0022             MOVS     R2,R4
    139              loops  = n_blks - 1u;
   \   00000072   0xF1B8 0x0101      SUBS     R1,R8,#+1
    140              for (i = 0u; i < loops; i++) {
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE006             B.N      ??OSMemCreate_7
    141                  p_blk +=  blk_size;
   \                     ??OSMemCreate_8: (+1)
   \   0000007A   0x46AC             MOV      R12,R5
   \   0000007C   0xFA1F 0xFC8C      UXTH     R12,R12          ;; ZeroExt  R12,R12,#+16,#+16
   \   00000080   0x4462             ADD      R2,R2,R12
    142                 *p_link = (void  *)p_blk;                                /* Save pointer to NEXT block in CURRENT block          */
   \   00000082   0x601A             STR      R2,[R3, #+0]
    143                  p_link = (void **)(void *)p_blk;                        /* Position     to NEXT block                           */
   \   00000084   0x0013             MOVS     R3,R2
    144              }
   \   00000086   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSMemCreate_7: (+1)
   \   00000088   0x4684             MOV      R12,R0
   \   0000008A   0x468E             MOV      LR,R1
   \   0000008C   0xFA1F 0xFC8C      UXTH     R12,R12          ;; ZeroExt  R12,R12,#+16,#+16
   \   00000090   0xFA1F 0xFE8E      UXTH     LR,LR            ;; ZeroExt  LR,LR,#+16,#+16
   \   00000094   0x45F4             CMP      R12,LR
   \   00000096   0xD3F0             BCC.N    ??OSMemCreate_8
    145             *p_link             = (void *)0;                             /* Last memory block points to NULL                     */
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x6018             STR      R0,[R3, #+0]
    146          
    147              CPU_CRITICAL_ENTER();
   \   0000009C   0x2040             MOVS     R0,#+64
   \   0000009E   0x.... 0x....      BL       CPU_SR_Save
    148          #if (OS_OBJ_TYPE_REQ > 0u)
    149          #if (OS_CFG_OBJ_CREATED_CHK_EN > 0u)
    150              if (p_mem->Type == OS_OBJ_TYPE_MEM) {
   \   000000A2   0x6831             LDR      R1,[R6, #+0]
   \   000000A4   0x....             LDR.N    R2,??DataTable2_1  ;; 0x204d454d
   \   000000A6   0x4291             CMP      R1,R2
   \   000000A8   0xD105             BNE.N    ??OSMemCreate_9
    151                  CPU_CRITICAL_EXIT();
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    152                  *p_err = OS_ERR_OBJ_CREATED;
   \   000000AE   0xF645 0x50C1      MOVW     R0,#+24001
   \   000000B2   0x8038             STRH     R0,[R7, #+0]
    153                  return;
   \   000000B4   0xE00C             B.N      ??OSMemCreate_1
    154              }
    155          #endif
    156              p_mem->Type        = OS_OBJ_TYPE_MEM;                       /* Set the type of object                               */
   \                     ??OSMemCreate_9: (+1)
   \   000000B6   0x....             LDR.N    R1,??DataTable2_1  ;; 0x204d454d
   \   000000B8   0x6031             STR      R1,[R6, #+0]
    157          #endif
    158          #if (OS_CFG_DBG_EN > 0u)
    159              p_mem->NamePtr     = p_name;                                /* Save name of memory partition                        */
    160          #else
    161              (void)p_name;
    162          #endif
    163              p_mem->AddrPtr     = p_addr;                                /* Store start address of memory partition              */
   \   000000BA   0x6074             STR      R4,[R6, #+4]
    164              p_mem->FreeListPtr = p_addr;                                /* Initialize pointer to pool of free blocks            */
   \   000000BC   0x60B4             STR      R4,[R6, #+8]
    165              p_mem->NbrFree     = n_blks;                                /* Store number of free blocks in MCB                   */
   \   000000BE   0xF8A6 0x8010      STRH     R8,[R6, #+16]
    166              p_mem->NbrMax      = n_blks;
   \   000000C2   0xF8A6 0x800E      STRH     R8,[R6, #+14]
    167              p_mem->BlkSize     = blk_size;                              /* Store block size of each memory blocks               */
   \   000000C6   0x81B5             STRH     R5,[R6, #+12]
    168          
    169          #if (OS_CFG_DBG_EN > 0u)
    170              OS_MemDbgListAdd(p_mem);
    171              OSMemQty++;
    172          #endif
    173          
    174              OS_TRACE_MEM_CREATE(p_mem, p_name);
    175              CPU_CRITICAL_EXIT();
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
    176             *p_err = OS_ERR_NONE;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x8038             STRH     R0,[R7, #+0]
    177          }
   \                     ??OSMemCreate_1: (+1)
   \   000000D0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    178          
    179          
    180          /*
    181          ************************************************************************************************************************
    182          *                                                  GET A MEMORY BLOCK
    183          *
    184          * Description : Get a memory block from a partition.
    185          *
    186          * Arguments   : p_mem   is a pointer to the memory partition control block
    187          *
    188          *               p_err   is a pointer to a variable containing an error message which will be set by this function to
    189          *                       either:
    190          *
    191          *                           OS_ERR_NONE               If the memory partition has been created correctly
    192          *                           OS_ERR_MEM_INVALID_P_MEM  If you passed a NULL pointer for 'p_mem'
    193          *                           OS_ERR_MEM_NO_FREE_BLKS   If there are no more free memory blocks to allocate to the caller
    194          *                           OS_ERR_OBJ_TYPE           If 'p_mem' is not pointing at a memory partition
    195          *
    196          * Returns    : A pointer to a memory block if no error is detected
    197          *              A pointer to NULL if an error is detected
    198          *
    199          * Note(s)    : none
    200          ************************************************************************************************************************
    201          */
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void  *OSMemGet (OS_MEM  *p_mem,
    204                           OS_ERR  *p_err)
    205          {
   \                     OSMemGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    206              void    *p_blk;
    207              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    208          
    209          
    210          
    211          #ifdef OS_SAFETY_CRITICAL
    212              if (p_err == (OS_ERR *)0) {
    213                  OS_SAFETY_CRITICAL_EXCEPTION();
    214                  return ((void *)0);
    215              }
    216          #endif
    217          
    218              OS_TRACE_MEM_GET_ENTER(p_mem);
    219          
    220          #if (OS_CFG_ARG_CHK_EN > 0u)
    221              if (p_mem == (OS_MEM *)0) {                                 /* Must point to a valid memory partition               */
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD104             BNE.N    ??OSMemGet_0
    222                  OS_TRACE_MEM_GET_FAILED(p_mem);
    223                  OS_TRACE_MEM_GET_EXIT(OS_ERR_MEM_INVALID_P_MEM);
    224                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000C   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000010   0x8028             STRH     R0,[R5, #+0]
    225                  return ((void *)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE020             B.N      ??OSMemGet_1
    226              }
    227          #endif
    228          
    229          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    230              if (p_mem->Type != OS_OBJ_TYPE_MEM) {                       /* Make sure the memory block was created               */
   \                     ??OSMemGet_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable2_1  ;; 0x204d454d
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD004             BEQ.N    ??OSMemGet_2
    231                  OS_TRACE_MEM_GET_EXIT(OS_ERR_OBJ_TYPE);
    232                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000001E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000022   0x8028             STRH     R0,[R5, #+0]
    233                  return ((void *)0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE017             B.N      ??OSMemGet_1
    234              }
    235          #endif
    236          
    237          
    238              CPU_CRITICAL_ENTER();
   \                     ??OSMemGet_2: (+1)
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
    239              if (p_mem->NbrFree == 0u) {                                 /* See if there are any free memory blocks              */
   \   0000002E   0x8A21             LDRH     R1,[R4, #+16]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD106             BNE.N    ??OSMemGet_3
    240                  CPU_CRITICAL_EXIT();
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
    241                  OS_TRACE_MEM_GET_FAILED(p_mem);
    242                  OS_TRACE_MEM_GET_EXIT(OS_ERR_MEM_NO_FREE_BLKS);
    243                 *p_err = OS_ERR_MEM_NO_FREE_BLKS;                        /* No,  Notify caller of empty memory partition         */
   \   00000038   0xF245 0x60C2      MOVW     R0,#+22210
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    244                  return ((void *)0);                                     /* Return NULL pointer to caller                        */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE00A             B.N      ??OSMemGet_1
    245              }
    246              p_blk              = p_mem->FreeListPtr;                    /* Yes, point to next free memory block                 */
   \                     ??OSMemGet_3: (+1)
   \   00000042   0x68A6             LDR      R6,[R4, #+8]
    247              p_mem->FreeListPtr = *(void **)p_blk;                       /* Adjust pointer to new free list                      */
   \   00000044   0x6831             LDR      R1,[R6, #+0]
   \   00000046   0x60A1             STR      R1,[R4, #+8]
    248              p_mem->NbrFree--;                                           /* One less memory block in this partition              */
   \   00000048   0x8A21             LDRH     R1,[R4, #+16]
   \   0000004A   0x1E49             SUBS     R1,R1,#+1
   \   0000004C   0x8221             STRH     R1,[R4, #+16]
    249              CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Restore
    250              OS_TRACE_MEM_GET(p_mem);
    251              OS_TRACE_MEM_GET_EXIT(OS_ERR_NONE);
    252             *p_err = OS_ERR_NONE;                                        /* No error                                             */
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x8028             STRH     R0,[R5, #+0]
    253              return (p_blk);                                             /* Return memory block to caller                        */
   \   00000056   0x0030             MOVS     R0,R6
   \                     ??OSMemGet_1: (+1)
   \   00000058   0xBD70             POP      {R4-R6,PC}       ;; return
    254          }
    255          
    256          
    257          /*
    258          ************************************************************************************************************************
    259          *                                                 RELEASE A MEMORY BLOCK
    260          *
    261          * Description : Returns a memory block to a partition.
    262          *
    263          * Arguments   : p_mem    is a pointer to the memory partition control block
    264          *
    265          *               p_blk    is a pointer to the memory block being released.
    266          *
    267          *               p_err    is a pointer to a variable that will contain an error code returned by this function.
    268          *
    269          *                            OS_ERR_NONE               If the memory block was inserted into the partition
    270          *                            OS_ERR_MEM_FULL           If you are returning a memory block to an already FULL memory
    271          *                                                      partition (You freed more blocks than you allocated!)
    272          *                            OS_ERR_MEM_INVALID_P_BLK  If you passed a NULL pointer for the block to release.
    273          *                            OS_ERR_MEM_INVALID_P_MEM  If you passed a NULL pointer for 'p_mem'
    274          *                            OS_ERR_OBJ_TYPE           If 'p_mem' is not pointing at a memory partition
    275          *
    276          * Returns    : none
    277          *
    278          * Note(s)    : none
    279          ************************************************************************************************************************
    280          */
    281          

   \                                 In section .text, align 2, keep-with-next
    282          void  OSMemPut (OS_MEM  *p_mem,
    283                          void    *p_blk,
    284                          OS_ERR  *p_err)
    285          {
   \                     OSMemPut: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    286              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
    287          
    288          
    289          
    290          #ifdef OS_SAFETY_CRITICAL
    291              if (p_err == (OS_ERR *)0) {
    292                  OS_SAFETY_CRITICAL_EXCEPTION();
    293                  return;
    294              }
    295          #endif
    296          
    297              OS_TRACE_MEM_PUT_ENTER(p_mem, p_blk);
    298          
    299          #if (OS_CFG_ARG_CHK_EN > 0u)
    300              if (p_mem == (OS_MEM *)0) {                                 /* Must point to a valid memory partition               */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD103             BNE.N    ??OSMemPut_0
    301                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    302                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_INVALID_P_MEM);
    303                 *p_err  = OS_ERR_MEM_INVALID_P_MEM;
   \   0000000E   0xF245 0x60BF      MOVW     R0,#+22207
   \   00000012   0x8030             STRH     R0,[R6, #+0]
    304                  return;
   \   00000014   0xE024             B.N      ??OSMemPut_1
    305              }
    306              if (p_blk == (void *)0) {                                   /* Must release a valid block                           */
   \                     ??OSMemPut_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD103             BNE.N    ??OSMemPut_2
    307                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    308                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_INVALID_P_BLK);
    309                 *p_err  = OS_ERR_MEM_INVALID_P_BLK;
   \   0000001A   0xF245 0x60BE      MOVW     R0,#+22206
   \   0000001E   0x8030             STRH     R0,[R6, #+0]
    310                  return;
   \   00000020   0xE01E             B.N      ??OSMemPut_1
    311              }
    312          #endif
    313          
    314          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    315              if (p_mem->Type != OS_OBJ_TYPE_MEM) {                       /* Make sure the memory block was created               */
   \                     ??OSMemPut_2: (+1)
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable2_1  ;; 0x204d454d
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD003             BEQ.N    ??OSMemPut_3
    316                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_OBJ_TYPE);
    317                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000002E   0x8030             STRH     R0,[R6, #+0]
    318                  return;
   \   00000030   0xE016             B.N      ??OSMemPut_1
    319              }
    320          #endif
    321          
    322          
    323              CPU_CRITICAL_ENTER();
   \                     ??OSMemPut_3: (+1)
   \   00000032   0x2040             MOVS     R0,#+64
   \   00000034   0x.... 0x....      BL       CPU_SR_Save
    324              if (p_mem->NbrFree >= p_mem->NbrMax) {                      /* Make sure all blocks not already returned            */
   \   00000038   0x8A21             LDRH     R1,[R4, #+16]
   \   0000003A   0x89E2             LDRH     R2,[R4, #+14]
   \   0000003C   0x4291             CMP      R1,R2
   \   0000003E   0xD305             BCC.N    ??OSMemPut_4
    325                  CPU_CRITICAL_EXIT();
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    326                  OS_TRACE_MEM_PUT_FAILED(p_mem);
    327                  OS_TRACE_MEM_PUT_EXIT(OS_ERR_MEM_FULL);
    328                 *p_err = OS_ERR_MEM_FULL;
   \   00000044   0xF245 0x60BA      MOVW     R0,#+22202
   \   00000048   0x8030             STRH     R0,[R6, #+0]
    329                  return;
   \   0000004A   0xE009             B.N      ??OSMemPut_1
    330              }
    331              *(void **)p_blk    = p_mem->FreeListPtr;                    /* Insert released block into free block list           */
   \                     ??OSMemPut_4: (+1)
   \   0000004C   0x68A1             LDR      R1,[R4, #+8]
   \   0000004E   0x6029             STR      R1,[R5, #+0]
    332              p_mem->FreeListPtr = p_blk;
   \   00000050   0x60A5             STR      R5,[R4, #+8]
    333              p_mem->NbrFree++;                                           /* One more memory block in this partition              */
   \   00000052   0x8A21             LDRH     R1,[R4, #+16]
   \   00000054   0x1C49             ADDS     R1,R1,#+1
   \   00000056   0x8221             STRH     R1,[R4, #+16]
    334              CPU_CRITICAL_EXIT();
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    335              OS_TRACE_MEM_PUT(p_mem);
    336              OS_TRACE_MEM_PUT_EXIT(OS_ERR_NONE);
    337             *p_err              = OS_ERR_NONE;                           /* Notify caller that memory block was released         */
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8030             STRH     R0,[R6, #+0]
    338          }
   \                     ??OSMemPut_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    339          
    340          
    341          /*
    342          ************************************************************************************************************************
    343          *                                           ADD MEMORY PARTITION TO DEBUG LIST
    344          *
    345          * Description : This function is called by OSMemCreate() to add the memory partition to the debug table.
    346          *
    347          * Arguments   : p_mem    Is a pointer to the memory partition
    348          *
    349          * Returns     : none
    350          *
    351          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    352          ************************************************************************************************************************
    353          */
    354          
    355          #if (OS_CFG_DBG_EN > 0u)
    356          void  OS_MemDbgListAdd (OS_MEM  *p_mem)
    357          {
    358              p_mem->DbgPrevPtr               = (OS_MEM *)0;
    359              if (OSMemDbgListPtr == (OS_MEM *)0) {
    360                  p_mem->DbgNextPtr           = (OS_MEM *)0;
    361              } else {
    362                  p_mem->DbgNextPtr           =  OSMemDbgListPtr;
    363                  OSMemDbgListPtr->DbgPrevPtr =  p_mem;
    364              }
    365              OSMemDbgListPtr                 =  p_mem;
    366          }
    367          #endif
    368          
    369          
    370          /*
    371          ************************************************************************************************************************
    372          *                                           INITIALIZE MEMORY PARTITION MANAGER
    373          *
    374          * Description : This function is called by uC/OS-III to initialize the memory partition manager.  Your
    375          *               application MUST NOT call this function.
    376          *
    377          * Arguments   : none
    378          *
    379          * Returns     : none
    380          *
    381          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
    382          ************************************************************************************************************************
    383          */
    384          

   \                                 In section .text, align 2, keep-with-next
    385          void  OS_MemInit (OS_ERR  *p_err)
    386          {
    387          #if (OS_CFG_DBG_EN > 0u)
    388              OSMemDbgListPtr = (OS_MEM *)0;
    389              OSMemQty        = 0u;
    390          #endif
    391             *p_err           = OS_ERR_NONE;
   \                     OS_MemInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    392          }
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x204D454D         DC32     0x204d454d
    393          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSMemCreate
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSMemGet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSMemPut
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       0   OS_MemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
     212  OSMemCreate
      90  OSMemGet
      98  OSMemPut
       6  OS_MemInit

 
 414 bytes in section .text
 
 414 bytes of CODE memory

Errors: none
Warnings: none
