###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  17:49:09
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\bsp.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EWB6EC.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\bsp.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\bsp.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\bsp.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\bsp.c
      1          #include "bsp.h"
      2          #include <stdio.h>
      3          #include "bluetooth.h"
      4          #include "stm32f10x_usart.h"
      5          

   \                                 In section .text, align 2, keep-with-next
      6          void GPIO_Configuration(void) {
   \                     GPIO_Configuration: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
      7              GPIO_InitTypeDef GPIO_InitStructure;
      8          
      9              // Enable Clocks (Updated for new pins)
     10              // PIR/Touch/Light -> GPIOC, Servo -> GPIOB, LED -> GPIOD
     11              RCC_APB2PeriphClockCmd(PIR_RCC | TOUCH_RCC | LIGHT_RCC | SERVO_RCC_GPIO | LED_RCC | 
     12                                     RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF244 0x003D      MOVW     R0,#+16445
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     13              RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000012   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     14          
     15              // PIR Sensor (PC1) - Input Pull-down
     16              GPIO_InitStructure.GPIO_Pin = PIR_PIN;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     17              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   0000001C   0x2028             MOVS     R0,#+40
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
     18              GPIO_Init(PIR_PORT, &GPIO_InitStructure);
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40011000
   \   00000028   0x.... 0x....      BL       GPIO_Init
     19          
     20              // Touch Sensor (PC2) - Input Pull-down
     21              GPIO_InitStructure.GPIO_Pin = TOUCH_PIN;
   \   0000002C   0x2004             MOVS     R0,#+4
   \   0000002E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     22              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   00000032   0x2028             MOVS     R0,#+40
   \   00000034   0xF88D 0x0003      STRB     R0,[SP, #+3]
     23              GPIO_Init(TOUCH_PORT, &GPIO_InitStructure);
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable9  ;; 0x40011000
   \   0000003E   0x.... 0x....      BL       GPIO_Init
     24          
     25              // Light Sensor (PC0/ADC) - Analog Input
     26              GPIO_InitStructure.GPIO_Pin = LIGHT_PIN;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     27              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     28              GPIO_Init(LIGHT_PORT, &GPIO_InitStructure);
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40010c00
   \   00000054   0x.... 0x....      BL       GPIO_Init
     29          
     30              // Servo Motor (PB6/TIM4_CH1) - Alt Function Push Pull
     31              GPIO_InitStructure.GPIO_Pin = SERVO_PIN;
   \   00000058   0x2040             MOVS     R0,#+64
   \   0000005A   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     32              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000005E   0x2018             MOVS     R0,#+24
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
     33              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000064   0x2003             MOVS     R0,#+3
   \   00000066   0xF88D 0x0002      STRB     R0,[SP, #+2]
     34              GPIO_Init(SERVO_PORT, &GPIO_InitStructure);
   \   0000006A   0x4669             MOV      R1,SP
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40010c00
   \   00000070   0x.... 0x....      BL       GPIO_Init
     35          
     36              // LEDs (PD3, PD4) - Output Push Pull
     37              GPIO_InitStructure.GPIO_Pin = LED1_PIN | LED2_PIN;
   \   00000074   0x2018             MOVS     R0,#+24
   \   00000076   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     38              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000007A   0x2010             MOVS     R0,#+16
   \   0000007C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     39              GPIO_Init(LED_PORT, &GPIO_InitStructure);
   \   00000080   0x4669             MOV      R1,SP
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40011400
   \   00000086   0x.... 0x....      BL       GPIO_Init
     40          
     41              // --- USART1 (PC) & USART2 (Bluetooth) GPIO Configuration ---
     42              
     43              /* USART1 TX (PA9) -> Alternate Function Push-Pull */
     44              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000008A   0xF44F 0x7000      MOV      R0,#+512
   \   0000008E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     45              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000092   0x2003             MOVS     R0,#+3
   \   00000094   0xF88D 0x0002      STRB     R0,[SP, #+2]
     46              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000098   0x2018             MOVS     R0,#+24
   \   0000009A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     47              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000009E   0x4669             MOV      R1,SP
   \   000000A0   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40010800
   \   000000A2   0x.... 0x....      BL       GPIO_Init
     48          
     49              /* USART1 RX (PA10) -> Input Pull-Up */
     50              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   000000A6   0xF44F 0x6080      MOV      R0,#+1024
   \   000000AA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     51              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   000000AE   0x2048             MOVS     R0,#+72
   \   000000B0   0xF88D 0x0003      STRB     R0,[SP, #+3]
     52              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000B4   0x4669             MOV      R1,SP
   \   000000B6   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40010800
   \   000000B8   0x.... 0x....      BL       GPIO_Init
     53          
     54              /* USART2 TX (PA2) -> Alternate Function Push-Pull */
     55              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   000000BC   0x2004             MOVS     R0,#+4
   \   000000BE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     56              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000C2   0x2003             MOVS     R0,#+3
   \   000000C4   0xF88D 0x0002      STRB     R0,[SP, #+2]
     57              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   000000C8   0x2018             MOVS     R0,#+24
   \   000000CA   0xF88D 0x0003      STRB     R0,[SP, #+3]
     58              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000CE   0x4669             MOV      R1,SP
   \   000000D0   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40010800
   \   000000D2   0x.... 0x....      BL       GPIO_Init
     59          
     60              /* USART2 RX (PA3) -> Input Pull-Up */
     61              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   000000D6   0x2008             MOVS     R0,#+8
   \   000000D8   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     62              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   000000DC   0x2048             MOVS     R0,#+72
   \   000000DE   0xF88D 0x0003      STRB     R0,[SP, #+3]
     63              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   000000E2   0x4669             MOV      R1,SP
   \   000000E4   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40010800
   \   000000E6   0x.... 0x....      BL       GPIO_Init
     64          }
   \   000000EA   0xBD01             POP      {R0,PC}          ;; return
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void ADC_Configuration(void) {
   \                     ADC_Configuration: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
     67              ADC_InitTypeDef ADC_InitStructure;
     68              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF44F 0x7000      MOV      R0,#+512
   \   0000000A   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     69          
     70              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9000             STR      R0,[SP, #+0]
     71              ADC_InitStructure.ADC_ScanConvMode = DISABLE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0004      STRB     R0,[SP, #+4]
     72              ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0005      STRB     R0,[SP, #+5]
     73              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   0000001E   0xF45F 0x2060      MOVS     R0,#+917504
   \   00000022   0x9002             STR      R0,[SP, #+8]
     74              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9003             STR      R0,[SP, #+12]
     75              ADC_InitStructure.ADC_NbrOfChannel = 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF88D 0x0010      STRB     R0,[SP, #+16]
     76              ADC_Init(ADC1, &ADC_InitStructure);
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000032   0x.... 0x....      BL       ADC_Init
     77          
     78              ADC_Cmd(ADC1, ENABLE);
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   0000003A   0x.... 0x....      BL       ADC_Cmd
     79              
     80              // Calibration
     81              ADC_ResetCalibration(ADC1);
   \   0000003E   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000040   0x.... 0x....      BL       ADC_ResetCalibration
     82              while(ADC_GetResetCalibrationStatus(ADC1));
   \                     ??ADC_Configuration_0: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000046   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD1FA             BNE.N    ??ADC_Configuration_0
     83              ADC_StartCalibration(ADC1);
   \   0000004E   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000050   0x.... 0x....      BL       ADC_StartCalibration
     84              while(ADC_GetCalibrationStatus(ADC1));
   \                     ??ADC_Configuration_1: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000056   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1FA             BNE.N    ??ADC_Configuration_1
     85          }
   \   0000005E   0xB005             ADD      SP,SP,#+20
   \   00000060   0xBD00             POP      {PC}             ;; return
     86          

   \                                 In section .text, align 2, keep-with-next
     87          void TIM_Configuration(void) {
   \                     TIM_Configuration: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
     88              // Servo Motor using TIM4 CH1 (PB6)
     89              TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
     90              TIM_OCInitTypeDef  TIM_OCInitStructure;
     91          
     92              // TIM4 is on APB1
     93              RCC_APB1PeriphClockCmd(SERVO_RCC_TIM, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x2004             MOVS     R0,#+4
   \   00000008   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     94          
     95              // PWM Frequency = 50Hz (20ms Period) for Servo
     96              // SystemCoreClock is usually 72MHz. 
     97              // TIM4 (APB1) -> PCLK1 * 2 if APB1 prescaler != 1. Assuming 72MHz.
     98              // Prescaler = 71 -> 1MHz Timer Clock (1us tick)
     99              // Period = 20000 -> 20ms
    100              TIM_TimeBaseStructure.TIM_Period = 20000 - 1; 
   \   0000000C   0xF644 0x601F      MOVW     R0,#+19999
   \   00000010   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    101              TIM_TimeBaseStructure.TIM_Prescaler = 72 - 1;
   \   00000014   0x2047             MOVS     R0,#+71
   \   00000016   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    102              TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    103              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    104              TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF88D 0x0008      STRB     R0,[SP, #+8]
    105              TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40000800
   \   00000030   0x.... 0x....      BL       TIM_TimeBaseInit
    106          
    107              // PWM Channel 1 Configuration
    108              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \   00000034   0x2060             MOVS     R0,#+96
   \   00000036   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    109              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    110              TIM_OCInitStructure.TIM_Pulse = 1500; // 1.5ms (Center/90deg)
   \   00000040   0xF240 0x50DC      MOVW     R0,#+1500
   \   00000044   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    111              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    112              TIM_OC1Init(TIM4, &TIM_OCInitStructure);
   \   0000004E   0xA903             ADD      R1,SP,#+12
   \   00000050   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40000800
   \   00000052   0x.... 0x....      BL       TIM_OC1Init
    113              TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
   \   00000056   0x2108             MOVS     R1,#+8
   \   00000058   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40000800
   \   0000005A   0x.... 0x....      BL       TIM_OC1PreloadConfig
    114          
    115              // TIM4 does not need TIM_CtrlPWMOutputs (Only TIM1/TIM8 do)
    116              TIM_Cmd(TIM4, ENABLE);
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40000800
   \   00000062   0x.... 0x....      BL       TIM_Cmd
    117          }
   \   00000066   0xB007             ADD      SP,SP,#+28
   \   00000068   0xBD00             POP      {PC}             ;; return
    118          

   \                                 In section .text, align 2, keep-with-next
    119          void EXTI_Configuration(void) {
   \                     EXTI_Configuration: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    120              EXTI_InitTypeDef EXTI_InitStructure;
    121              
    122              // Connect EXTI Line to Touch Pin
    123              GPIO_EXTILineConfig(TOUCH_PortSource, TOUCH_PinSource);
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       GPIO_EXTILineConfig
    124          
    125              EXTI_InitStructure.EXTI_Line = TOUCH_EXTI_Line;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x9000             STR      R0,[SP, #+0]
    126              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0004      STRB     R0,[SP, #+4]
    127              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising; // Touch triggers on rise
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
    128              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF88D 0x0006      STRB     R0,[SP, #+6]
    129              EXTI_Init(&EXTI_InitStructure);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       EXTI_Init
    130          }
   \   00000026   0xBD07             POP      {R0-R2,PC}       ;; return
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void NVIC_Configuration(void) {
   \                     NVIC_Configuration: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    133              NVIC_InitTypeDef NVIC_InitStructure;
    134          
    135              // Enable Touch Interrupt
    136              NVIC_InitStructure.NVIC_IRQChannel = TOUCH_IRQn;
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0xF88D 0x0000      STRB     R0,[SP, #+0]
    137              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x0F; 
   \   00000008   0x200F             MOVS     R0,#+15
   \   0000000A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    138              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x0F;
   \   0000000E   0x200F             MOVS     R0,#+15
   \   00000010   0xF88D 0x0002      STRB     R0,[SP, #+2]
    139              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xF88D 0x0003      STRB     R0,[SP, #+3]
    140              NVIC_Init(&NVIC_InitStructure);
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x.... 0x....      BL       NVIC_Init
    141          
    142              /* USART1 Interrupt */
    143              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   00000020   0x2025             MOVS     R0,#+37
   \   00000022   0xF88D 0x0000      STRB     R0,[SP, #+0]
    144              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xF88D 0x0001      STRB     R0,[SP, #+1]
    145              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    146              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF88D 0x0003      STRB     R0,[SP, #+3]
    147              NVIC_Init(&NVIC_InitStructure);
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x.... 0x....      BL       NVIC_Init
    148          
    149              /* USART2 Interrupt */
    150              NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \   0000003E   0x2026             MOVS     R0,#+38
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
    151              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xF88D 0x0001      STRB     R0,[SP, #+1]
    152              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    153              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xF88D 0x0003      STRB     R0,[SP, #+3]
    154              NVIC_Init(&NVIC_InitStructure);
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       NVIC_Init
    155          }
   \   0000005C   0xBD01             POP      {R0,PC}          ;; return
    156          

   \                                 In section .text, align 2, keep-with-next
    157          void USART_Configuration(void) {
    158              // Bluetooth UART (USART2) initialization is handled in USART2_Init()
    159              // PC UART (USART1) initialization is handled in USART1_Init()
    160          }
   \                     USART_Configuration: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    161          

   \                                 In section .text, align 2, keep-with-next
    162          void USART1_Init(void) {
   \                     USART1_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    163              USART_InitTypeDef USART1_InitStructure;
    164          
    165              USART1_InitStructure.USART_BaudRate = 9600;
   \   00000002   0xF44F 0x5016      MOV      R0,#+9600
   \   00000006   0x9000             STR      R0,[SP, #+0]
    166              USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    167              USART1_InitStructure.USART_StopBits = USART_StopBits_1_5;
   \   0000000E   0xF44F 0x5040      MOV      R0,#+12288
   \   00000012   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    168              USART1_InitStructure.USART_Parity = USART_Parity_No;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    169              USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    170              USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    171          
    172              USART_Init(USART1, &USART1_InitStructure);
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   0000002C   0x.... 0x....      BL       USART_Init
    173          
    174              /* RX Interrupt Enable */
    175              USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0xF240 0x5125      MOVW     R1,#+1317
   \   00000036   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000038   0x.... 0x....      BL       USART_ITConfig
    176          
    177              /* Enable USART1 */
    178              USART_Cmd(USART1, ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x....             LDR.N    R0,??DataTable9_6  ;; 0x40013800
   \   00000040   0x.... 0x....      BL       USART_Cmd
    179          }
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xBD00             POP      {PC}             ;; return
    180          

   \                                 In section .text, align 2, keep-with-next
    181          void USART2_Init(void) {
   \                     USART2_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    182              USART_InitTypeDef USART2_InitStructure;
    183          
    184              USART2_InitStructure.USART_BaudRate = 9600;
   \   00000002   0xF44F 0x5016      MOV      R0,#+9600
   \   00000006   0x9000             STR      R0,[SP, #+0]
    185              USART2_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    186              USART2_InitStructure.USART_StopBits = USART_StopBits_1_5;
   \   0000000E   0xF44F 0x5040      MOV      R0,#+12288
   \   00000012   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    187              USART2_InitStructure.USART_Parity = USART_Parity_No;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    188              USART2_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    189              USART2_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    190          
    191              USART_Init(USART2, &USART2_InitStructure);
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   0000002C   0x.... 0x....      BL       USART_Init
    192          
    193              /* RX Interrupt Enable */
    194              USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0xF240 0x5125      MOVW     R1,#+1317
   \   00000036   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   00000038   0x.... 0x....      BL       USART_ITConfig
    195          
    196              /* Enable USART2 */
    197              USART_Cmd(USART2, ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   00000040   0x.... 0x....      BL       USART_Cmd
    198          }
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xBD00             POP      {PC}             ;; return
    199          

   \                                 In section .text, align 2, keep-with-next
    200          void BSP_Init(void) {
   \                     BSP_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    201              GPIO_Configuration();
   \   00000002   0x.... 0x....      BL       GPIO_Configuration
    202              ADC_Configuration();
   \   00000006   0x.... 0x....      BL       ADC_Configuration
    203              TIM_Configuration();
   \   0000000A   0x.... 0x....      BL       TIM_Configuration
    204              EXTI_Configuration();
   \   0000000E   0x.... 0x....      BL       EXTI_Configuration
    205              LCD_Init();
                     ^
Warning[Pe223]: function "LCD_Init" declared implicitly
   \   00000012   0x.... 0x....      BL       LCD_Init
    206              LCD_Init();
   \   00000016   0x.... 0x....      BL       LCD_Init
    207              // Bluetooth_Init(); // Removed old init
    208              USART1_Init();       // PC Communications
   \   0000001A   0x.... 0x....      BL       USART1_Init
    209              USART2_Init();       // Bluetooth Communications
   \   0000001E   0x.... 0x....      BL       USART2_Init
    210              NVIC_Configuration();
   \   00000022   0x.... 0x....      BL       NVIC_Configuration
    211          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    212          
    213          // --- Hardware Abstraction ---
    214          

   \                                 In section .text, align 2, keep-with-next
    215          void Servo_SetAngle(uint8_t angle) {
   \                     Servo_SetAngle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    216              uint16_t pulse = 500; // Default 0
   \   00000002   0xF44F 0x71FA      MOV      R1,#+500
    217              if (angle == 90) pulse = 1500;
   \   00000006   0x0002             MOVS     R2,R0
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2A5A             CMP      R2,#+90
   \   0000000C   0xD102             BNE.N    ??Servo_SetAngle_0
   \   0000000E   0xF240 0x51DC      MOVW     R1,#+1500
   \   00000012   0xE004             B.N      ??Servo_SetAngle_1
    218              else if (angle == 0) pulse = 500;
   \                     ??Servo_SetAngle_0: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??Servo_SetAngle_1
   \   0000001A   0xF44F 0x71FA      MOV      R1,#+500
    219              
    220              TIM_SetCompare1(TIM4, pulse);
   \                     ??Servo_SetAngle_1: (+1)
   \   0000001E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000020   0x....             LDR.N    R0,??DataTable9_5  ;; 0x40000800
   \   00000022   0x.... 0x....      BL       TIM_SetCompare1
    221          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void LED_Set(uint8_t led, uint8_t state) {
   \                     LED_Set: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    224              uint16_t pin = (led == 1) ? LED1_PIN : LED2_PIN;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??LED_Set_0
   \   00000008   0x2008             MOVS     R0,#+8
   \   0000000A   0xE000             B.N      ??LED_Set_1
   \                     ??LED_Set_0: (+1)
   \   0000000C   0x2010             MOVS     R0,#+16
    225              // Assuming Active High for now as per common LED wiring on these pins
    226              if (state) GPIO_SetBits(LED_PORT, pin);
   \                     ??LED_Set_1: (+1)
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD005             BEQ.N    ??LED_Set_2
   \   00000014   0x0001             MOVS     R1,R0
   \   00000016   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000018   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40011400
   \   0000001A   0x.... 0x....      BL       GPIO_SetBits
   \   0000001E   0xE004             B.N      ??LED_Set_3
    227              else GPIO_ResetBits(LED_PORT, pin);
   \                     ??LED_Set_2: (+1)
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000024   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40011400
   \   00000026   0x.... 0x....      BL       GPIO_ResetBits
    228          }
   \                     ??LED_Set_3: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    229          

   \                                 In section .text, align 2, keep-with-next
    230          uint16_t LightSensor_Read(void) {
   \                     LightSensor_Read: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    231              ADC_RegularChannelConfig(ADC1, LIGHT_ADC_CH, 1, ADC_SampleTime_55Cycles5);
   \   00000002   0x2305             MOVS     R3,#+5
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2108             MOVS     R1,#+8
   \   00000008   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   0000000A   0x.... 0x....      BL       ADC_RegularChannelConfig
    232              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000012   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    233              while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
   \                     ??LightSensor_Read_0: (+1)
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   0000001A   0x.... 0x....      BL       ADC_GetFlagStatus
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD0F9             BEQ.N    ??LightSensor_Read_0
    234              return ADC_GetConversionValue(ADC1);
   \   00000022   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40012400
   \   00000024   0x.... 0x....      BL       ADC_GetConversionValue
   \   00000028   0xBD02             POP      {R1,PC}          ;; return
    235          }
    236          

   \                                 In section .text, align 2, keep-with-next
    237          uint8_t PIR_Read(void) {
   \                     PIR_Read: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    238              return GPIO_ReadInputDataBit(PIR_PORT, PIR_PIN);
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x....             LDR.N    R0,??DataTable9  ;; 0x40011000
   \   00000006   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    239          }
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void Bluetooth_Send(uint8_t data) {
    242          // Stub
    243          }
   \                     Bluetooth_Send: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    244          

   \                                 In section .text, align 2, keep-with-next
    245          void Bluetooth_SendString(char *str) {
   \                     Bluetooth_SendString: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    246              char *p = str;
   \   00000004   0xE017             B.N      ??Bluetooth_SendString_0
    247              volatile uint32_t timeout;
    248              
    249              // Send to Bluetooth (USART2) Only
    250              while (*p) {
    251                  timeout = 0;
   \                     ??Bluetooth_SendString_1: (+1)
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    252                  while ((USART2->SR & USART_SR_TXE) == 0) {
   \                     ??Bluetooth_SendString_2: (+1)
   \   0000000A   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x0600             LSLS     R0,R0,#+24
   \   00000010   0xD406             BMI.N    ??Bluetooth_SendString_3
    253                      if (++timeout > 10000) break; // Timeout guard
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0xF242 0x7111      MOVW     R1,#+10001
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD3F4             BCC.N    ??Bluetooth_SendString_2
    254                  }
    255                  if (timeout <= 10000) USART_SendData(USART2, *p);
   \                     ??Bluetooth_SendString_3: (+1)
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0xF242 0x7111      MOVW     R1,#+10001
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD204             BCS.N    ??Bluetooth_SendString_4
   \   0000002A   0x7821             LDRB     R1,[R4, #+0]
   \   0000002C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002E   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   00000030   0x.... 0x....      BL       USART_SendData
    256                  
    257                  p++;
   \                     ??Bluetooth_SendString_4: (+1)
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    258              }
   \                     ??Bluetooth_SendString_0: (+1)
   \   00000036   0x7820             LDRB     R0,[R4, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1E4             BNE.N    ??Bluetooth_SendString_1
    259              
    260              // Newline/Space for readability
    261              // Note: Removed \r\n to prevent phantom echo to PC. Using Space separator instead.
    262              timeout = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9000             STR      R0,[SP, #+0]
    263              while ((USART2->SR & USART_SR_TXE) == 0) { if (++timeout > 10000) break; }
   \                     ??Bluetooth_SendString_5: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   00000042   0x8800             LDRH     R0,[R0, #+0]
   \   00000044   0x0600             LSLS     R0,R0,#+24
   \   00000046   0xD406             BMI.N    ??Bluetooth_SendString_6
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0xF242 0x7111      MOVW     R1,#+10001
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD3F4             BCC.N    ??Bluetooth_SendString_5
    264              if (timeout <= 10000) USART_SendData(USART2, ' ');
   \                     ??Bluetooth_SendString_6: (+1)
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0xF242 0x7111      MOVW     R1,#+10001
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD203             BCS.N    ??Bluetooth_SendString_7
   \   00000060   0x2120             MOVS     R1,#+32
   \   00000062   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004400
   \   00000064   0x.... 0x....      BL       USART_SendData
    265          }
   \                     ??Bluetooth_SendString_7: (+1)
   \   00000068   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x40004400         DC32     0x40004400

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   ADC_Configuration
        24   -> ADC_Cmd
        24   -> ADC_GetCalibrationStatus
        24   -> ADC_GetResetCalibrationStatus
        24   -> ADC_Init
        24   -> ADC_ResetCalibration
        24   -> ADC_StartCalibration
        24   -> RCC_APB2PeriphClockCmd
       8   BSP_Init
         8   -> ADC_Configuration
         8   -> EXTI_Configuration
         8   -> GPIO_Configuration
         8   -> LCD_Init
         8   -> NVIC_Configuration
         8   -> TIM_Configuration
         8   -> USART1_Init
         8   -> USART2_Init
       0   Bluetooth_Send
      16   Bluetooth_SendString
        16   -> USART_SendData
      16   EXTI_Configuration
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   GPIO_Configuration
         8   -> GPIO_Init
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
       8   LED_Set
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   LightSensor_Read
         8   -> ADC_GetConversionValue
         8   -> ADC_GetFlagStatus
         8   -> ADC_RegularChannelConfig
         8   -> ADC_SoftwareStartConvCmd
       8   NVIC_Configuration
         8   -> NVIC_Init
       8   PIR_Read
         8   -> GPIO_ReadInputDataBit
       8   Servo_SetAngle
         8   -> TIM_SetCompare1
      32   TIM_Configuration
        32   -> RCC_APB1PeriphClockCmd
        32   -> TIM_Cmd
        32   -> TIM_OC1Init
        32   -> TIM_OC1PreloadConfig
        32   -> TIM_TimeBaseInit
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
      24   USART2_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   USART_Configuration


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
      98  ADC_Configuration
      40  BSP_Init
       2  Bluetooth_Send
     106  Bluetooth_SendString
      40  EXTI_Configuration
     236  GPIO_Configuration
      44  LED_Set
      42  LightSensor_Read
      94  NVIC_Configuration
      12  PIR_Read
      40  Servo_SetAngle
     106  TIM_Configuration
      72  USART1_Init
      72  USART2_Init
       2  USART_Configuration

 
 1 038 bytes in section .text
 
 1 038 bytes of CODE memory

Errors: none
Warnings: 1
