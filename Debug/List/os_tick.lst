###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  11:44:50
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_tick.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW2B22.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_tick.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_tick.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_tick.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_tick.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                            TICK MANAGEMENT
     20          *
     21          * File    : os_tick.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_tick__c = "$Id: $";
     31          #endif
     32          
     33          #if (OS_CFG_TICK_EN > 0u)
     34          /*
     35          ************************************************************************************************************************
     36          *                                                 FUNCTION PROTOTYPES
     37          ************************************************************************************************************************
     38          */
     39          
     40          static  void  OS_TickListUpdate (OS_TICK  ticks);
     41          
     42          
     43          /*
     44          ************************************************************************************************************************
     45          *                                                      TICK INIT
     46          *
     47          * Description: This function initializes the variables related to the tick handler.
     48          *              The function is internal to uC/OS-III.
     49          *
     50          * Arguments  : p_err          is a pointer to a variable that will contain an error code returned by this function.
     51          *              -----
     52          *                                 OS_ERR_NONE           the tick variables were initialized successfully
     53          *
     54          * Returns    : none
     55          *
     56          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
     57          ************************************************************************************************************************
     58          */
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void  OS_TickInit (OS_ERR  *p_err)
     61          {
     62              *p_err                = OS_ERR_NONE;
   \                     OS_TickInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
     63          
     64              OSTickCtr             = 0u;                               /* Clear the tick counter                               */
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable5
   \   00000008   0x6008             STR      R0,[R1, #+0]
     65          
     66          #if (OS_CFG_DYN_TICK_EN > 0u)
     67              OSTickCtrStep         = 0u;
     68          #endif
     69          
     70              OSTickList.TCB_Ptr    = (OS_TCB *)0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable5_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     71          
     72          #if (OS_CFG_DBG_EN > 0u)
     73              OSTickList.NbrEntries = 0u;
     74              OSTickList.NbrUpdated = 0u;
     75          #endif
     76          }
   \   00000010   0x4770             BX       LR               ;; return
     77          
     78          /*
     79          ************************************************************************************************************************
     80          *                                                      TICK UPDATE
     81          *
     82          * Description: This function updates the list of task either delayed pending with timeout.
     83          *              The function is internal to uC/OS-III.
     84          *
     85          * Arguments  : ticks          the number of ticks which have elapsed
     86          *              -----
     87          *
     88          * Returns    : none
     89          *
     90          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
     91          ************************************************************************************************************************
     92          */
     93          

   \                                 In section .text, align 2, keep-with-next
     94          void  OS_TickUpdate (OS_TICK  ticks)
     95          {
   \                     OS_TickUpdate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     96          #if (OS_CFG_TS_EN > 0u)
     97              CPU_TS  ts_start;
     98          #endif
     99              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    100          
    101          
    102              CPU_CRITICAL_ENTER();
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   \   0000000C   0x0005             MOVS     R5,R0
    103          
    104              OSTickCtr += ticks;                                         /* Keep track of the number of ticks                    */
   \   0000000E   0x....             LDR.N    R0,??DataTable5
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1820             ADDS     R0,R4,R0
   \   00000014   0x....             LDR.N    R1,??DataTable5
   \   00000016   0x6008             STR      R0,[R1, #+0]
    105          
    106              OS_TRACE_TICK_INCREMENT(OSTickCtr);
    107          
    108          #if (OS_CFG_TS_EN > 0u)
    109              ts_start   = OS_TS_GET();
    110              OS_TickListUpdate(ticks);
    111              OSTickTime = OS_TS_GET() - ts_start;
    112              if (OSTickTimeMax < OSTickTime) {
    113                  OSTickTimeMax = OSTickTime;
    114              }
    115          #else
    116              OS_TickListUpdate(ticks);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       OS_TickListUpdate
    117          #endif
    118          
    119          #if (OS_CFG_DYN_TICK_EN > 0u)
    120              if (OSTickList.TCB_Ptr != (OS_TCB *)0) {
    121                  OSTickCtrStep = OSTickList.TCB_Ptr->TickRemain;
    122              } else {
    123                  OSTickCtrStep = 0u;
    124              }
    125          
    126              OS_DynTickSet(OSTickCtrStep);
    127          #endif
    128              CPU_CRITICAL_EXIT();
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x.... 0x....      BL       CPU_SR_Restore
    129          }
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    130          
    131          /*
    132          ************************************************************************************************************************
    133          *                                                      INSERT
    134          *
    135          * Description: This task is internal to uC/OS-III and allows the insertion of a task in a tick list.
    136          *
    137          * Arguments  : p_tcb       is a pointer to the TCB to insert in the list
    138          *
    139          *              elapsed     is the number of elapsed ticks since the last tick interrupt
    140          *
    141          *              tick_base   is value of OSTickCtr from which time is offset
    142          *
    143          *              time        is the amount of time remaining (in ticks) for the task to become ready
    144          *
    145          * Returns    : OS_TRUE     if time is valid for the given tick base
    146          *
    147          *              OS_FALSE    if time is invalid (i.e. zero delay)
    148          *
    149          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
    150          *
    151          *              2) This function supports both Periodic Tick Mode (PTM) and Dynamic Tick Mode (DTM).
    152          *
    153          *              3) PTM should always call this function with elapsed == 0u.
    154          ************************************************************************************************************************
    155          */
    156          

   \                                 In section .text, align 2, keep-with-next
    157          CPU_BOOLEAN  OS_TickListInsert (OS_TCB   *p_tcb,
    158                                          OS_TICK   elapsed,
    159                                          OS_TICK   tick_base,
    160                                          OS_TICK   time)
    161          {
   \                     OS_TickListInsert: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    162              OS_TCB        *p_tcb1;
    163              OS_TCB        *p_tcb2;
    164              OS_TICK_LIST  *p_list;
    165              OS_TICK        delta;
    166              OS_TICK        remain;
    167          
    168          
    169              delta = (time + tick_base) - (OSTickCtr + elapsed);         /* How many ticks until our delay expires?              */
   \   00000004   0x18D2             ADDS     R2,R2,R3
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x1A12             SUBS     R2,R2,R0
   \   0000000C   0x1A52             SUBS     R2,R2,R1
    170          
    171              if (delta == 0u) {
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD103             BNE.N    ??OS_TickListInsert_0
    172                  p_tcb->TickRemain = 0u;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6460             STR      R0,[R4, #+68]
    173                  return (OS_FALSE);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE03B             B.N      ??OS_TickListInsert_1
    174              }
    175          
    176              OS_TRACE_TASK_DLY(delta);
    177          
    178              p_list = &OSTickList;
   \                     ??OS_TickListInsert_0: (+1)
   \   0000001A   0x....             LDR.N    R5,??DataTable5_1
    179              if (p_list->TCB_Ptr == (OS_TCB *)0) {                       /* Is the list empty?                                   */
   \   0000001C   0x6828             LDR      R0,[R5, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD107             BNE.N    ??OS_TickListInsert_2
    180                  p_tcb->TickRemain   = delta;                            /* Yes, Store time in TCB                               */
   \   00000022   0x6462             STR      R2,[R4, #+68]
    181                  p_tcb->TickNextPtr  = (OS_TCB *)0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6160             STR      R0,[R4, #+20]
    182                  p_tcb->TickPrevPtr  = (OS_TCB *)0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x61A0             STR      R0,[R4, #+24]
    183                  p_list->TCB_Ptr     = p_tcb;                            /* Point to TCB of task to place in the list            */
   \   0000002C   0x602C             STR      R4,[R5, #+0]
    184          #if (OS_CFG_DYN_TICK_EN > 0u)
    185                  if (elapsed != 0u) {
    186                      OSTickCtr      += elapsed;                          /* Update OSTickCtr before we set a new tick step.      */
    187                      OS_TRACE_TICK_INCREMENT(OSTickCtr);
    188                  }
    189          
    190                  OSTickCtrStep       = delta;
    191                  OS_DynTickSet(OSTickCtrStep);
    192          #endif
    193          #if (OS_CFG_DBG_EN > 0u)
    194                  p_list->NbrEntries  = 1u;                               /* List contains 1 entry                                */
    195          #endif
    196                  return (OS_TRUE);
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE02F             B.N      ??OS_TickListInsert_1
    197              }
    198          
    199          
    200          #if (OS_CFG_DBG_EN > 0u)
    201              p_list->NbrEntries++;                                       /* Update debug counter to reflect the new entry.       */
    202          #endif
    203          
    204              p_tcb2 = p_list->TCB_Ptr;
   \                     ??OS_TickListInsert_2: (+1)
   \   00000032   0x682B             LDR      R3,[R5, #+0]
    205              remain = p_tcb2->TickRemain - elapsed;                      /* How many ticks until the head's delay expires?       */
   \   00000034   0x6C58             LDR      R0,[R3, #+68]
   \   00000036   0x1A41             SUBS     R1,R0,R1
    206          
    207              if ((delta               <   remain) &&                     /* If our entry is the new head of the tick list    ... */
    208                  (p_tcb2->TickPrevPtr == (OS_TCB *)0)) {
   \   00000038   0x428A             CMP      R2,R1
   \   0000003A   0xD20C             BCS.N    ??OS_TickListInsert_3
   \   0000003C   0x6998             LDR      R0,[R3, #+24]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD109             BNE.N    ??OS_TickListInsert_3
    209                  p_tcb->TickRemain    =  delta;                          /* ... the delta is equivalent to the full delay    ... */
   \   00000042   0x6462             STR      R2,[R4, #+68]
    210                  p_tcb2->TickRemain   =  remain - delta;                 /* ... the previous head's delta is now relative to it. */
   \   00000044   0x1A89             SUBS     R1,R1,R2
   \   00000046   0x6459             STR      R1,[R3, #+68]
    211          
    212                  p_tcb->TickPrevPtr   = (OS_TCB *)0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x61A0             STR      R0,[R4, #+24]
    213                  p_tcb->TickNextPtr   =  p_tcb2;
   \   0000004C   0x6163             STR      R3,[R4, #+20]
    214                  p_tcb2->TickPrevPtr  =  p_tcb;
   \   0000004E   0x619C             STR      R4,[R3, #+24]
    215                  p_list->TCB_Ptr      =  p_tcb;
   \   00000050   0x602C             STR      R4,[R5, #+0]
    216          #if (OS_CFG_DYN_TICK_EN > 0u)
    217                  if (elapsed != 0u) {
    218                      OSTickCtr       +=  elapsed;                        /* Update OSTickCtr before we set a new tick step.      */
    219                      OS_TRACE_TICK_INCREMENT(OSTickCtr);
    220                  }
    221                                                                          /* In DTM, a new list head must update the tick     ... */
    222                  OSTickCtrStep        =  delta;                          /* ... timer to interrupt at the new delay value.       */
    223                  OS_DynTickSet(OSTickCtrStep);
    224          #endif
    225          
    226                  return (OS_TRUE);
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE01D             B.N      ??OS_TickListInsert_1
    227              }
    228          
    229                                                                          /* Our entry comes after the current list head.         */
    230              delta  -= remain;                                           /* Make delta relative to the head.                     */
   \                     ??OS_TickListInsert_3: (+1)
   \   00000056   0x1A51             SUBS     R1,R2,R1
    231              p_tcb1  = p_tcb2;
    232              p_tcb2  = p_tcb1->TickNextPtr;
   \   00000058   0x6958             LDR      R0,[R3, #+20]
   \   0000005A   0xE003             B.N      ??OS_TickListInsert_4
    233          
    234              while ((p_tcb2 !=        (OS_TCB *)0) &&                    /* Find the appropriate position in the delta list.     */
    235                     (delta  >= p_tcb2->TickRemain)) {
    236                  delta  -= p_tcb2->TickRemain;
   \                     ??OS_TickListInsert_5: (+1)
   \   0000005C   0x6C42             LDR      R2,[R0, #+68]
   \   0000005E   0x1A89             SUBS     R1,R1,R2
    237                  p_tcb1  = p_tcb2;
   \   00000060   0x0003             MOVS     R3,R0
    238                  p_tcb2  = p_tcb2->TickNextPtr;
   \   00000062   0x6940             LDR      R0,[R0, #+20]
    239              }
   \                     ??OS_TickListInsert_4: (+1)
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??OS_TickListInsert_6
   \   00000068   0x6C42             LDR      R2,[R0, #+68]
   \   0000006A   0x4291             CMP      R1,R2
   \   0000006C   0xD2F6             BCS.N    ??OS_TickListInsert_5
    240          
    241              if (p_tcb2 != (OS_TCB *)0) {                                /* Our entry is not the last element in the list.       */
   \                     ??OS_TickListInsert_6: (+1)
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD009             BEQ.N    ??OS_TickListInsert_7
    242                  p_tcb1               = p_tcb2->TickPrevPtr;
   \   00000072   0x6982             LDR      R2,[R0, #+24]
    243                  p_tcb->TickRemain    = delta;                           /* Store remaining time                                 */
   \   00000074   0x6461             STR      R1,[R4, #+68]
    244                  p_tcb->TickPrevPtr   = p_tcb1;
   \   00000076   0x61A2             STR      R2,[R4, #+24]
    245                  p_tcb->TickNextPtr   = p_tcb2;
   \   00000078   0x6160             STR      R0,[R4, #+20]
    246                  p_tcb2->TickRemain  -= delta;                           /* Reduce time of next entry in the list                */
   \   0000007A   0x6C43             LDR      R3,[R0, #+68]
   \   0000007C   0x1A59             SUBS     R1,R3,R1
   \   0000007E   0x6441             STR      R1,[R0, #+68]
    247                  p_tcb2->TickPrevPtr  = p_tcb;
   \   00000080   0x6184             STR      R4,[R0, #+24]
    248                  p_tcb1->TickNextPtr  = p_tcb;
   \   00000082   0x6154             STR      R4,[R2, #+20]
   \   00000084   0xE004             B.N      ??OS_TickListInsert_8
    249          
    250              } else {                                                    /* Our entry belongs at the end of the list.            */
    251                  p_tcb->TickRemain    = delta;
   \                     ??OS_TickListInsert_7: (+1)
   \   00000086   0x6461             STR      R1,[R4, #+68]
    252                  p_tcb->TickPrevPtr   = p_tcb1;
   \   00000088   0x61A3             STR      R3,[R4, #+24]
    253                  p_tcb->TickNextPtr   = (OS_TCB *)0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x6160             STR      R0,[R4, #+20]
    254                  p_tcb1->TickNextPtr  = p_tcb;
   \   0000008E   0x615C             STR      R4,[R3, #+20]
    255              }
    256          
    257              return (OS_TRUE);
   \                     ??OS_TickListInsert_8: (+1)
   \   00000090   0x2001             MOVS     R0,#+1
   \                     ??OS_TickListInsert_1: (+1)
   \   00000092   0xBC30             POP      {R4,R5}
   \   00000094   0x4770             BX       LR               ;; return
    258          }
    259          
    260          /*
    261          ************************************************************************************************************************
    262          *                                            ADD DELAYED TASK TO TICK LIST
    263          *
    264          * Description: This function is called to place a task in a list of task waiting for time to expire
    265          *
    266          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task to add to the tick list
    267          *              -----
    268          *
    269          *              time           represents either the 'match' value of OSTickCtr or a relative time from the current
    270          *                             system time as specified by the 'opt' argument..
    271          *
    272          *                             relative when 'opt' is set to OS_OPT_TIME_DLY
    273          *                             relative when 'opt' is set to OS_OPT_TIME_TIMEOUT
    274          *                             match    when 'opt' is set to OS_OPT_TIME_MATCH
    275          *                             periodic when 'opt' is set to OS_OPT_TIME_PERIODIC
    276          *
    277          *              opt            is an option specifying how to calculate time.  The valid values are:
    278          *              ---
    279          *                                 OS_OPT_TIME_DLY
    280          *                                 OS_OPT_TIME_TIMEOUT
    281          *                                 OS_OPT_TIME_PERIODIC
    282          *                                 OS_OPT_TIME_MATCH
    283          *
    284          *              p_err          is a pointer to a variable that will contain an error code returned by this function.
    285          *              -----
    286          *                                 OS_ERR_NONE           the call was successful and the time delay was scheduled.
    287          *                                 OS_ERR_TIME_ZERO_DLY  if the effective delay is zero
    288          *
    289          * Returns    : None
    290          *
    291          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    292          *
    293          *              2) This function is assumed to be called with interrupts disabled.
    294          ************************************************************************************************************************
    295          */
    296          

   \                                 In section .text, align 2, keep-with-next
    297          void  OS_TickListInsertDly (OS_TCB   *p_tcb,
    298                                      OS_TICK   time,
    299                                      OS_OPT    opt,
    300                                      OS_ERR   *p_err)
    301          {
   \                     OS_TickListInsertDly: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x001E             MOVS     R6,R3
    302              OS_TICK      elapsed;
    303              OS_TICK      tick_base;
    304              OS_TICK      base_offset;
    305              CPU_BOOLEAN  valid_dly;
    306          
    307          
    308          #if (OS_CFG_DYN_TICK_EN > 0u)
    309              elapsed  = OS_DynTickGet();
    310          #else
    311              elapsed  = 0u;
   \   00000006   0x2400             MOVS     R4,#+0
    312          #endif
    313          
    314              if (opt == OS_OPT_TIME_MATCH) {                             /* MATCH to absolute tick ctr value mode                */
   \   00000008   0x0010             MOVS     R0,R2
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD101             BNE.N    ??OS_TickListInsertDly_0
    315                  tick_base = 0u;                                         /* tick_base + time == time                             */
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0xE020             B.N      ??OS_TickListInsertDly_1
    316          
    317              } else if (opt == OS_OPT_TIME_PERIODIC) {                   /* PERIODIC mode.                                       */
   \                     ??OS_TickListInsertDly_0: (+1)
   \   00000014   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000016   0x2A08             CMP      R2,#+8
   \   00000018   0xD11B             BNE.N    ??OS_TickListInsertDly_2
    318                  if (time == 0u) {
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD103             BNE.N    ??OS_TickListInsertDly_3
    319                     *p_err = OS_ERR_TIME_ZERO_DLY;                       /* Infinite frequency is invalid.                       */
   \   0000001E   0xF247 0x207E      MOVW     R0,#+29310
   \   00000022   0x8030             STRH     R0,[R6, #+0]
    320                      return;
   \   00000024   0xE028             B.N      ??OS_TickListInsertDly_4
    321                  }
    322          
    323                  tick_base = p_tcb->TickCtrPrev;
   \                     ??OS_TickListInsertDly_3: (+1)
   \   00000026   0x6CAA             LDR      R2,[R5, #+72]
    324          
    325          #if (OS_CFG_DYN_TICK_EN > 0u)                                   /* How far is our tick-base from the system time?       */
    326                  base_offset = OSTickCtr + elapsed - tick_base;
    327          #else
    328                  base_offset = OSTickCtr - tick_base;
   \   00000028   0x....             LDR.N    R0,??DataTable5
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x1A80             SUBS     R0,R0,R2
    329          #endif
    330          
    331                  if (base_offset >= time) {                              /* If our task missed the last period, move         ... */
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD30B             BCC.N    ??OS_TickListInsertDly_5
    332                      tick_base += time * (base_offset / time);           /* ... tick_base up to the next one.                    */
   \   00000032   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \   00000036   0xFB03 0x2201      MLA      R2,R3,R1,R2
    333                      if ((base_offset % time) != 0u) {
   \   0000003A   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \   0000003E   0xFB01 0x0013      MLS      R0,R1,R3,R0
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD000             BEQ.N    ??OS_TickListInsertDly_6
    334                          tick_base += time;                              /* Account for rounding errors with integer division    */
   \   00000046   0x188A             ADDS     R2,R1,R2
    335                      }
    336          
    337                      p_tcb->TickCtrPrev = tick_base;                     /* Adjust the periodic tick base                        */
   \                     ??OS_TickListInsertDly_6: (+1)
   \   00000048   0x64AA             STR      R2,[R5, #+72]
    338                  }
    339          
    340                  p_tcb->TickCtrPrev += time;                             /* Update for the next time we perform a periodic dly.  */
   \                     ??OS_TickListInsertDly_5: (+1)
   \   0000004A   0x6CA8             LDR      R0,[R5, #+72]
   \   0000004C   0x1808             ADDS     R0,R1,R0
   \   0000004E   0x64A8             STR      R0,[R5, #+72]
   \   00000050   0xE001             B.N      ??OS_TickListInsertDly_1
    341          
    342              } else {                                                    /* RELATIVE time delay mode                             */
    343          #if (OS_CFG_DYN_TICK_EN > 0u)                                   /* Our base is always the current system time.          */
    344                  tick_base = OSTickCtr + elapsed;
    345          #else
    346                  tick_base = OSTickCtr;
   \                     ??OS_TickListInsertDly_2: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable5
   \   00000054   0x6802             LDR      R2,[R0, #+0]
    347          #endif
    348              }
    349          
    350              valid_dly = OS_TickListInsert(p_tcb, elapsed, tick_base, time);
   \                     ??OS_TickListInsertDly_1: (+1)
   \   00000056   0x000B             MOVS     R3,R1
   \   00000058   0x0021             MOVS     R1,R4
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       OS_TickListInsert
    351          
    352              if (valid_dly == OS_TRUE) {
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xD105             BNE.N    ??OS_TickListInsertDly_7
    353                  p_tcb->TaskState = OS_TASK_STATE_DLY;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF885 0x002E      STRB     R0,[R5, #+46]
    354                 *p_err            = OS_ERR_NONE;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x8030             STRH     R0,[R6, #+0]
   \   00000070   0xE002             B.N      ??OS_TickListInsertDly_8
    355              } else {
    356                 *p_err = OS_ERR_TIME_ZERO_DLY;
   \                     ??OS_TickListInsertDly_7: (+1)
   \   00000072   0xF247 0x207E      MOVW     R0,#+29310
   \   00000076   0x8030             STRH     R0,[R6, #+0]
    357              }
    358          }
   \                     ??OS_TickListInsertDly_8: (+1)
   \                     ??OS_TickListInsertDly_4: (+1)
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return
    359          
    360          /*
    361          ************************************************************************************************************************
    362          *                                         REMOVE A TASK FROM THE TICK LIST
    363          *
    364          * Description: This function is called to remove a task from the tick list
    365          *
    366          * Arguments  : p_tcb          Is a pointer to the OS_TCB to remove.
    367          *              -----
    368          *
    369          * Returns    : none
    370          *
    371          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    372          *
    373          *              2) This function is assumed to be called with interrupts disabled.
    374          ************************************************************************************************************************
    375          */
    376          

   \                                 In section .text, align 2, keep-with-next
    377          void  OS_TickListRemove (OS_TCB  *p_tcb)
    378          {
   \                     OS_TickListRemove: (+1)
   \   00000000   0xB410             PUSH     {R4}
    379              OS_TCB        *p_tcb1;
    380              OS_TCB        *p_tcb2;
    381              OS_TICK_LIST  *p_list;
    382          #if (OS_CFG_DYN_TICK_EN > 0u)
    383              OS_TICK        elapsed;
    384          #endif
    385          
    386          #if (OS_CFG_DYN_TICK_EN > 0u)
    387              elapsed = OS_DynTickGet();
    388          #endif
    389          
    390              p_tcb1 = p_tcb->TickPrevPtr;
   \   00000002   0x6982             LDR      R2,[R0, #+24]
    391              p_tcb2 = p_tcb->TickNextPtr;
   \   00000004   0x6941             LDR      R1,[R0, #+20]
    392              p_list = &OSTickList;
   \   00000006   0x....             LDR.N    R3,??DataTable5_1
    393              if (p_tcb1 == (OS_TCB *)0) {
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD112             BNE.N    ??OS_TickListRemove_0
    394                  if (p_tcb2 == (OS_TCB *)0) {                            /* Remove the ONLY entry in the list?                   */
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD104             BNE.N    ??OS_TickListRemove_1
    395                      p_list->TCB_Ptr      = (OS_TCB *)0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6019             STR      R1,[R3, #+0]
    396          #if (OS_CFG_DBG_EN > 0u)
    397                      p_list->NbrEntries   =           0u;
    398          #endif
    399                      p_tcb->TickRemain    =           0u;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6441             STR      R1,[R0, #+68]
   \   00000018   0xE019             B.N      ??OS_TickListRemove_2
    400          #if (OS_CFG_DYN_TICK_EN > 0u)
    401                      if (elapsed != 0u) {
    402                          OSTickCtr       += elapsed;                     /* Keep track of time.                                  */
    403                          OS_TRACE_TICK_INCREMENT(OSTickCtr);
    404                      }
    405                      OSTickCtrStep        =           0u;
    406                      OS_DynTickSet(OSTickCtrStep);
    407          #endif
    408                  } else {
    409                      p_tcb2->TickPrevPtr  = (OS_TCB *)0;
   \                     ??OS_TickListRemove_1: (+1)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x618A             STR      R2,[R1, #+24]
    410                      p_tcb2->TickRemain  += p_tcb->TickRemain;           /* Add back the ticks to the delta                      */
   \   0000001E   0x6C4C             LDR      R4,[R1, #+68]
   \   00000020   0x6C42             LDR      R2,[R0, #+68]
   \   00000022   0x1914             ADDS     R4,R2,R4
   \   00000024   0x644C             STR      R4,[R1, #+68]
    411                      p_list->TCB_Ptr      = p_tcb2;
   \   00000026   0x6019             STR      R1,[R3, #+0]
    412          #if (OS_CFG_DBG_EN > 0u)
    413                      p_list->NbrEntries--;
    414          #endif
    415          
    416          #if (OS_CFG_DYN_TICK_EN > 0u)
    417                      if (p_tcb2->TickRemain != p_tcb->TickRemain) {      /* Only set a new tick if tcb2 had a longer delay.      */
    418                          if (elapsed != 0u) {
    419                              OSTickCtr          += elapsed;              /* Keep track of time.                                  */
    420                              OS_TRACE_TICK_INCREMENT(OSTickCtr);
    421                              p_tcb2->TickRemain -= elapsed;              /* We must account for any time which has passed.       */
    422                          }
    423                          OSTickCtrStep           = p_tcb2->TickRemain;
    424                          OS_DynTickSet(OSTickCtrStep);
    425                      }
    426          #endif
    427                      p_tcb->TickNextPtr          = (OS_TCB *)0;
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x6141             STR      R1,[R0, #+20]
    428                      p_tcb->TickRemain           =           0u;
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6441             STR      R1,[R0, #+68]
   \   00000030   0xE00D             B.N      ??OS_TickListRemove_2
    429                  }
    430              } else {
    431                  p_tcb1->TickNextPtr = p_tcb2;
   \                     ??OS_TickListRemove_0: (+1)
   \   00000032   0x6151             STR      R1,[R2, #+20]
    432                  if (p_tcb2 != (OS_TCB *)0) {
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD004             BEQ.N    ??OS_TickListRemove_3
    433                      p_tcb2->TickPrevPtr  = p_tcb1;
   \   00000038   0x618A             STR      R2,[R1, #+24]
    434                      p_tcb2->TickRemain  += p_tcb->TickRemain;            /* Add back the ticks to the delta list                 */
   \   0000003A   0x6C4B             LDR      R3,[R1, #+68]
   \   0000003C   0x6C42             LDR      R2,[R0, #+68]
   \   0000003E   0x18D3             ADDS     R3,R2,R3
   \   00000040   0x644B             STR      R3,[R1, #+68]
    435                  }
    436                  p_tcb->TickPrevPtr       = (OS_TCB *)0;
   \                     ??OS_TickListRemove_3: (+1)
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6181             STR      R1,[R0, #+24]
    437          #if (OS_CFG_DBG_EN > 0u)
    438                  p_list->NbrEntries--;
    439          #endif
    440                  p_tcb->TickNextPtr       = (OS_TCB *)0;
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x6141             STR      R1,[R0, #+20]
    441                  p_tcb->TickRemain        =           0u;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6441             STR      R1,[R0, #+68]
    442              }
    443          }
   \                     ??OS_TickListRemove_2: (+1)
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x4770             BX       LR               ;; return
    444          
    445          /*
    446          ************************************************************************************************************************
    447          *                                 UPDATE THE LIST OF TASKS DELAYED OR PENDING WITH TIMEOUT
    448          *
    449          * Description: This function updates the delta list which contains tasks that are delayed or pending with a timeout.
    450          *
    451          * Arguments  : ticks          the number of ticks which have elapsed.
    452          *
    453          * Returns    : none
    454          *
    455          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    456          ************************************************************************************************************************
    457          */
    458          

   \                                 In section .text, align 2, keep-with-next
    459          static  void  OS_TickListUpdate (OS_TICK  ticks)
    460          {
   \                     OS_TickListUpdate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
    461              OS_TCB        *p_tcb;
    462              OS_TICK_LIST  *p_list;
    463          #if (OS_CFG_DBG_EN > 0u)
    464              OS_OBJ_QTY     nbr_updated;
    465          #endif
    466          #if (OS_CFG_MUTEX_EN > 0u)
    467              OS_TCB        *p_tcb_owner;
    468              OS_PRIO        prio_new;
    469          #endif
    470          
    471          
    472          
    473          #if (OS_CFG_DBG_EN > 0u)
    474              nbr_updated = 0u;
    475          #endif
    476              p_list      = &OSTickList;
   \   00000004   0x....             LDR.N    R6,??DataTable5_1
    477              p_tcb       = p_list->TCB_Ptr;
   \   00000006   0x6834             LDR      R4,[R6, #+0]
    478              if (p_tcb != (OS_TCB *)0) {
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD075             BEQ.N    ??OS_TickListUpdate_0
    479                  if (p_tcb->TickRemain <= ticks) {
   \   0000000C   0x6C60             LDR      R0,[R4, #+68]
   \   0000000E   0x4287             CMP      R7,R0
   \   00000010   0xD304             BCC.N    ??OS_TickListUpdate_1
    480                      ticks              = ticks - p_tcb->TickRemain;
   \   00000012   0x6C60             LDR      R0,[R4, #+68]
   \   00000014   0x1A3F             SUBS     R7,R7,R0
    481                      p_tcb->TickRemain  = 0u;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6460             STR      R0,[R4, #+68]
   \   0000001A   0xE007             B.N      ??OS_TickListUpdate_2
    482                  } else {
    483                      p_tcb->TickRemain -= ticks;
   \                     ??OS_TickListUpdate_1: (+1)
   \   0000001C   0x6C60             LDR      R0,[R4, #+68]
   \   0000001E   0x1BC0             SUBS     R0,R0,R7
   \   00000020   0x6460             STR      R0,[R4, #+68]
   \   00000022   0xE003             B.N      ??OS_TickListUpdate_2
    484                  }
    485          
    486                  while (p_tcb->TickRemain == 0u) {
    487          #if (OS_CFG_DBG_EN > 0u)
    488                      nbr_updated++;
    489          #endif
    490          
    491                      switch (p_tcb->TaskState) {
    492                          case OS_TASK_STATE_DLY:
    493                               p_tcb->TaskState = OS_TASK_STATE_RDY;
    494                               OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                    */
    495                               break;
    496          
    497                          case OS_TASK_STATE_DLY_SUSPENDED:
    498                               p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
    499                               break;
    500          
    501                          default:
    502          #if (OS_CFG_MUTEX_EN > 0u)
    503                               p_tcb_owner = (OS_TCB *)0;
    504                               if (p_tcb->PendOn == OS_TASK_PEND_ON_MUTEX) {
    505                                   p_tcb_owner = (OS_TCB *)((OS_MUTEX *)((void *)p_tcb->PendObjPtr))->OwnerTCBPtr;
    506                               }
    507          #endif
    508          
    509          #if (OS_MSG_EN > 0u)
    510                               p_tcb->MsgPtr  = (void *)0;
    511                               p_tcb->MsgSize = 0u;
    512          #endif
    513          #if (OS_CFG_TS_EN > 0u)
    514                               p_tcb->TS      = OS_TS_GET();
    515          #endif
    516                               OS_PendListRemove(p_tcb);                           /* Remove task from pend list                           */
    517          
    518                               switch (p_tcb->TaskState) {
    519                                   case OS_TASK_STATE_PEND_TIMEOUT:
    520                                        OS_RdyListInsert(p_tcb);                   /* Insert the task in the ready list                    */
    521                                        p_tcb->TaskState  = OS_TASK_STATE_RDY;
    522                                        break;
    523          
    524                                   case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    525                                        p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
    526                                        break;
    527          
    528                                   default:
    529                                        break;
    530                               }
    531                               p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;         /* Indicate pend timed out                              */
    532                               p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                           */
    533          
    534          #if (OS_CFG_MUTEX_EN > 0u)
    535                               if (p_tcb_owner != (OS_TCB *)0) {
    536                                   if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    537                                       (p_tcb_owner->Prio == p_tcb->Prio)) {       /* Has the owner inherited a priority?                  */
    538                                       prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
    539                                       prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
    540                                       if (prio_new != p_tcb_owner->Prio) {
    541                                           OS_TaskChangePrio(p_tcb_owner, prio_new);
    542                                           OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    543                                       }
    544                                   }
    545                               }
    546          #endif
    547                               break;
    548                      }
    549          
    550                      p_list->TCB_Ptr = p_tcb->TickNextPtr;
    551                      p_tcb           = p_list->TCB_Ptr;                           /* Get 'p_tcb' again for loop                           */
    552                      if (p_tcb == (OS_TCB *)0) {
    553          #if (OS_CFG_DBG_EN > 0u)
    554                          p_list->NbrEntries = 0u;
    555          #endif
    556                          break;
    557                      } else {
    558          #if (OS_CFG_DBG_EN > 0u)
    559                          p_list->NbrEntries--;
    560          #endif
    561                          p_tcb->TickPrevPtr = (OS_TCB *)0;
    562                          if (p_tcb->TickRemain <= ticks) {
    563                              ticks              = ticks - p_tcb->TickRemain;
   \                     ??OS_TickListUpdate_3: (+1)
   \   00000024   0x6C60             LDR      R0,[R4, #+68]
   \   00000026   0x1A3F             SUBS     R7,R7,R0
    564                              p_tcb->TickRemain  = 0u;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6460             STR      R0,[R4, #+68]
    565                          } else {
   \                     ??OS_TickListUpdate_2: (+1)
   \   0000002C   0x6C60             LDR      R0,[R4, #+68]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD162             BNE.N    ??OS_TickListUpdate_0
   \   00000032   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD002             BEQ.N    ??OS_TickListUpdate_4
   \   0000003A   0x2805             CMP      R0,#+5
   \   0000003C   0xD007             BEQ.N    ??OS_TickListUpdate_5
   \   0000003E   0xE00A             B.N      ??OS_TickListUpdate_6
   \                     ??OS_TickListUpdate_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       OS_RdyListInsert
   \   0000004C   0xE04F             B.N      ??OS_TickListUpdate_7
   \                     ??OS_TickListUpdate_5: (+1)
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   00000054   0xE04B             B.N      ??OS_TickListUpdate_7
   \                     ??OS_TickListUpdate_6: (+1)
   \   00000056   0x2500             MOVS     R5,#+0
   \   00000058   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000005C   0x2804             CMP      R0,#+4
   \   0000005E   0xD101             BNE.N    ??OS_TickListUpdate_8
   \   00000060   0x6AA0             LDR      R0,[R4, #+40]
   \   00000062   0x6905             LDR      R5,[R0, #+16]
   \                     ??OS_TickListUpdate_8: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x6560             STR      R0,[R4, #+84]
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       OS_PendListRemove
   \   00000074   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000078   0x2803             CMP      R0,#+3
   \   0000007A   0xD002             BEQ.N    ??OS_TickListUpdate_9
   \   0000007C   0x2807             CMP      R0,#+7
   \   0000007E   0xD007             BEQ.N    ??OS_TickListUpdate_10
   \   00000080   0xE00A             B.N      ??OS_TickListUpdate_11
   \                     ??OS_TickListUpdate_9: (+1)
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0x.... 0x....      BL       OS_RdyListInsert
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   0000008E   0xE003             B.N      ??OS_TickListUpdate_12
   \                     ??OS_TickListUpdate_10: (+1)
   \   00000090   0x2004             MOVS     R0,#+4
   \   00000092   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   00000096   0xE7FF             B.N      ??OS_TickListUpdate_12
   \                     ??OS_TickListUpdate_11: (+1)
   \                     ??OS_TickListUpdate_12: (+1)
   \   00000098   0x2003             MOVS     R0,#+3
   \   0000009A   0xF884 0x002D      STRB     R0,[R4, #+45]
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   000000A4   0x2D00             CMP      R5,#+0
   \   000000A6   0xD022             BEQ.N    ??OS_TickListUpdate_13
   \   000000A8   0xF895 0x002F      LDRB     R0,[R5, #+47]
   \   000000AC   0xF895 0x1030      LDRB     R1,[R5, #+48]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD01C             BEQ.N    ??OS_TickListUpdate_13
   \   000000B4   0xF895 0x002F      LDRB     R0,[R5, #+47]
   \   000000B8   0xF894 0x102F      LDRB     R1,[R4, #+47]
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xD116             BNE.N    ??OS_TickListUpdate_13
   \   000000C0   0x0028             MOVS     R0,R5
   \   000000C2   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000C6   0x0001             MOVS     R1,R0
   \   000000C8   0xF895 0x0030      LDRB     R0,[R5, #+48]
   \   000000CC   0x000A             MOVS     R2,R1
   \   000000CE   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000D0   0x4290             CMP      R0,R2
   \   000000D2   0xD202             BCS.N    ??OS_TickListUpdate_14
   \   000000D4   0xF895 0x1030      LDRB     R1,[R5, #+48]
   \   000000D8   0xE7FF             B.N      ??OS_TickListUpdate_15
   \                     ??OS_TickListUpdate_14: (+1)
   \                     ??OS_TickListUpdate_15: (+1)
   \   000000DA   0x0008             MOVS     R0,R1
   \   000000DC   0xF895 0x202F      LDRB     R2,[R5, #+47]
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x4290             CMP      R0,R2
   \   000000E4   0xD003             BEQ.N    ??OS_TickListUpdate_13
   \   000000E6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000E8   0x0028             MOVS     R0,R5
   \   000000EA   0x.... 0x....      BL       OS_TaskChangePrio
   \                     ??OS_TickListUpdate_13: (+1)
   \                     ??OS_TickListUpdate_7: (+1)
   \   000000EE   0x6960             LDR      R0,[R4, #+20]
   \   000000F0   0x6030             STR      R0,[R6, #+0]
   \   000000F2   0x6834             LDR      R4,[R6, #+0]
   \   000000F4   0x2C00             CMP      R4,#+0
   \   000000F6   0xD100             BNE.N    ??OS_TickListUpdate_16
    566                              p_tcb->TickRemain -= ticks;
    567                          }
    568                      }
    569                  }
    570              }
    571          #if (OS_CFG_DBG_EN > 0u)
    572              p_list->NbrUpdated = nbr_updated;
    573          #endif
    574          }
   \                     ??OS_TickListUpdate_0: (+1)
   \   000000F8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??OS_TickListUpdate_16: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x61A0             STR      R0,[R4, #+24]
   \   000000FE   0x6C60             LDR      R0,[R4, #+68]
   \   00000100   0x4287             CMP      R7,R0
   \   00000102   0xD28F             BCS.N    ??OS_TickListUpdate_3
   \   00000104   0x6C60             LDR      R0,[R4, #+68]
   \   00000106   0x1BC0             SUBS     R0,R0,R7
   \   00000108   0x6460             STR      R0,[R4, #+68]
   \   0000010A   0xE78F             B.N      ??OS_TickListUpdate_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSTickCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSTickList
    575          
    576          #endif                                                                   /* #if OS_CFG_TICK_EN                                   */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   OS_TickInit
       8   OS_TickListInsert
      16   OS_TickListInsertDly
        16   -> OS_TickListInsert
       4   OS_TickListRemove
      24   OS_TickListUpdate
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_PendListRemove
        24   -> OS_RdyListInsert
        24   -> OS_TaskChangePrio
      16   OS_TickUpdate
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_TickListUpdate


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
      18  OS_TickInit
     150  OS_TickListInsert
     122  OS_TickListInsertDly
      82  OS_TickListRemove
     268  OS_TickListUpdate
      38  OS_TickUpdate

 
 686 bytes in section .text
 
 686 bytes of CODE memory

Errors: none
Warnings: none
