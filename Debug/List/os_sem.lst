###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_sem.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3BCA.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_sem.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_sem.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_sem.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_sem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                         SEMAPHORE MANAGEMENT
     20          *
     21          * File    : os_sem.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_sem__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_SEM_EN > 0u)
     35          /*
     36          ************************************************************************************************************************
     37          *                                                  CREATE A SEMAPHORE
     38          *
     39          * Description: This function creates a semaphore.
     40          *
     41          * Arguments  : p_sem         is a pointer to the semaphore to initialize.  Your application is responsible for
     42          *                            allocating storage for the semaphore.
     43          *
     44          *              p_name        is a pointer to the name you would like to give the semaphore.
     45          *
     46          *              cnt           is the initial value for the semaphore.
     47          *                            If used to share resources, you should initialize to the number of resources available.
     48          *                            If used to signal the occurrence of event(s) then you should initialize to 0.
     49          *
     50          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
     51          *
     52          *                                OS_ERR_NONE                    If the call was successful
     53          *                                OS_ERR_CREATE_ISR              If you called this function from an ISR
     54          *                                OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the semaphore after you
     55          *                                                                 called OSSafetyCriticalStart()
     56          *                                OS_ERR_OBJ_PTR_NULL            If 'p_sem'  is a NULL pointer
     57          *                                OS_ERR_OBJ_CREATED             If the semaphore was already created
     58          *
     59          * Returns    : none
     60          *
     61          * Note(s)    : none
     62          ************************************************************************************************************************
     63          */
     64          

   \                                 In section .text, align 2, keep-with-next
     65          void  OSSemCreate (OS_SEM      *p_sem,
     66                             CPU_CHAR    *p_name,
     67                             OS_SEM_CTR   cnt,
     68                             OS_ERR      *p_err)
     69          {
   \                     OSSemCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
     70              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
     71          
     72          
     73          #ifdef OS_SAFETY_CRITICAL
     74              if (p_err == (OS_ERR *)0) {
     75                  OS_SAFETY_CRITICAL_EXCEPTION();
     76                  return;
     77              }
     78          #endif
     79          
     80          #ifdef OS_SAFETY_CRITICAL_IEC61508
     81              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     82                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     83                  return;
     84              }
     85          #endif
     86          
     87          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
     88              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to be called from an ISR                 */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSSemCreate_0
     89                 *p_err = OS_ERR_CREATE_ISR;
   \   00000014   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
     90                  return;
   \   0000001A   0xE021             B.N      ??OSSemCreate_1
     91              }
     92          #endif
     93          
     94          #if (OS_CFG_ARG_CHK_EN > 0u)
     95              if (p_sem == (OS_SEM *)0) {                                 /* Validate 'p_sem'                                     */
   \                     ??OSSemCreate_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD103             BNE.N    ??OSSemCreate_2
     96                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8028             STRH     R0,[R5, #+0]
     97                  return;
   \   00000026   0xE01B             B.N      ??OSSemCreate_1
     98              }
     99          #endif
    100          
    101              CPU_CRITICAL_ENTER();
   \                     ??OSSemCreate_2: (+1)
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   \   0000002E   0x0007             MOVS     R7,R0
    102          #if (OS_OBJ_TYPE_REQ > 0u)
    103          #if (OS_CFG_OBJ_CREATED_CHK_EN > 0u)
    104              if (p_sem->Type == OS_OBJ_TYPE_SEM) {
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x414d4553
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD106             BNE.N    ??OSSemCreate_3
    105                  CPU_CRITICAL_EXIT();
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
    106                  *p_err = OS_ERR_OBJ_CREATED;
   \   00000040   0xF645 0x50C1      MOVW     R0,#+24001
   \   00000044   0x8028             STRH     R0,[R5, #+0]
    107                  return;
   \   00000046   0xE00B             B.N      ??OSSemCreate_1
    108              }
    109          #endif
    110              p_sem->Type    = OS_OBJ_TYPE_SEM;                           /* Mark the data structure as a semaphore               */
   \                     ??OSSemCreate_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable6_1  ;; 0x414d4553
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    111          #endif
    112              p_sem->Ctr     = cnt;                                       /* Set semaphore value                                  */
   \   0000004E   0x60E6             STR      R6,[R4, #+12]
    113          #if (OS_CFG_TS_EN > 0u)
    114              p_sem->TS      = 0u;
    115          #endif
    116          #if (OS_CFG_DBG_EN > 0u)
    117              p_sem->NamePtr = p_name;                                    /* Save the name of the semaphore                       */
    118          #else
    119              (void)p_name;
    120          #endif
    121              OS_PendListInit(&p_sem->PendList);                          /* Initialize the waiting list                          */
   \   00000050   0x1D20             ADDS     R0,R4,#+4
   \   00000052   0x.... 0x....      BL       OS_PendListInit
    122          
    123          #if (OS_CFG_DBG_EN > 0u)
    124              OS_SemDbgListAdd(p_sem);
    125              OSSemQty++;
    126          #endif
    127          
    128              OS_TRACE_SEM_CREATE(p_sem, p_name);
    129          
    130              CPU_CRITICAL_EXIT();
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    131             *p_err = OS_ERR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8028             STRH     R0,[R5, #+0]
    132          }
   \                     ??OSSemCreate_1: (+1)
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    133          
    134          
    135          /*
    136          ************************************************************************************************************************
    137          *                                                  DELETE A SEMAPHORE
    138          *
    139          * Description: This function deletes a semaphore.
    140          *
    141          * Arguments  : p_sem         is a pointer to the semaphore to delete
    142          *
    143          *              opt           determines delete options as follows:
    144          *
    145          *                                OS_OPT_DEL_NO_PEND          Delete semaphore ONLY if no task pending
    146          *                                OS_OPT_DEL_ALWAYS           Deletes the semaphore even if tasks are waiting.
    147          *                                                            In this case, all the tasks pending will be readied.
    148          *
    149          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    150          *
    151          *                                OS_ERR_NONE                    The call was successful and the semaphore was deleted
    152          *                                OS_ERR_DEL_ISR                 If you attempted to delete the semaphore from an ISR
    153          *                                OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the semaphore after you called
    154          *                                                                 OSStart()
    155          *                                OS_ERR_OBJ_PTR_NULL            If 'p_sem' is a NULL pointer
    156          *                                OS_ERR_OBJ_TYPE                If 'p_sem' is not pointing at a semaphore
    157          *                                OS_ERR_OPT_INVALID             An invalid option was specified
    158          *                                OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    159          *                                OS_ERR_TASK_WAITING            One or more tasks were waiting on the semaphore
    160          *
    161          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    162          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    163          *
    164          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the semaphore
    165          *                 MUST check the return code of OSSemPend().
    166          *              2) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in applications where
    167          *                 the semaphore is used for mutual exclusion because the resource(s) will no longer be guarded by the
    168          *                 semaphore.
    169          ************************************************************************************************************************
    170          */
    171          
    172          #if (OS_CFG_SEM_DEL_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    173          OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
    174                                OS_OPT   opt,
    175                                OS_ERR  *p_err)
    176          {
   \                     OSSemDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0015             MOVS     R5,R2
    177              OS_OBJ_QTY     nbr_tasks;
    178              OS_PEND_LIST  *p_pend_list;
    179              OS_TCB        *p_tcb;
    180              CPU_TS         ts;
    181              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    182          
    183          
    184          #ifdef OS_SAFETY_CRITICAL
    185              if (p_err == (OS_ERR *)0) {
    186                  OS_SAFETY_CRITICAL_EXCEPTION();
    187                  return (0u);
    188              }
    189          #endif
    190          
    191              OS_TRACE_SEM_DEL_ENTER(p_sem, opt);
    192          
    193          #ifdef OS_SAFETY_CRITICAL_IEC61508
    194              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    195                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    196                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    197                  return (0u);
    198              }
    199          #endif
    200          
    201          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    202              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to delete a semaphore from an ISR        */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSSemDel_0
    203                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_DEL_ISR);
    204                 *p_err = OS_ERR_DEL_ISR;
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    205                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE05F             B.N      ??OSSemDel_1
    206              }
    207          #endif
    208          
    209          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    210              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSSemDel_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD004             BEQ.N    ??OSSemDel_2
    211                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    212                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002A   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    213                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE055             B.N      ??OSSemDel_1
    214              }
    215          #endif
    216          
    217          #if (OS_CFG_ARG_CHK_EN > 0u)
    218              if (p_sem == (OS_SEM *)0) {                                 /* Validate 'p_sem'                                     */
   \                     ??OSSemDel_2: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD104             BNE.N    ??OSSemDel_3
    219                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    220                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000038   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    221                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE04E             B.N      ??OSSemDel_1
    222              }
    223          #endif
    224          
    225          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    226              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemDel_3: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x414d4553
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD004             BEQ.N    ??OSSemDel_4
    227                  OS_TRACE_SEM_DEL_EXIT(OS_ERR_OBJ_TYPE);
    228                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000004C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000050   0x8028             STRH     R0,[R5, #+0]
    229                  return (0u);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE044             B.N      ??OSSemDel_1
    230              }
    231          #endif
    232          
    233              CPU_CRITICAL_ENTER();
   \                     ??OSSemDel_4: (+1)
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
   \   0000005C   0x0007             MOVS     R7,R0
    234              p_pend_list = &p_sem->PendList;
   \   0000005E   0xF114 0x0804      ADDS     R8,R4,#+4
    235              nbr_tasks   = 0u;
   \   00000062   0x2600             MOVS     R6,#+0
    236              switch (opt) {
   \   00000064   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000068   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006C   0xD003             BEQ.N    ??OSSemDel_5
   \   0000006E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000072   0xD014             BEQ.N    ??OSSemDel_6
   \   00000074   0xE02C             B.N      ??OSSemDel_7
    237                  case OS_OPT_DEL_NO_PEND:                                /* Delete semaphore only if no task waiting             */
    238                       if (p_pend_list->HeadPtr == (OS_TCB *)0) {
   \                     ??OSSemDel_5: (+1)
   \   00000076   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD108             BNE.N    ??OSSemDel_8
    239          #if (OS_CFG_DBG_EN > 0u)
    240                           OS_SemDbgListRemove(p_sem);
    241                           OSSemQty--;
    242          #endif
    243                           OS_TRACE_SEM_DEL(p_sem);
    244                           OS_SemClr(p_sem);
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       OS_SemClr
    245                           CPU_CRITICAL_EXIT();
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    246                          *p_err = OS_ERR_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x8028             STRH     R0,[R5, #+0]
   \   0000008E   0xE005             B.N      ??OSSemDel_9
    247                       } else {
    248                           CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_8: (+1)
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    249                          *p_err = OS_ERR_TASK_WAITING;
   \   00000096   0xF247 0x105F      MOVW     R0,#+29023
   \   0000009A   0x8028             STRH     R0,[R5, #+0]
    250                       }
    251                       break;
   \                     ??OSSemDel_9: (+1)
   \   0000009C   0xE01E             B.N      ??OSSemDel_10
    252          
    253                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the semaphore                          */
    254          #if (OS_CFG_TS_EN > 0u)
    255                       ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
    256          #else
    257                       ts = 0u;
   \                     ??OSSemDel_6: (+1)
   \   0000009E   0xF05F 0x0900      MOVS     R9,#+0
   \   000000A2   0xE006             B.N      ??OSSemDel_11
    258          #endif
    259                       while (p_pend_list->HeadPtr != (OS_TCB *)0) {      /* Remove all tasks on the pend list                    */
    260                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSSemDel_12: (+1)
   \   000000A4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
    261                           OS_PendAbort(p_tcb,
    262                                        ts,
    263                                        OS_STATUS_PEND_DEL);
   \   000000A8   0x2202             MOVS     R2,#+2
   \   000000AA   0x4649             MOV      R1,R9
   \   000000AC   0x.... 0x....      BL       OS_PendAbort
    264                           nbr_tasks++;
   \   000000B0   0x1C76             ADDS     R6,R6,#+1
    265                       }
   \                     ??OSSemDel_11: (+1)
   \   000000B2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD1F4             BNE.N    ??OSSemDel_12
    266          #if (OS_CFG_DBG_EN > 0u)
    267                       OS_SemDbgListRemove(p_sem);
    268                       OSSemQty--;
    269          #endif
    270                       OS_TRACE_SEM_DEL(p_sem);
    271                       OS_SemClr(p_sem);
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       OS_SemClr
    272                       CPU_CRITICAL_EXIT();
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    273                       OSSched();                                         /* Find highest priority task ready to run              */
   \   000000C6   0x.... 0x....      BL       OSSched
    274                      *p_err = OS_ERR_NONE;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    275                       break;
   \   000000CE   0xE005             B.N      ??OSSemDel_10
    276          
    277                  default:
    278                       CPU_CRITICAL_EXIT();
   \                     ??OSSemDel_7: (+1)
   \   000000D0   0x0038             MOVS     R0,R7
   \   000000D2   0x.... 0x....      BL       CPU_SR_Restore
    279                      *p_err = OS_ERR_OPT_INVALID;
   \   000000D6   0xF645 0x6025      MOVW     R0,#+24101
   \   000000DA   0x8028             STRH     R0,[R5, #+0]
    280                       break;
    281              }
    282          
    283              OS_TRACE_SEM_DEL_EXIT(*p_err);
    284          
    285              return (nbr_tasks);
   \                     ??OSSemDel_10: (+1)
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemDel_1: (+1)
   \   000000E0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    286          }
    287          #endif
    288          
    289          
    290          /*
    291          ************************************************************************************************************************
    292          *                                                  PEND ON SEMAPHORE
    293          *
    294          * Description: This function waits for a semaphore.
    295          *
    296          * Arguments  : p_sem         is a pointer to the semaphore
    297          *
    298          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for the
    299          *                            resource up to the amount of time (in 'ticks') specified by this argument.  If you specify
    300          *                            0, however, your task will wait forever at the specified semaphore or, until the resource
    301          *                            becomes available (or the event occurs).
    302          *
    303          *              opt           determines whether the user wants to block if the semaphore is available or not:
    304          *
    305          *                                OS_OPT_PEND_BLOCKING
    306          *                                OS_OPT_PEND_NON_BLOCKING
    307          *
    308          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
    309          *                            or pend aborted or the semaphore deleted.  If you pass a NULL pointer (i.e. (CPU_TS*)0)
    310          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid
    311          *                            and indicates that you don't need the timestamp.
    312          *
    313          *              p_err         is a pointer to a variable that will contain an error code returned by this function.
    314          *
    315          *                                OS_ERR_NONE               The call was successful and your task owns the resource
    316          *                                                          or, the event you are waiting for occurred
    317          *                                OS_ERR_OBJ_DEL            If 'p_sem' was deleted
    318          *                                OS_ERR_OBJ_PTR_NULL       If 'p_sem' is a NULL pointer
    319          *                                OS_ERR_OBJ_TYPE           If 'p_sem' is not pointing at a semaphore
    320          *                                OS_ERR_OPT_INVALID        If you specified an invalid value for 'opt'
    321          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    322          *                                OS_ERR_PEND_ABORT         If the pend was aborted by another task
    323          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    324          *                                                          would lead to a suspension
    325          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the semaphore was not
    326          *                                                          available
    327          *                                OS_ERR_SCHED_LOCKED       If you called this function when the scheduler is locked
    328          *                                OS_ERR_STATUS_INVALID     Pend status is invalid
    329          *                                OS_ERR_TIMEOUT            The semaphore was not received within the specified
    330          *                                                          timeout
    331          *                                OS_ERR_TICK_DISABLED      If kernel ticks are disabled and a timeout is specified
    332          *
    333          *
    334          * Returns    : The current value of the semaphore counter or 0 if not available.
    335          *
    336          * Note(s)    : This API 'MUST NOT' be called from a timer callback function.
    337          ************************************************************************************************************************
    338          */
    339          

   \                                 In section .text, align 2, keep-with-next
    340          OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
    341                                 OS_TICK   timeout,
    342                                 OS_OPT    opt,
    343                                 CPU_TS   *p_ts,
    344                                 OS_ERR   *p_err)
    345          {
   \                     OSSemPend: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x9D06             LDR      R5,[SP, #+24]
    346              OS_SEM_CTR  ctr;
    347              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
    348          
    349          
    350          #if (OS_CFG_TS_EN == 0u)
    351              (void)p_ts;                                                /* Prevent compiler warning for not using 'ts'          */
    352          #endif
    353          
    354          #ifdef OS_SAFETY_CRITICAL
    355              if (p_err == (OS_ERR *)0) {
    356                  OS_SAFETY_CRITICAL_EXCEPTION();
    357                  return (0u);
    358              }
    359          #endif
    360          
    361              OS_TRACE_SEM_PEND_ENTER(p_sem, timeout, opt, p_ts);
    362          
    363          #if (OS_CFG_TICK_EN == 0u)
    364              if (timeout != 0u) {
    365                 *p_err = OS_ERR_TICK_DISABLED;
    366                  OS_TRACE_SEM_PEND_FAILED(p_sem);
    367                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_TICK_DISABLED);
    368                  return (0u);
    369              }
    370          #endif
    371          
    372          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    373              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD008             BEQ.N    ??OSSemPend_0
    374                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != OS_OPT_PEND_NON_BLOCKING) {
   \   00000018   0x4640             MOV      R0,R8
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0x0400             LSLS     R0,R0,#+16
   \   0000001E   0xD404             BMI.N    ??OSSemPend_0
    375                      OS_TRACE_SEM_PEND_FAILED(p_sem);
    376                      OS_TRACE_SEM_PEND_EXIT(OS_ERR_PEND_ISR);
    377                     *p_err = OS_ERR_PEND_ISR;
   \   00000020   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000024   0x8028             STRH     R0,[R5, #+0]
    378                      return (0u);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE073             B.N      ??OSSemPend_1
    379                  }
    380              }
    381          #endif
    382          
    383          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    384              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSSemPend_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD004             BEQ.N    ??OSSemPend_2
    385                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    386                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000034   0xF645 0x6089      MOVW     R0,#+24201
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    387                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE069             B.N      ??OSSemPend_1
    388              }
    389          #endif
    390          
    391          #if (OS_CFG_ARG_CHK_EN > 0u)
    392              if (p_sem == (OS_SEM *)0) {                                 /* Validate 'p_sem'                                     */
   \                     ??OSSemPend_2: (+1)
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD104             BNE.N    ??OSSemPend_3
    393                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    394                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000042   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000046   0x8028             STRH     R0,[R5, #+0]
    395                  return (0u);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE062             B.N      ??OSSemPend_1
    396              }
    397              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSSemPend_3: (+1)
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ.N    ??OSSemPend_4
   \   00000054   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000058   0xD116             BNE.N    ??OSSemPend_5
    398                  case OS_OPT_PEND_BLOCKING:
    399                  case OS_OPT_PEND_NON_BLOCKING:
    400                       break;
    401          
    402                  default:
    403                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    404                       OS_TRACE_SEM_PEND_EXIT(OS_ERR_OPT_INVALID);
    405                      *p_err = OS_ERR_OPT_INVALID;
    406                       return (0u);
    407              }
    408          #endif
    409          
    410          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    411              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemPend_4: (+1)
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable6_1  ;; 0x414d4553
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD116             BNE.N    ??OSSemPend_6
    412                  OS_TRACE_SEM_PEND_FAILED(p_sem);
    413                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_OBJ_TYPE);
    414                 *p_err = OS_ERR_OBJ_TYPE;
    415                  return (0u);
    416              }
    417          #endif
    418          
    419          
    420              CPU_CRITICAL_ENTER();
   \   00000064   0x2040             MOVS     R0,#+64
   \   00000066   0x.... 0x....      BL       CPU_SR_Save
   \   0000006A   0x0006             MOVS     R6,R0
    421              if (p_sem->Ctr > 0u) {                                      /* Resource available?                                  */
   \   0000006C   0x68E0             LDR      R0,[R4, #+12]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD014             BEQ.N    ??OSSemPend_7
    422                  p_sem->Ctr--;                                           /* Yes, caller may proceed                              */
   \   00000072   0x68E0             LDR      R0,[R4, #+12]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x60E0             STR      R0,[R4, #+12]
    423          #if (OS_CFG_TS_EN > 0u)
    424                  if (p_ts != (CPU_TS *)0) {
    425                     *p_ts = p_sem->TS;                                   /* get timestamp of last post                           */
    426                  }
    427          #endif
    428                  ctr   = p_sem->Ctr;
   \   00000078   0x68E4             LDR      R4,[R4, #+12]
    429                  OS_TRACE_SEM_PEND(p_sem);
    430                  CPU_CRITICAL_EXIT();
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
    431                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_NONE);
    432                 *p_err = OS_ERR_NONE;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x8028             STRH     R0,[R5, #+0]
    433                  return (ctr);
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0xE044             B.N      ??OSSemPend_1
    434              }
   \                     ??OSSemPend_5: (+1)
   \   00000088   0xF645 0x6025      MOVW     R0,#+24101
   \   0000008C   0x8028             STRH     R0,[R5, #+0]
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE03F             B.N      ??OSSemPend_1
   \                     ??OSSemPend_6: (+1)
   \   00000092   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000096   0x8028             STRH     R0,[R5, #+0]
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE03A             B.N      ??OSSemPend_1
    435          
    436              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSSemPend_7: (+1)
   \   0000009C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000A0   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   000000A4   0xD508             BPL.N    ??OSSemPend_8
    437          #if (OS_CFG_TS_EN > 0u)
    438                  if (p_ts != (CPU_TS *)0) {
    439                     *p_ts = 0u;
    440                  }
    441          #endif
    442                  ctr   = p_sem->Ctr;                                     /* No                                                   */
   \   000000A6   0x68E4             LDR      R4,[R4, #+12]
    443                  CPU_CRITICAL_EXIT();
   \   000000A8   0x0030             MOVS     R0,R6
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    444                  OS_TRACE_SEM_PEND_FAILED(p_sem);
    445                  OS_TRACE_SEM_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    446                 *p_err = OS_ERR_PEND_WOULD_BLOCK;
   \   000000AE   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000B2   0x8028             STRH     R0,[R5, #+0]
    447                  return (ctr);
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xE02C             B.N      ??OSSemPend_1
    448              } else {                                                    /* Yes                                                  */
    449                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSSemPend_8: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable6_3
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD007             BEQ.N    ??OSSemPend_9
    450          #if (OS_CFG_TS_EN > 0u)
    451                      if (p_ts != (CPU_TS *)0) {
    452                         *p_ts = 0u;
    453                      }
    454          #endif
    455                      CPU_CRITICAL_EXIT();
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    456                      OS_TRACE_SEM_PEND_FAILED(p_sem);
    457                      OS_TRACE_SEM_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    458                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000C6   0xF646 0x5063      MOVW     R0,#+28003
   \   000000CA   0x8028             STRH     R0,[R5, #+0]
    459                      return (0u);
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0xE020             B.N      ??OSSemPend_1
    460                  }
    461              }
    462          
    463              OS_Pend((OS_PEND_OBJ *)((void *)p_sem),                     /* Block task pending on Semaphore                      */
    464                      OSTCBCurPtr,
    465                      OS_TASK_PEND_ON_SEM,
    466                      timeout);
   \                     ??OSSemPend_9: (+1)
   \   000000D0   0x003B             MOVS     R3,R7
   \   000000D2   0x2206             MOVS     R2,#+6
   \   000000D4   0x....             LDR.N    R0,??DataTable6_4
   \   000000D6   0x6801             LDR      R1,[R0, #+0]
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       OS_Pend
    467              CPU_CRITICAL_EXIT();
   \   000000DE   0x0030             MOVS     R0,R6
   \   000000E0   0x.... 0x....      BL       CPU_SR_Restore
    468              OS_TRACE_SEM_PEND_BLOCK(p_sem);
    469              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   000000E4   0x.... 0x....      BL       OSSched
    470          
    471              CPU_CRITICAL_ENTER();
   \   000000E8   0x2040             MOVS     R0,#+64
   \   000000EA   0x.... 0x....      BL       CPU_SR_Save
    472              switch (OSTCBCurPtr->PendStatus) {
   \   000000EE   0x....             LDR.N    R1,??DataTable6_4
   \   000000F0   0x6809             LDR      R1,[R1, #+0]
   \   000000F2   0xF891 0x102D      LDRB     R1,[R1, #+45]
   \   000000F6   0x2900             CMP      R1,#+0
   \   000000F8   0xD005             BEQ.N    ??OSSemPend_10
   \   000000FA   0x2902             CMP      R1,#+2
   \   000000FC   0xD013             BEQ.N    ??OSSemPend_11
   \   000000FE   0xD30A             BCC.N    ??OSSemPend_12
   \   00000100   0x2903             CMP      R1,#+3
   \   00000102   0xD00C             BEQ.N    ??OSSemPend_13
   \   00000104   0xE013             B.N      ??OSSemPend_14
    473                  case OS_STATUS_PEND_OK:                                 /* We got the semaphore                                 */
    474          #if (OS_CFG_TS_EN > 0u)
    475                       if (p_ts != (CPU_TS *)0) {
    476                          *p_ts = OSTCBCurPtr->TS;
    477                       }
    478          #endif
    479                       OS_TRACE_SEM_PEND(p_sem);
    480                      *p_err = OS_ERR_NONE;
   \                     ??OSSemPend_10: (+1)
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x8029             STRH     R1,[R5, #+0]
    481                       break;
    482          
    483                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    484          #if (OS_CFG_TS_EN > 0u)
    485                       if (p_ts != (CPU_TS *)0) {
    486                          *p_ts = OSTCBCurPtr->TS;
    487                       }
    488          #endif
    489                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    490                      *p_err = OS_ERR_PEND_ABORT;
    491                       break;
    492          
    493                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
    494          #if (OS_CFG_TS_EN > 0u)
    495                       if (p_ts != (CPU_TS *)0) {
    496                          *p_ts = 0u;
    497                       }
    498          #endif
    499                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    500                      *p_err = OS_ERR_TIMEOUT;
    501                       break;
    502          
    503                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    504          #if (OS_CFG_TS_EN > 0u)
    505                       if (p_ts != (CPU_TS *)0) {
    506                          *p_ts = OSTCBCurPtr->TS;
    507                       }
    508          #endif
    509                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    510                      *p_err = OS_ERR_OBJ_DEL;
    511                       break;
    512          
    513                  default:
    514                       OS_TRACE_SEM_PEND_FAILED(p_sem);
    515                      *p_err = OS_ERR_STATUS_INVALID;
    516                       CPU_CRITICAL_EXIT();
    517                       OS_TRACE_SEM_PEND_EXIT(*p_err);
    518                       return (0u);
    519              }
    520              ctr = p_sem->Ctr;
   \                     ??OSSemPend_15: (+1)
   \   0000010A   0x68E4             LDR      R4,[R4, #+12]
    521              CPU_CRITICAL_EXIT();
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
    522              OS_TRACE_SEM_PEND_EXIT(*p_err);
    523              return (ctr);
   \   00000110   0x0020             MOVS     R0,R4
   \                     ??OSSemPend_1: (+1)
   \   00000112   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??OSSemPend_12: (+1)
   \   00000116   0xF246 0x11A9      MOVW     R1,#+25001
   \   0000011A   0x8029             STRH     R1,[R5, #+0]
   \   0000011C   0xE7F5             B.N      ??OSSemPend_15
   \                     ??OSSemPend_13: (+1)
   \   0000011E   0xF247 0x21D9      MOVW     R1,#+29401
   \   00000122   0x8029             STRH     R1,[R5, #+0]
   \   00000124   0xE7F1             B.N      ??OSSemPend_15
   \                     ??OSSemPend_11: (+1)
   \   00000126   0xF645 0x51C2      MOVW     R1,#+24002
   \   0000012A   0x8029             STRH     R1,[R5, #+0]
   \   0000012C   0xE7ED             B.N      ??OSSemPend_15
   \                     ??OSSemPend_14: (+1)
   \   0000012E   0xF646 0x612E      MOVW     R1,#+28206
   \   00000132   0x8029             STRH     R1,[R5, #+0]
   \   00000134   0x.... 0x....      BL       CPU_SR_Restore
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xE7EA             B.N      ??OSSemPend_1
    524          }
    525          
    526          
    527          /*
    528          ************************************************************************************************************************
    529          *                                             ABORT WAITING ON A SEMAPHORE
    530          *
    531          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function should be used
    532          *              to fault-abort the wait on the semaphore, rather than to normally signal the semaphore via OSSemPost().
    533          *
    534          * Arguments  : p_sem     is a pointer to the semaphore
    535          *
    536          *              opt       determines the type of ABORT performed:
    537          *
    538          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the semaphore
    539          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the semaphore
    540          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    541          *
    542          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    543          *
    544          *                            OS_ERR_NONE                  At least one task waiting on the semaphore was readied and
    545          *                                                         informed of the aborted wait; check return value for the
    546          *                                                         number of tasks whose wait on the semaphore was aborted.
    547          *                            OS_ERR_OBJ_PTR_NULL          If 'p_sem' is a NULL pointer.
    548          *                            OS_ERR_OBJ_TYPE              If 'p_sem' is not pointing at a semaphore
    549          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    550          *                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    551          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    552          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    553          *
    554          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    555          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    556          *
    557          * Note(s)    : none
    558          ************************************************************************************************************************
    559          */
    560          
    561          #if (OS_CFG_SEM_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    562          OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
    563                                      OS_OPT   opt,
    564                                      OS_ERR  *p_err)
    565          {
   \                     OSSemPendAbort: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    566              OS_PEND_LIST  *p_pend_list;
    567              OS_TCB        *p_tcb;
    568              CPU_TS         ts;
    569              OS_OBJ_QTY     nbr_tasks;
    570              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    571          
    572          
    573          #ifdef OS_SAFETY_CRITICAL
    574              if (p_err == (OS_ERR *)0) {
    575                  OS_SAFETY_CRITICAL_EXCEPTION();
    576                  return (0u);
    577              }
    578          #endif
    579          
    580          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    581              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000C   0x....             LDR.N    R0,??DataTable6
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSSemPendAbort_0
    582                 *p_err =  OS_ERR_PEND_ABORT_ISR;
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    583                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE059             B.N      ??OSSemPendAbort_1
    584              }
    585          #endif
    586          
    587          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    588              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSSemPendAbort_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable6_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSSemPendAbort_2
    589                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    590                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE050             B.N      ??OSSemPendAbort_1
    591              }
    592          #endif
    593          
    594          #if (OS_CFG_ARG_CHK_EN > 0u)
    595              if (p_sem == (OS_SEM *)0) {                                 /* Validate 'p_sem'                                     */
   \                     ??OSSemPendAbort_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE.N    ??OSSemPendAbort_3
    596                 *p_err =  OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    597                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE049             B.N      ??OSSemPendAbort_1
    598              }
    599              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSSemPendAbort_3: (+1)
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD008             BEQ.N    ??OSSemPendAbort_4
   \   00000046   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004A   0xD005             BEQ.N    ??OSSemPendAbort_4
   \   0000004C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000050   0xD002             BEQ.N    ??OSSemPendAbort_4
   \   00000052   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000056   0xD113             BNE.N    ??OSSemPendAbort_5
    600                  case OS_OPT_PEND_ABORT_1:
    601                  case OS_OPT_PEND_ABORT_ALL:
    602                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    603                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    604                       break;
    605          
    606                  default:
    607                      *p_err =  OS_ERR_OPT_INVALID;
    608                       return (0u);
    609              }
    610          #endif
    611          
    612          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    613              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemPendAbort_4: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x414d4553
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD114             BNE.N    ??OSSemPendAbort_6
    614                 *p_err =  OS_ERR_OBJ_TYPE;
    615                  return (0u);
    616              }
    617          #endif
    618          
    619              CPU_CRITICAL_ENTER();
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x.... 0x....      BL       CPU_SR_Save
   \   00000066   0x0007             MOVS     R7,R0
    620              p_pend_list = &p_sem->PendList;
   \   00000068   0x1D24             ADDS     R4,R4,#+4
    621              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on semaphore?                       */
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD111             BNE.N    ??OSSemPendAbort_7
    622                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    623                 *p_err =  OS_ERR_PEND_ABORT_NONE;
   \   00000076   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000007A   0x8028             STRH     R0,[R5, #+0]
    624                  return (0u);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE028             B.N      ??OSSemPendAbort_1
    625              }
   \                     ??OSSemPendAbort_5: (+1)
   \   00000080   0xF645 0x6025      MOVW     R0,#+24101
   \   00000084   0x8028             STRH     R0,[R5, #+0]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE023             B.N      ??OSSemPendAbort_1
   \                     ??OSSemPendAbort_6: (+1)
   \   0000008A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE01E             B.N      ??OSSemPendAbort_1
    626          
    627              nbr_tasks = 0u;
   \                     ??OSSemPendAbort_7: (+1)
   \   00000094   0xF05F 0x0900      MOVS     R9,#+0
    628          #if (OS_CFG_TS_EN > 0u)
    629              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
    630          #else
    631              ts        = 0u;
   \   00000098   0xF05F 0x0800      MOVS     R8,#+0
    632          #endif
    633              while (p_pend_list->HeadPtr != (OS_TCB *)0) {
   \                     ??OSSemPendAbort_8: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD00B             BEQ.N    ??OSSemPendAbort_9
    634                  p_tcb = p_pend_list->HeadPtr;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
    635                  OS_PendAbort(p_tcb,
    636                               ts,
    637                               OS_STATUS_PEND_ABORT);
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0x4641             MOV      R1,R8
   \   000000A8   0x.... 0x....      BL       OS_PendAbort
    638                  nbr_tasks++;
   \   000000AC   0xF119 0x0901      ADDS     R9,R9,#+1
    639                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000B8   0xD0F0             BEQ.N    ??OSSemPendAbort_8
    640                      break;                                              /* No                                                   */
    641                  }
    642              }
    643              CPU_CRITICAL_EXIT();
   \                     ??OSSemPendAbort_9: (+1)
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    644          
    645              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000C0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C2   0x0430             LSLS     R0,R6,#+16
   \   000000C4   0xD401             BMI.N    ??OSSemPendAbort_10
    646                  OSSched();                                              /* Run the scheduler                                    */
   \   000000C6   0x.... 0x....      BL       OSSched
    647              }
    648          
    649             *p_err = OS_ERR_NONE;
   \                     ??OSSemPendAbort_10: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    650              return (nbr_tasks);
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSSemPendAbort_1: (+1)
   \   000000D2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    651          }
    652          #endif
    653          
    654          
    655          /*
    656          ************************************************************************************************************************
    657          *                                                 POST TO A SEMAPHORE
    658          *
    659          * Description: This function signals a semaphore.
    660          *
    661          * Arguments  : p_sem    is a pointer to the semaphore
    662          *
    663          *              opt      determines the type of POST performed:
    664          *
    665          *                           OS_OPT_POST_1            POST and ready only the highest priority task waiting on semaphore
    666          *                                                    (if tasks are waiting).
    667          *                           OS_OPT_POST_ALL          POST to ALL tasks that are waiting on the semaphore
    668          *
    669          *                           OS_OPT_POST_NO_SCHED     Do not call the scheduler
    670          *
    671          *
    672          *              p_err    is a pointer to a variable that will contain an error code returned by this function.
    673          *
    674          *                           OS_ERR_NONE              The call was successful and the semaphore was signaled
    675          *                           OS_ERR_OBJ_PTR_NULL      If 'p_sem' is a NULL pointer
    676          *                           OS_ERR_OBJ_TYPE          If 'p_sem' is not pointing at a semaphore
    677          *                           OS_ERR_OPT_INVALID       If you specified an invalid option
    678          *                           OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    679          *                           OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow
    680          *
    681          * Returns    : The current value of the semaphore counter or 0 upon error.
    682          *
    683          * Note(s)    : 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
    684          ************************************************************************************************************************
    685          */
    686          

   \                                 In section .text, align 2, keep-with-next
    687          OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
    688                                 OS_OPT   opt,
    689                                 OS_ERR  *p_err)
    690          {
   \                     OSSemPost: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0015             MOVS     R5,R2
    691              OS_SEM_CTR     ctr;
    692              OS_PEND_LIST  *p_pend_list;
    693              OS_TCB        *p_tcb;
    694              OS_TCB        *p_tcb_next;
    695              CPU_TS         ts;
    696              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    697          
    698          
    699          #ifdef OS_SAFETY_CRITICAL
    700              if (p_err == (OS_ERR *)0) {
    701                  OS_SAFETY_CRITICAL_EXCEPTION();
    702                  return (0u);
    703              }
    704          #endif
    705          
    706              OS_TRACE_SEM_POST_ENTER(p_sem, opt);
    707          
    708          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    709              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   0000000C   0x....             LDR.N    R0,??DataTable6_2
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ.N    ??OSSemPost_0
    710                  OS_TRACE_SEM_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    711                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000014   0xF645 0x6089      MOVW     R0,#+24201
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    712                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE05F             B.N      ??OSSemPost_1
    713              }
    714          #endif
    715          
    716          #if (OS_CFG_ARG_CHK_EN > 0u)
    717              if (p_sem == (OS_SEM *)0) {                                 /* Validate 'p_sem'                                     */
   \                     ??OSSemPost_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD104             BNE.N    ??OSSemPost_2
    718                  OS_TRACE_SEM_POST_FAILED(p_sem);
    719                  OS_TRACE_SEM_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    720                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000022   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000026   0x8028             STRH     R0,[R5, #+0]
    721                  return (0u);
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xE058             B.N      ??OSSemPost_1
    722              }
    723              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSSemPost_2: (+1)
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD008             BEQ.N    ??OSSemPost_3
   \   00000034   0xF5B0 0x7F00      CMP      R0,#+512
   \   00000038   0xD005             BEQ.N    ??OSSemPost_3
   \   0000003A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003E   0xD002             BEQ.N    ??OSSemPost_3
   \   00000040   0xF5B0 0x4F02      CMP      R0,#+33280
   \   00000044   0xD118             BNE.N    ??OSSemPost_4
    724                  case OS_OPT_POST_1:
    725                  case OS_OPT_POST_ALL:
    726                  case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
    727                  case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
    728                       break;
    729          
    730                  default:
    731                       OS_TRACE_SEM_POST_FAILED(p_sem);
    732                       OS_TRACE_SEM_POST_EXIT(OS_ERR_OPT_INVALID);
    733                      *p_err =  OS_ERR_OPT_INVALID;
    734                       return (0u);
    735              }
    736          #endif
    737          
    738          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    739              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemPost_3: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x....             LDR.N    R1,??DataTable6_1  ;; 0x414d4553
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD119             BNE.N    ??OSSemPost_5
    740                  OS_TRACE_SEM_POST_FAILED(p_sem);
    741                  OS_TRACE_SEM_POST_EXIT(OS_ERR_OBJ_TYPE);
    742                 *p_err = OS_ERR_OBJ_TYPE;
    743                  return (0u);
    744              }
    745          #endif
    746          #if (OS_CFG_TS_EN > 0u)
    747              ts = OS_TS_GET();                                           /* Get timestamp                                        */
    748          #else
    749              ts = 0u;
   \   0000004E   0x2700             MOVS     R7,#+0
    750          #endif
    751          
    752              OS_TRACE_SEM_POST(p_sem);
    753              CPU_CRITICAL_ENTER();
   \   00000050   0x2040             MOVS     R0,#+64
   \   00000052   0x.... 0x....      BL       CPU_SR_Save
   \   00000056   0x0006             MOVS     R6,R0
    754              p_pend_list = &p_sem->PendList;
   \   00000058   0x1D21             ADDS     R1,R4,#+4
    755              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on semaphore?                       */
   \   0000005A   0x6808             LDR      R0,[R1, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD120             BNE.N    ??OSSemPost_6
    756                  if (p_sem->Ctr == (OS_SEM_CTR)-1) {
   \   00000060   0x68E0             LDR      R0,[R4, #+12]
   \   00000062   0xF110 0x0F01      CMN      R0,#+1
   \   00000066   0xD111             BNE.N    ??OSSemPost_7
    757                     CPU_CRITICAL_EXIT();
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    758                    *p_err = OS_ERR_SEM_OVF;
   \   0000006E   0xF646 0x50C5      MOVW     R0,#+28101
   \   00000072   0x8028             STRH     R0,[R5, #+0]
    759                     OS_TRACE_SEM_POST_EXIT(*p_err);
    760                     return (0u);
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xE032             B.N      ??OSSemPost_1
    761                  }
   \                     ??OSSemPost_4: (+1)
   \   00000078   0xF645 0x6025      MOVW     R0,#+24101
   \   0000007C   0x8028             STRH     R0,[R5, #+0]
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE02D             B.N      ??OSSemPost_1
   \                     ??OSSemPost_5: (+1)
   \   00000082   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000086   0x8028             STRH     R0,[R5, #+0]
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE028             B.N      ??OSSemPost_1
    762                  p_sem->Ctr++;                                           /* No                                                   */
   \                     ??OSSemPost_7: (+1)
   \   0000008C   0x68E0             LDR      R0,[R4, #+12]
   \   0000008E   0x1C40             ADDS     R0,R0,#+1
   \   00000090   0x60E0             STR      R0,[R4, #+12]
    763                  ctr       = p_sem->Ctr;
   \   00000092   0x68E4             LDR      R4,[R4, #+12]
    764          #if (OS_CFG_TS_EN > 0u)
    765                  p_sem->TS = ts;                                         /* Save timestamp in semaphore control block            */
    766          #endif
    767                  CPU_CRITICAL_EXIT();
   \   00000094   0x0030             MOVS     R0,R6
   \   00000096   0x.... 0x....      BL       CPU_SR_Restore
    768                 *p_err     = OS_ERR_NONE;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x8028             STRH     R0,[R5, #+0]
    769                  OS_TRACE_SEM_POST_EXIT(*p_err);
    770                  return (ctr);
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0xE01D             B.N      ??OSSemPost_1
    771              }
    772          
    773              p_tcb = p_pend_list->HeadPtr;
   \                     ??OSSemPost_6: (+1)
   \   000000A2   0x6809             LDR      R1,[R1, #+0]
   \   000000A4   0xE000             B.N      ??OSSemPost_8
    774              while (p_tcb != (OS_TCB *)0) {
    775                  p_tcb_next = p_tcb->PendNextPtr;
    776                  OS_Post((OS_PEND_OBJ *)((void *)p_sem),
    777                          p_tcb,
    778                          (void *)0,
    779                          0u,
    780                          ts);
    781                  if ((opt & OS_OPT_POST_ALL) == 0u) {                     /* Post to all tasks waiting?                           */
    782                      break;                                              /* No                                                   */
    783                  }
    784                  p_tcb = p_tcb_next;
   \                     ??OSSemPost_9: (+1)
   \   000000A6   0x4649             MOV      R1,R9
   \                     ??OSSemPost_8: (+1)
   \   000000A8   0x2900             CMP      R1,#+0
   \   000000AA   0xD00B             BEQ.N    ??OSSemPost_10
   \   000000AC   0xF8D1 0x9020      LDR      R9,[R1, #+32]
   \   000000B0   0x9700             STR      R7,[SP, #+0]
   \   000000B2   0x2300             MOVS     R3,#+0
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       OS_Post
   \   000000BC   0x4640             MOV      R0,R8
   \   000000BE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C0   0x0580             LSLS     R0,R0,#+22
   \   000000C2   0xD4F0             BMI.N    ??OSSemPost_9
    785              }
    786              CPU_CRITICAL_EXIT();
   \                     ??OSSemPost_10: (+1)
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0x.... 0x....      BL       CPU_SR_Restore
    787              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000CA   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000CE   0xEA5F 0x4008      LSLS     R0,R8,#+16
   \   000000D2   0xD401             BMI.N    ??OSSemPost_11
    788                  OSSched();                                              /* Run the scheduler                                    */
   \   000000D4   0x.... 0x....      BL       OSSched
    789              }
    790             *p_err = OS_ERR_NONE;
   \                     ??OSSemPost_11: (+1)
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x8028             STRH     R0,[R5, #+0]
    791          
    792              OS_TRACE_SEM_POST_EXIT(*p_err);
    793              return (0u);
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??OSSemPost_1: (+1)
   \   000000DE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    794          }
    795          
    796          
    797          /*
    798          ************************************************************************************************************************
    799          *                                                    SET SEMAPHORE
    800          *
    801          * Description: This function sets the semaphore count to the value specified as an argument.  Typically, this value
    802          *              would be 0 but of course, we can set the semaphore to any value.
    803          *
    804          *              You would typically use this function when a semaphore is used as a signaling mechanism
    805          *              and, you want to reset the count value.
    806          *
    807          * Arguments  : p_sem     is a pointer to the semaphore
    808          *
    809          *              cnt       is the new value for the semaphore count.  You would pass 0 to reset the semaphore count.
    810          *
    811          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    812          *
    813          *                            OS_ERR_NONE           The call was successful and the semaphore value was set
    814          *                            OS_ERR_OBJ_PTR_NULL   If 'p_sem' is a NULL pointer
    815          *                            OS_ERR_OBJ_TYPE       If 'p_sem' is not pointing to a semaphore
    816          *                            OS_ERR_SET_ISR        If called from an ISR
    817          *                            OS_ERR_TASK_WAITING   If tasks are waiting on the semaphore
    818          *
    819          * Returns    : None
    820          *
    821          * Note(s)    : none
    822          ************************************************************************************************************************
    823          */
    824          
    825          #if (OS_CFG_SEM_SET_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    826          void  OSSemSet (OS_SEM      *p_sem,
    827                          OS_SEM_CTR   cnt,
    828                          OS_ERR      *p_err)
    829          {
   \                     OSSemSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    830              OS_PEND_LIST  *p_pend_list;
    831              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
    832          
    833          
    834          #ifdef OS_SAFETY_CRITICAL
    835              if (p_err == (OS_ERR *)0) {
    836                  OS_SAFETY_CRITICAL_EXCEPTION();
    837                  return;
    838              }
    839          #endif
    840          
    841          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    842              if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
   \   0000000A   0x....             LDR.N    R0,??DataTable6
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSSemSet_0
    843                 *p_err = OS_ERR_SET_ISR;
   \   00000012   0xF646 0x50C6      MOVW     R0,#+28102
   \   00000016   0x8030             STRH     R0,[R6, #+0]
    844                  return;
   \   00000018   0xE022             B.N      ??OSSemSet_1
    845              }
    846          #endif
    847          
    848          #if (OS_CFG_ARG_CHK_EN > 0u)
    849              if (p_sem == (OS_SEM *)0) {                                 /* Validate 'p_sem'                                     */
   \                     ??OSSemSet_0: (+1)
   \   0000001A   0x2C00             CMP      R4,#+0
   \   0000001C   0xD103             BNE.N    ??OSSemSet_2
    850                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   0000001E   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000022   0x8030             STRH     R0,[R6, #+0]
    851                  return;
   \   00000024   0xE01C             B.N      ??OSSemSet_1
    852              }
    853          #endif
    854          
    855          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    856              if (p_sem->Type != OS_OBJ_TYPE_SEM) {                       /* Make sure semaphore was created                      */
   \                     ??OSSemSet_2: (+1)
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x....             LDR.N    R1,??DataTable6_1  ;; 0x414d4553
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD003             BEQ.N    ??OSSemSet_3
    857                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000002E   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000032   0x8030             STRH     R0,[R6, #+0]
    858                  return;
   \   00000034   0xE014             B.N      ??OSSemSet_1
    859              }
    860          #endif
    861          
    862             *p_err = OS_ERR_NONE;
   \                     ??OSSemSet_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x8030             STRH     R0,[R6, #+0]
    863              CPU_CRITICAL_ENTER();
   \   0000003A   0x2040             MOVS     R0,#+64
   \   0000003C   0x.... 0x....      BL       CPU_SR_Save
    864              if (p_sem->Ctr > 0u) {                                      /* See if semaphore already has a count                 */
   \   00000040   0x68E1             LDR      R1,[R4, #+12]
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD001             BEQ.N    ??OSSemSet_4
    865                  p_sem->Ctr = cnt;                                       /* Yes, set it to the new value specified.              */
   \   00000046   0x60E5             STR      R5,[R4, #+12]
   \   00000048   0xE008             B.N      ??OSSemSet_5
    866              } else {
    867                  p_pend_list = &p_sem->PendList;                         /* No                                                   */
   \                     ??OSSemSet_4: (+1)
   \   0000004A   0x1D21             ADDS     R1,R4,#+4
    868                  if (p_pend_list->HeadPtr == (OS_TCB *)0) {              /* See if task(s) waiting?                              */
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x2900             CMP      R1,#+0
   \   00000050   0xD101             BNE.N    ??OSSemSet_6
    869                      p_sem->Ctr = cnt;                                   /* No, OK to set the value                              */
   \   00000052   0x60E5             STR      R5,[R4, #+12]
   \   00000054   0xE002             B.N      ??OSSemSet_5
    870                  } else {
    871                     *p_err      = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_6: (+1)
   \   00000056   0xF247 0x115F      MOVW     R1,#+29023
   \   0000005A   0x8031             STRH     R1,[R6, #+0]
    872                  }
    873              }
    874              CPU_CRITICAL_EXIT();
   \                     ??OSSemSet_5: (+1)
   \   0000005C   0x.... 0x....      BL       CPU_SR_Restore
    875          }
   \                     ??OSSemSet_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    876          #endif
    877          
    878          
    879          /*
    880          ************************************************************************************************************************
    881          *                                           CLEAR THE CONTENTS OF A SEMAPHORE
    882          *
    883          * Description: This function is called by OSSemDel() to clear the contents of a semaphore
    884          *
    885          
    886          * Argument(s): p_sem      is a pointer to the semaphore to clear
    887          *              -----
    888          *
    889          * Returns    : none
    890          *
    891          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    892          ************************************************************************************************************************
    893          */
    894          

   \                                 In section .text, align 2, keep-with-next
    895          void  OS_SemClr (OS_SEM  *p_sem)
    896          {
   \                     OS_SemClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    897          #if (OS_OBJ_TYPE_REQ > 0u)
    898              p_sem->Type    = OS_OBJ_TYPE_NONE;                          /* Mark the data structure as a NONE                    */
   \   00000002   0x....             LDR.N    R1,??DataTable6_5  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
    899          #endif
    900              p_sem->Ctr     = 0u;                                        /* Set semaphore value                                  */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    901          #if (OS_CFG_TS_EN > 0u)
    902              p_sem->TS      = 0u;                                        /* Clear the time stamp                                 */
    903          #endif
    904          #if (OS_CFG_DBG_EN > 0u)
    905              p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
    906          #endif
    907              OS_PendListInit(&p_sem->PendList);                          /* Initialize the waiting list                          */
   \   0000000A   0x1D00             ADDS     R0,R0,#+4
   \   0000000C   0x.... 0x....      BL       OS_PendListInit
    908          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x414D4553         DC32     0x414d4553

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e
    909          
    910          
    911          /*
    912          ************************************************************************************************************************
    913          *                                        ADD/REMOVE SEMAPHORE TO/FROM DEBUG LIST
    914          *
    915          * Description: These functions are called by uC/OS-III to add or remove a semaphore to/from the debug list.
    916          *
    917          * Arguments  : p_sem     is a pointer to the semaphore to add/remove
    918          *
    919          * Returns    : none
    920          *
    921          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
    922          ************************************************************************************************************************
    923          */
    924          
    925          #if (OS_CFG_DBG_EN > 0u)
    926          void  OS_SemDbgListAdd (OS_SEM  *p_sem)
    927          {
    928              p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    929              p_sem->DbgPrevPtr               = (OS_SEM *)0;
    930              if (OSSemDbgListPtr == (OS_SEM *)0) {
    931                  p_sem->DbgNextPtr           = (OS_SEM *)0;
    932              } else {
    933                  p_sem->DbgNextPtr           =  OSSemDbgListPtr;
    934                  OSSemDbgListPtr->DbgPrevPtr =  p_sem;
    935              }
    936              OSSemDbgListPtr                 =  p_sem;
    937          }
    938          
    939          
    940          void  OS_SemDbgListRemove (OS_SEM  *p_sem)
    941          {
    942              OS_SEM  *p_sem_next;
    943              OS_SEM  *p_sem_prev;
    944          
    945          
    946              p_sem_prev = p_sem->DbgPrevPtr;
    947              p_sem_next = p_sem->DbgNextPtr;
    948          
    949              if (p_sem_prev == (OS_SEM *)0) {
    950                  OSSemDbgListPtr = p_sem_next;
    951                  if (p_sem_next != (OS_SEM *)0) {
    952                      p_sem_next->DbgPrevPtr = (OS_SEM *)0;
    953                  }
    954                  p_sem->DbgNextPtr = (OS_SEM *)0;
    955          
    956              } else if (p_sem_next == (OS_SEM *)0) {
    957                  p_sem_prev->DbgNextPtr = (OS_SEM *)0;
    958                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
    959          
    960              } else {
    961                  p_sem_prev->DbgNextPtr =  p_sem_next;
    962                  p_sem_next->DbgPrevPtr =  p_sem_prev;
    963                  p_sem->DbgNextPtr      = (OS_SEM *)0;
    964                  p_sem->DbgPrevPtr      = (OS_SEM *)0;
    965              }
    966          }
    967          #endif
    968          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSSemCreate
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_PendListInit
      32   OSSemDel
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
        32   -> OS_SemClr
      24   OSSemPend
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_Pend
      32   OSSemPendAbort
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      32   OSSemPost
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Post
      16   OSSemSet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       8   OS_SemClr
         8   -> OS_PendListInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
      98  OSSemCreate
     228  OSSemDel
     316  OSSemPend
     214  OSSemPendAbort
     226  OSSemPost
      98  OSSemSet
      18  OS_SemClr

 
 1 222 bytes in section .text
 
 1 222 bytes of CODE memory

Errors: none
Warnings: none
