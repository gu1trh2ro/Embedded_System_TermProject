###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:36
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\lib_mem.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW365D.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\lib_mem.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\lib_mem.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\lib_mem.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/LIB
      4          *                                       Custom Library Modules
      5          *
      6          *                    Copyright 2004-2021 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *
     20          *                                     STANDARD MEMORY OPERATIONS
     21          *
     22          * Filename : lib_mem.c
     23          * Version  : V1.39.01
     24          *********************************************************************************************************
     25          * Note(s)  : (1) NO compiler-supplied standard library functions are used in library or product software.
     26          *
     27          *                (a) ALL standard library functions are implemented in the custom library modules :
     28          *
     29          *                    (1) \<Custom Library Directory>\lib_*.*
     30          *
     31          *                    (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     32          *
     33          *                          where
     34          *                                  <Custom Library Directory>      directory path for custom library software
     35          *                                  <cpu>                           directory name for specific processor (CPU)
     36          *                                  <compiler>                      directory name for specific compiler
     37          *
     38          *                (b) Product-specific library functions are implemented in individual products.
     39          *********************************************************************************************************
     40          */
     41          
     42          /*
     43          *********************************************************************************************************
     44          *                                            INCLUDE FILES
     45          *********************************************************************************************************
     46          */
     47          
     48          #define    MICRIUM_SOURCE
     49          #define    LIB_MEM_MODULE
     50          #include  "lib_mem.h"
     51          #include  "lib_math.h"
     52          #include  "lib_str.h"
     53          
     54          
     55          /*
     56          *********************************************************************************************************
     57          *                                            LOCAL DEFINES
     58          *********************************************************************************************************
     59          */
     60          
     61          
     62          /*
     63          *********************************************************************************************************
     64          *                                           LOCAL CONSTANTS
     65          *********************************************************************************************************
     66          */
     67          
     68          
     69          /*
     70          *********************************************************************************************************
     71          *                                          LOCAL DATA TYPES
     72          *********************************************************************************************************
     73          */
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                            LOCAL TABLES
     79          *********************************************************************************************************
     80          */
     81          
     82          
     83          /*
     84          *********************************************************************************************************
     85          *                                       LOCAL GLOBAL VARIABLES
     86          *********************************************************************************************************
     87          */
     88          
     89          
     90          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
     91          #ifndef  LIB_MEM_CFG_HEAP_BASE_ADDR

   \                                 In section .bss, align 4
     92          CPU_INT08U   Mem_Heap[LIB_MEM_CFG_HEAP_SIZE];                   /* Mem heap.                                            */
   \                     Mem_Heap:
   \   00000000                      DS8 1024
     93          #endif
     94          

   \                                 In section .bss, align 4
     95          MEM_SEG      Mem_SegHeap;                                       /* Heap mem seg.                                        */
   \                     Mem_SegHeap:
   \   00000000                      DS8 20
     96          #endif
     97          

   \                                 In section .bss, align 4
     98          MEM_SEG     *Mem_SegHeadPtr;                                    /* Ptr to head of seg list.                             */
   \                     Mem_SegHeadPtr:
   \   00000000                      DS8 4
     99          
    100          
    101          /*
    102          *********************************************************************************************************
    103          *                                      LOCAL FUNCTION PROTOTYPES
    104          *********************************************************************************************************
    105          */
    106          
    107          static  void          Mem_SegCreateCritical    (const  CPU_CHAR      *p_name,
    108                                                                 MEM_SEG       *p_seg,
    109                                                                 CPU_ADDR       seg_base_addr,
    110                                                                 CPU_SIZE_T     padding_align,
    111                                                                 CPU_SIZE_T     size);
    112          
    113          #if  (LIB_MEM_CFG_HEAP_SIZE > 0u)
    114          static  MEM_SEG      *Mem_SegOverlapChkCritical(       CPU_ADDR       seg_base_addr,
    115                                                                 CPU_SIZE_T     size,
    116                                                                 LIB_ERR       *p_err);
    117          #endif
    118          
    119          static  void         *Mem_SegAllocInternal     (const  CPU_CHAR      *p_name,
    120                                                                 MEM_SEG       *p_seg,
    121                                                                 CPU_SIZE_T     size,
    122                                                                 CPU_SIZE_T     align,
    123                                                                 CPU_SIZE_T     padding_align,
    124                                                                 CPU_SIZE_T    *p_bytes_reqd,
    125                                                                 LIB_ERR       *p_err);
    126          
    127          static  void         *Mem_SegAllocExtCritical  (       MEM_SEG       *p_seg,
    128                                                                 CPU_SIZE_T     size,
    129                                                                 CPU_SIZE_T     align,
    130                                                                 CPU_SIZE_T     padding_align,
    131                                                                 CPU_SIZE_T    *p_bytes_reqd,
    132                                                                 LIB_ERR       *p_err);
    133          
    134          static  void          Mem_DynPoolCreateInternal(const  CPU_CHAR      *p_name,
    135                                                                 MEM_DYN_POOL  *p_pool,
    136                                                                 MEM_SEG       *p_seg,
    137                                                                 CPU_SIZE_T     blk_size,
    138                                                                 CPU_SIZE_T     blk_align,
    139                                                                 CPU_SIZE_T     blk_padding_align,
    140                                                                 CPU_SIZE_T     blk_qty_init,
    141                                                                 CPU_SIZE_T     blk_qty_max,
    142                                                                 LIB_ERR       *p_err);
    143          
    144          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
    145          static  void          Mem_SegAllocTrackCritical(const  CPU_CHAR      *p_name,
    146                                                                 MEM_SEG       *p_seg,
    147                                                                 CPU_SIZE_T     size,
    148                                                                 LIB_ERR       *p_err);
    149          #endif
    150          
    151          #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
    152               (LIB_MEM_CFG_HEAP_SIZE      >  0u))
    153          static  CPU_BOOLEAN   Mem_PoolBlkIsValidAddr   (       MEM_POOL      *p_pool,
    154                                                                 void          *p_mem);
    155          #endif
    156          
    157          
    158          /*
    159          *********************************************************************************************************
    160          *                                     LOCAL CONFIGURATION ERRORS
    161          *********************************************************************************************************
    162          */
    163          
    164          /*
    165          *********************************************************************************************************
    166          *********************************************************************************************************
    167          *                                            GLOBAL FUNCTIONS
    168          *********************************************************************************************************
    169          *********************************************************************************************************
    170          */
    171          
    172          /*
    173          *********************************************************************************************************
    174          *                                             Mem_Init()
    175          *
    176          * Description : (1) Initializes Memory Management Module :
    177          *
    178          *                   (a) Initialize heap memory pool
    179          *                   (b) Initialize      memory pool table
    180          *
    181          *
    182          * Argument(s) : none.
    183          *
    184          * Return(s)   : none.
    185          *
    186          * Caller(s)   : Application.
    187          *
    188          * Note(s)     : (2) Mem_Init() MUST be called ... :
    189          *
    190          *                   (a) ONLY ONCE from a product's application; ...
    191          *                   (b) BEFORE product's application calls any memory library module function(s)
    192          *********************************************************************************************************
    193          */
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void  Mem_Init (void)
    196          {
   \                     Mem_Init: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    197          
    198                                                                          /* ------------------ INIT SEG LIST ------------------- */
    199              Mem_SegHeadPtr = DEF_NULL;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000008   0x6008             STR      R0,[R1, #+0]
    200          
    201          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
    202              {
    203                  LIB_ERR   err;
    204                  CPU_ADDR  heap_base_addr;
    205          
    206          
    207                                                                          /* ------------------ INIT HEAP SEG ------------------- */
    208          #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    209                  heap_base_addr = LIB_MEM_CFG_HEAP_BASE_ADDR;
    210          #else
    211                  heap_base_addr = (CPU_ADDR)&Mem_Heap[0u];
   \   0000000A   0x.... 0x....      LDR.W    R2,??DataTable12_1
    212          #endif
    213          
    214                  Mem_SegCreate("Heap",
    215                                &Mem_SegHeap,                             /* Create heap seg.                                     */
    216                                 heap_base_addr,
    217                                 LIB_MEM_CFG_HEAP_SIZE,
    218                                 LIB_MEM_PADDING_ALIGN_NONE,
    219                                &err);
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x9001             STR      R0,[SP, #+4]
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0xF44F 0x6380      MOV      R3,#+1024
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   00000022   0x.... 0x....      BL       Mem_SegCreate
    220                  if (err != LIB_MEM_ERR_NONE) {
   \   00000026   0xF9BD 0x0008      LDRSH    R0,[SP, #+8]
   \   0000002A   0xF242 0x7110      MOVW     R1,#+10000
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD001             BEQ.N    ??Mem_Init_0
    221                      CPU_SW_EXCEPTION(;);
   \   00000032   0x.... 0x....      BL       CPU_SW_Exception
    222                  }
    223              }
    224          #endif
    225          }
   \                     ??Mem_Init_0: (+1)
   \   00000036   0xBD07             POP      {R0-R2,PC}       ;; return
    226          
    227          
    228          /*
    229          *********************************************************************************************************
    230          *                                              Mem_Clr()
    231          *
    232          * Description : Clears data buffer (see Note #2).
    233          *
    234          * Argument(s) : pmem        Pointer to memory buffer to clear.
    235          *
    236          *               size        Number of data buffer octets to clear (see Note #1).
    237          *
    238          * Return(s)   : none.
    239          *
    240          * Caller(s)   : Application.
    241          *
    242          * Note(s)     : (1) Null clears allowed (i.e. zero-length clears).
    243          *
    244          *                   See also 'Mem_Set()  Note #1'.
    245          *
    246          *               (2) Clear data by setting each data octet to 0.
    247          *********************************************************************************************************
    248          */
    249          

   \                                 In section .text, align 2, keep-with-next
    250          void  Mem_Clr (void        *pmem,
    251                         CPU_SIZE_T   size)
    252          {
   \                     Mem_Clr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x000A             MOVS     R2,R1
    253              Mem_Set(pmem,
    254                      0u,                                                 /* See Note #2.                                         */
    255                      size);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       Mem_Set
    256          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    257          
    258          
    259          /*
    260          *********************************************************************************************************
    261          *                                              Mem_Set()
    262          *
    263          * Description : Fills data buffer with specified data octet.
    264          *
    265          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    266          *
    267          *               data_val    Data fill octet value.
    268          *
    269          *               size        Number of data buffer octets to fill (see Note #1).
    270          *
    271          * Return(s)   : none.
    272          *
    273          * Caller(s)   : Application.
    274          *
    275          * Note(s)     : (1) Null sets allowed (i.e. zero-length sets).
    276          *
    277          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data
    278          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    279          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    280          *                   addresses.
    281          *
    282          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    283          *                   address boundary.
    284          *
    285          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    286          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    287          *                  'mem_align_mod' arithmetic operation.
    288          *********************************************************************************************************
    289          */
    290          

   \                                 In section .text, align 2, keep-with-next
    291          void  Mem_Set (void        *pmem,
    292                         CPU_INT08U   data_val,
    293                         CPU_SIZE_T   size)
    294          {
   \                     Mem_Set: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    295              CPU_SIZE_T   size_rem;
    296              CPU_ALIGN    data_align;
    297              CPU_ALIGN   *pmem_align;
    298              CPU_INT08U  *pmem_08;
    299              CPU_DATA     mem_align_mod;
    300              CPU_DATA     i;
    301          
    302          
    303          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    304              if (size < 1) {                                             /* See Note #1.                                         */
    305                  return;
    306              }
    307              if (pmem == (void *)0) {
    308                  return;
    309              }
    310          #endif
    311          
    312          
    313              data_align = 0u;
   \   00000002   0x2400             MOVS     R4,#+0
    314              for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0xE004             B.N      ??Mem_Set_0
    315                  data_align <<=  DEF_OCTET_NBR_BITS;
   \                     ??Mem_Set_1: (+1)
   \   00000008   0x0224             LSLS     R4,R4,#+8
    316                  data_align  |= (CPU_ALIGN)data_val;
   \   0000000A   0x000B             MOVS     R3,R1
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0x431C             ORRS     R4,R3,R4
    317              }
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \                     ??Mem_Set_0: (+1)
   \   00000012   0x2D04             CMP      R5,#+4
   \   00000014   0xD3F8             BCC.N    ??Mem_Set_1
    318          
    319              size_rem      =  size;
    320              mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
   \   00000016   0xF010 0x0303      ANDS     R3,R0,#0x3
    321          
    322              pmem_08 = (CPU_INT08U *)pmem;
    323              if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD008             BEQ.N    ??Mem_Set_2
    324                  i = mem_align_mod;
   \   0000001E   0xE003             B.N      ??Mem_Set_3
    325                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    326                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    327                     *pmem_08++ = data_val;
   \                     ??Mem_Set_4: (+1)
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
    328                      size_rem -= sizeof(CPU_INT08U);
   \   00000024   0x1E52             SUBS     R2,R2,#+1
    329                      i++;
   \   00000026   0x1C5B             ADDS     R3,R3,#+1
    330                  }
   \                     ??Mem_Set_3: (+1)
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xD001             BEQ.N    ??Mem_Set_2
   \   0000002C   0x2B04             CMP      R3,#+4
   \   0000002E   0xD3F7             BCC.N    ??Mem_Set_4
    331              }
    332          
    333              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2.                                         */
   \                     ??Mem_Set_2: (+1)
   \   00000030   0xE002             B.N      ??Mem_Set_5
    334              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    335                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \                     ??Mem_Set_6: (+1)
   \   00000032   0x6004             STR      R4,[R0, #+0]
   \   00000034   0x1D00             ADDS     R0,R0,#+4
    336                  size_rem    -= sizeof(CPU_ALIGN);
   \   00000036   0x1F12             SUBS     R2,R2,#+4
    337              }
   \                     ??Mem_Set_5: (+1)
   \   00000038   0x2A04             CMP      R2,#+4
   \   0000003A   0xD2FA             BCS.N    ??Mem_Set_6
    338          
    339              pmem_08 = (CPU_INT08U *)pmem_align;
   \   0000003C   0xE002             B.N      ??Mem_Set_7
    340              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
    341                 *pmem_08++   = data_val;
   \                     ??Mem_Set_8: (+1)
   \   0000003E   0x7001             STRB     R1,[R0, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
    342                  size_rem   -= sizeof(CPU_INT08U);
   \   00000042   0x1E52             SUBS     R2,R2,#+1
    343              }
   \                     ??Mem_Set_7: (+1)
   \   00000044   0x2A00             CMP      R2,#+0
   \   00000046   0xD1FA             BNE.N    ??Mem_Set_8
    344          }
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    345          
    346          
    347          /*
    348          *********************************************************************************************************
    349          *                                             Mem_Copy()
    350          *
    351          * Description : Copies data octets from one memory buffer to another memory buffer.
    352          *
    353          * Argument(s) : pdest       Pointer to destination memory buffer.
    354          *
    355          *               psrc        Pointer to source      memory buffer.
    356          *
    357          *               size        Number of octets to copy (see Note #1).
    358          *
    359          * Return(s)   : none.
    360          *
    361          * Caller(s)   : Application.
    362          *
    363          * Note(s)     : (1) Null copies allowed (i.e. zero-length copies).
    364          *
    365          *               (2) Memory buffers NOT checked for overlapping.
    366          *
    367          *                   (a) IEEE Std 1003.1, 2004 Edition, Section 'memcpy() : DESCRIPTION' states that "if
    368          *                       copying takes place between objects that overlap, the behavior is undefined".
    369          *
    370          *                   (b) However, data octets from a source memory buffer at a higher address value SHOULD
    371          *                       successfully copy to a destination memory buffer at a lower  address value even
    372          *                       if any octets of the memory buffers overlap as long as no individual, atomic CPU
    373          *                       word copy overlaps.
    374          *
    375          *                       Since Mem_Copy() performs the data octet copy via 'CPU_ALIGN'-sized words &/or
    376          *                       octets; & since 'CPU_ALIGN'-sized words MUST be accessed on word-aligned addresses
    377          *                       (see Note #3b), neither 'CPU_ALIGN'-sized words nor octets at unique addresses can
    378          *                       ever overlap.
    379          *
    380          *                       Therefore, Mem_Copy() SHOULD be able to successfully copy overlapping memory
    381          *                       buffers as long as the source memory buffer is at a higher address value than the
    382          *                       destination memory buffer.
    383          *
    384          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    385          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    386          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    387          *                   addresses.
    388          *
    389          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    390          *                   address boundary.
    391          *
    392          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    393          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    394          *                  'mem_align_mod' arithmetic operation.
    395          *********************************************************************************************************
    396          */
    397          
    398          #if (LIB_MEM_CFG_OPTIMIZE_ASM_EN != DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    399          void  Mem_Copy (       void        *pdest,
    400                          const  void        *psrc,
    401                                 CPU_SIZE_T   size)
    402          {
   \                     Mem_Copy: (+1)
   \   00000000   0xB410             PUSH     {R4}
    403                     CPU_SIZE_T    size_rem;
    404                     CPU_SIZE_T    mem_gap_octets;
    405                     CPU_ALIGN    *pmem_align_dest;
    406              const  CPU_ALIGN    *pmem_align_src;
    407                     CPU_INT08U   *pmem_08_dest;
    408              const  CPU_INT08U   *pmem_08_src;
    409                     CPU_DATA      i;
    410                     CPU_DATA      mem_align_mod_dest;
    411                     CPU_DATA      mem_align_mod_src;
    412                     CPU_BOOLEAN   mem_aligned;
    413          
    414          
    415          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    416              if (size < 1) {                                             /* See Note #1.                                         */
    417                  return;
    418              }
    419              if (pdest == (void *)0) {
    420                  return;
    421              }
    422              if (psrc  == (void *)0) {
    423                  return;
    424              }
    425          #endif
    426          
    427          
    428              size_rem           =  size;
    429          
    430              pmem_08_dest       = (      CPU_INT08U *)pdest;
    431              pmem_08_src        = (const CPU_INT08U *)psrc;
    432          
    433              mem_gap_octets     = (CPU_SIZE_T)(pmem_08_src - pmem_08_dest);
   \   00000002   0x1A0B             SUBS     R3,R1,R0
    434          
    435          
    436              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \   00000004   0x2B04             CMP      R3,#+4
   \   00000006   0xD326             BCC.N    ??Mem_Copy_0
    437                                                                          /* See Note #4.                                         */
    438                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   00000008   0xF010 0x0303      ANDS     R3,R0,#0x3
    439                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \   0000000C   0xF011 0x0403      ANDS     R4,R1,#0x3
    440          
    441                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \   00000010   0x42A3             CMP      R3,R4
   \   00000012   0xD101             BNE.N    ??Mem_Copy_1
   \   00000014   0x2401             MOVS     R4,#+1
   \   00000016   0xE000             B.N      ??Mem_Copy_2
   \                     ??Mem_Copy_1: (+1)
   \   00000018   0x2400             MOVS     R4,#+0
    442          
    443                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Copy_2: (+1)
   \   0000001A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001C   0x2C01             CMP      R4,#+1
   \   0000001E   0xD11A             BNE.N    ??Mem_Copy_0
    444                                                                          /* ... optimize copy for mem buf alignment.             */
    445                      if (mem_align_mod_dest != 0u) {                     /* If leading octets avail,                   ...       */
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD00A             BEQ.N    ??Mem_Copy_3
    446                          i = mem_align_mod_dest;
   \   00000024   0xE005             B.N      ??Mem_Copy_4
    447                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    448                                 (i          <  sizeof(CPU_ALIGN ))) {    /* ... until next CPU_ALIGN word boundary.              */
    449                             *pmem_08_dest++ = *pmem_08_src++;
   \                     ??Mem_Copy_5: (+1)
   \   00000026   0x780C             LDRB     R4,[R1, #+0]
   \   00000028   0x7004             STRB     R4,[R0, #+0]
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
    450                              size_rem      -=  sizeof(CPU_INT08U);
   \   0000002E   0x1E52             SUBS     R2,R2,#+1
    451                              i++;
   \   00000030   0x1C5B             ADDS     R3,R3,#+1
    452                          }
   \                     ??Mem_Copy_4: (+1)
   \   00000032   0x2A00             CMP      R2,#+0
   \   00000034   0xD001             BEQ.N    ??Mem_Copy_3
   \   00000036   0x2B04             CMP      R3,#+4
   \   00000038   0xD3F5             BCC.N    ??Mem_Copy_5
    453                      }
    454          
    455                      pmem_align_dest = (      CPU_ALIGN *)pmem_08_dest;  /* See Note #3.                                         */
    456                      pmem_align_src  = (const CPU_ALIGN *)pmem_08_src;
   \                     ??Mem_Copy_3: (+1)
   \   0000003A   0xE004             B.N      ??Mem_Copy_6
    457                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    458                         *pmem_align_dest++ = *pmem_align_src++;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Copy_7: (+1)
   \   0000003C   0x680B             LDR      R3,[R1, #+0]
   \   0000003E   0x6003             STR      R3,[R0, #+0]
   \   00000040   0x1D09             ADDS     R1,R1,#+4
   \   00000042   0x1D00             ADDS     R0,R0,#+4
    459                          size_rem         -=  sizeof(CPU_ALIGN);
   \   00000044   0x1F12             SUBS     R2,R2,#+4
    460                      }
   \                     ??Mem_Copy_6: (+1)
   \   00000046   0x2A04             CMP      R2,#+4
   \   00000048   0xD2F8             BCS.N    ??Mem_Copy_7
    461          
    462                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest;
    463                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src;
   \   0000004A   0xE004             B.N      ??Mem_Copy_0
    464                  }
    465              }
    466          
    467              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    468                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Copy_8: (+1)
   \   0000004C   0x780B             LDRB     R3,[R1, #+0]
   \   0000004E   0x7003             STRB     R3,[R0, #+0]
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \   00000052   0x1C40             ADDS     R0,R0,#+1
    469                  size_rem      -=  sizeof(CPU_INT08U);
   \   00000054   0x1E52             SUBS     R2,R2,#+1
    470              }
   \                     ??Mem_Copy_0: (+1)
   \   00000056   0x2A00             CMP      R2,#+0
   \   00000058   0xD1F8             BNE.N    ??Mem_Copy_8
    471          }
   \   0000005A   0xBC10             POP      {R4}
   \   0000005C   0x4770             BX       LR               ;; return
    472          #endif
    473          
    474          
    475          /*
    476          *********************************************************************************************************
    477          *                                             Mem_Move()
    478          *
    479          * Description : Moves data octets from one memory buffer to another memory buffer, or within the same
    480          *               memory buffer. Overlapping is correctly handled for all move operations.
    481          *
    482          * Argument(s) : pdest       Pointer to destination memory buffer.
    483          *
    484          *               psrc        Pointer to source      memory buffer.
    485          *
    486          *               size        Number of octets to move (see Note #1).
    487          *
    488          * Return(s)   : none.
    489          *
    490          * Caller(s)   : Application.
    491          *
    492          * Note(s)     : (1) Null move operations allowed (i.e. zero-length).
    493          *
    494          *               (2) Memory buffers checked for overlapping.
    495          *
    496          *               (3) For best CPU performance, optimized to copy data buffer using 'CPU_ALIGN'-sized data
    497          *                   words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    498          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    499          *                   addresses.
    500          *
    501          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    502          *                   address boundary.
    503          *
    504          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    505          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    506          *                  'mem_align_mod' arithmetic operation.
    507          *********************************************************************************************************
    508          */
    509          

   \                                 In section .text, align 2, keep-with-next
    510          void  Mem_Move (       void        *pdest,
    511                          const  void        *psrc,
    512                                 CPU_SIZE_T   size)
    513          {
   \                     Mem_Move: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    514                     CPU_SIZE_T    size_rem;
    515                     CPU_SIZE_T    mem_gap_octets;
    516                     CPU_ALIGN    *pmem_align_dest;
    517              const  CPU_ALIGN    *pmem_align_src;
    518                     CPU_INT08U   *pmem_08_dest;
    519              const  CPU_INT08U   *pmem_08_src;
    520                     CPU_INT08S    i;
    521                     CPU_DATA      mem_align_mod_dest;
    522                     CPU_DATA      mem_align_mod_src;
    523                     CPU_BOOLEAN   mem_aligned;
    524          
    525          
    526          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    527              if (size < 1) {
    528                  return;
    529              }
    530              if (pdest == (void *)0) {
    531                  return;
    532              }
    533              if (psrc  == (void *)0) {
    534                  return;
    535              }
    536          #endif
    537          
    538              pmem_08_src  = (const CPU_INT08U *)psrc;
    539              pmem_08_dest = (      CPU_INT08U *)pdest;
    540              if (pmem_08_src > pmem_08_dest) {
   \   00000002   0x4288             CMP      R0,R1
   \   00000004   0xD202             BCS.N    ??Mem_Move_0
    541                  Mem_Copy(pdest, psrc, size);
   \   00000006   0x.... 0x....      BL       Mem_Copy
    542                  return;
   \   0000000A   0xE036             B.N      ??Mem_Move_1
    543              }
    544          
    545              size_rem           =  size;
    546          
    547              pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
   \                     ??Mem_Move_0: (+1)
   \   0000000C   0x4410             ADD      R0,R0,R2
   \   0000000E   0x1E43             SUBS     R3,R0,#+1
    548              pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
   \   00000010   0xEB01 0x0002      ADD      R0,R1,R2
   \   00000014   0x1E41             SUBS     R1,R0,#+1
    549          
    550              mem_gap_octets     = (CPU_SIZE_T)(pmem_08_dest - pmem_08_src);
   \   00000016   0x1A58             SUBS     R0,R3,R1
    551          
    552          
    553              if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xD32C             BCC.N    ??Mem_Move_2
    554          
    555                                                                          /* See Note #4.                                         */
    556                  mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   0000001C   0xF013 0x0003      ANDS     R0,R3,#0x3
    557                  mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
   \   00000020   0xF011 0x0403      ANDS     R4,R1,#0x3
    558          
    559                  mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
   \   00000024   0x42A0             CMP      R0,R4
   \   00000026   0xD101             BNE.N    ??Mem_Move_3
   \   00000028   0x2401             MOVS     R4,#+1
   \   0000002A   0xE000             B.N      ??Mem_Move_4
   \                     ??Mem_Move_3: (+1)
   \   0000002C   0x2400             MOVS     R4,#+0
    560          
    561                  if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Move_4: (+1)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C01             CMP      R4,#+1
   \   00000032   0xD120             BNE.N    ??Mem_Move_2
    562                                                                          /* ... optimize copy for mem buf alignment.             */
    563                      if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
   \   00000034   0x2803             CMP      R0,#+3
   \   00000036   0xD00C             BEQ.N    ??Mem_Move_5
    564                          i = (CPU_INT08S)mem_align_mod_dest;
   \   00000038   0xE005             B.N      ??Mem_Move_6
    565                          while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
    566                                 (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
    567                             *pmem_08_dest-- = *pmem_08_src--;
   \                     ??Mem_Move_7: (+1)
   \   0000003A   0x780C             LDRB     R4,[R1, #+0]
   \   0000003C   0x701C             STRB     R4,[R3, #+0]
   \   0000003E   0x1E49             SUBS     R1,R1,#+1
   \   00000040   0x1E5B             SUBS     R3,R3,#+1
    568                              size_rem      -=  sizeof(CPU_INT08U);
   \   00000042   0x1E52             SUBS     R2,R2,#+1
    569                              i--;
   \   00000044   0x1E40             SUBS     R0,R0,#+1
    570                          }
   \                     ??Mem_Move_6: (+1)
   \   00000046   0x2A00             CMP      R2,#+0
   \   00000048   0xD003             BEQ.N    ??Mem_Move_5
   \   0000004A   0x0004             MOVS     R4,R0
   \   0000004C   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000004E   0x2C00             CMP      R4,#+0
   \   00000050   0xD5F3             BPL.N    ??Mem_Move_7
    571                      }
    572          
    573                                                                          /* See Note #3.                                         */
    574                      pmem_align_dest = (      CPU_ALIGN *)(((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN)) + 1);
   \                     ??Mem_Move_5: (+1)
   \   00000052   0x1ED8             SUBS     R0,R3,#+3
    575                      pmem_align_src  = (const CPU_ALIGN *)(((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN)) + 1);
   \   00000054   0x1EC9             SUBS     R1,R1,#+3
   \   00000056   0xE004             B.N      ??Mem_Move_8
    576                      while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    577                         *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Move_9: (+1)
   \   00000058   0x680B             LDR      R3,[R1, #+0]
   \   0000005A   0x6003             STR      R3,[R0, #+0]
   \   0000005C   0x1F09             SUBS     R1,R1,#+4
   \   0000005E   0x1F00             SUBS     R0,R0,#+4
    578                          size_rem         -=  sizeof(CPU_ALIGN);
   \   00000060   0x1F12             SUBS     R2,R2,#+4
    579                      }
   \                     ??Mem_Move_8: (+1)
   \   00000062   0x2A04             CMP      R2,#+4
   \   00000064   0xD2F8             BCS.N    ??Mem_Move_9
    580          
    581                      pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
   \   00000066   0x1CC3             ADDS     R3,R0,#+3
    582                      pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
   \   00000068   0x1CC9             ADDS     R1,R1,#+3
   \   0000006A   0xE004             B.N      ??Mem_Move_2
    583          
    584                  }
    585              }
    586          
    587              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
    588                 *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Move_10: (+1)
   \   0000006C   0x7808             LDRB     R0,[R1, #+0]
   \   0000006E   0x7018             STRB     R0,[R3, #+0]
   \   00000070   0x1E49             SUBS     R1,R1,#+1
   \   00000072   0x1E5B             SUBS     R3,R3,#+1
    589                  size_rem      -=  sizeof(CPU_INT08U);
   \   00000074   0x1E52             SUBS     R2,R2,#+1
    590              }
   \                     ??Mem_Move_2: (+1)
   \   00000076   0x2A00             CMP      R2,#+0
   \   00000078   0xD1F8             BNE.N    ??Mem_Move_10
    591          }
   \                     ??Mem_Move_1: (+1)
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return
    592          
    593          
    594          /*
    595          *********************************************************************************************************
    596          *                                              Mem_Cmp()
    597          *
    598          * Description : Verifies that ALL data octets in two memory buffers are identical in sequence.
    599          *
    600          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    601          *
    602          *               p2_mem      Pointer to second memory buffer.
    603          *
    604          *               size        Number of data buffer octets to compare (see Note #1).
    605          *
    606          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    607          *
    608          *               DEF_NO,  otherwise.
    609          *
    610          * Caller(s)   : Application.
    611          *
    612          * Note(s)     : (1) Null compares allowed (i.e. zero-length compares); 'DEF_YES' returned to indicate
    613          *                   identical null compare.
    614          *
    615          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g.
    616          *                   network address buffers.  Consequently, memory buffer comparison is more efficient
    617          *                   if the comparison starts from the end of the memory buffers which will abort sooner
    618          *                   on dissimilar memory buffers that vary only in the least significant octets.
    619          *
    620          *               (3) For best CPU performance, optimized to compare data buffers using 'CPU_ALIGN'-sized
    621          *                   data words. Since many word-aligned processors REQUIRE that multi-octet words be accessed on
    622          *                   word-aligned addresses, 'CPU_ALIGN'-sized words MUST be accessed on 'CPU_ALIGN'd
    623          *                   addresses.
    624          *
    625          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    626          *                   address boundary.
    627          *
    628          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus
    629          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    630          *                  'mem_align_mod' arithmetic operation.
    631          *********************************************************************************************************
    632          */
    633          

   \                                 In section .text, align 2, keep-with-next
    634          CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
    635                                const  void        *p2_mem,
    636                                       CPU_SIZE_T   size)
    637          {
   \                     Mem_Cmp: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    638                     CPU_SIZE_T    size_rem;
    639                     CPU_ALIGN    *p1_mem_align;
    640                     CPU_ALIGN    *p2_mem_align;
    641              const  CPU_INT08U   *p1_mem_08;
    642              const  CPU_INT08U   *p2_mem_08;
    643                     CPU_DATA      i;
    644                     CPU_DATA      mem_align_mod_1;
    645                     CPU_DATA      mem_align_mod_2;
    646                     CPU_BOOLEAN   mem_aligned;
    647                     CPU_BOOLEAN   mem_cmp;
    648          
    649          
    650              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD101             BNE.N    ??Mem_Cmp_0
    651                  return (DEF_YES);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE04F             B.N      ??Mem_Cmp_1
    652              }
    653              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0: (+1)
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??Mem_Cmp_2
    654                  return (DEF_NO);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE04B             B.N      ??Mem_Cmp_1
    655              }
    656              if (p2_mem == (void *)0) {
   \                     ??Mem_Cmp_2: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD101             BNE.N    ??Mem_Cmp_3
    657                  return (DEF_NO);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE047             B.N      ??Mem_Cmp_1
    658              }
    659          
    660          
    661              mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
   \                     ??Mem_Cmp_3: (+1)
   \   0000001A   0x2301             MOVS     R3,#+1
    662              size_rem        =  size;
    663                                                                          /* Start @ end of mem bufs (see Note #2).               */
    664              p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
   \   0000001C   0xEB00 0x0402      ADD      R4,R0,R2
    665              p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
   \   00000020   0x4411             ADD      R1,R1,R2
    666                                                                          /* See Note #4.                                         */
    667              mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   00000022   0xF014 0x0003      ANDS     R0,R4,#0x3
    668              mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
   \   00000026   0xF011 0x0503      ANDS     R5,R1,#0x3
    669          
    670              mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
   \   0000002A   0x42A8             CMP      R0,R5
   \   0000002C   0xD101             BNE.N    ??Mem_Cmp_4
   \   0000002E   0x2501             MOVS     R5,#+1
   \   00000030   0xE000             B.N      ??Mem_Cmp_5
   \                     ??Mem_Cmp_4: (+1)
   \   00000032   0x2500             MOVS     R5,#+0
    671          
    672              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
   \                     ??Mem_Cmp_5: (+1)
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D01             CMP      R5,#+1
   \   00000038   0xD12F             BNE.N    ??Mem_Cmp_6
    673                                                                          /* ... optimize cmp for mem buf alignment.              */
    674                  if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD011             BEQ.N    ??Mem_Cmp_7
    675                      i = mem_align_mod_1;
   \   0000003E   0xE008             B.N      ??Mem_Cmp_8
    676                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    677                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    678                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
    679                          p1_mem_08--;
   \                     ??Mem_Cmp_9: (+1)
   \   00000040   0x1E64             SUBS     R4,R4,#+1
    680                          p2_mem_08--;
   \   00000042   0x1E49             SUBS     R1,R1,#+1
    681                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000044   0x7825             LDRB     R5,[R4, #+0]
   \   00000046   0x780E             LDRB     R6,[R1, #+0]
   \   00000048   0x42B5             CMP      R5,R6
   \   0000004A   0xD000             BEQ.N    ??Mem_Cmp_10
    682                               mem_cmp = DEF_NO;
   \   0000004C   0x2300             MOVS     R3,#+0
    683                          }
    684                          size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_10: (+1)
   \   0000004E   0x1E52             SUBS     R2,R2,#+1
    685                          i--;
   \   00000050   0x1E40             SUBS     R0,R0,#+1
    686                      }
   \                     ??Mem_Cmp_8: (+1)
   \   00000052   0x001D             MOVS     R5,R3
   \   00000054   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000056   0x2D01             CMP      R5,#+1
   \   00000058   0xD103             BNE.N    ??Mem_Cmp_7
   \   0000005A   0x2A00             CMP      R2,#+0
   \   0000005C   0xD001             BEQ.N    ??Mem_Cmp_7
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD1EE             BNE.N    ??Mem_Cmp_9
    687                  }
    688          
    689                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
   \                     ??Mem_Cmp_7: (+1)
   \   00000062   0x0018             MOVS     R0,R3
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD117             BNE.N    ??Mem_Cmp_6
    690                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3.                                         */
    691                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
   \   0000006A   0xE007             B.N      ??Mem_Cmp_11
    692          
    693                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    694                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    695                          p1_mem_align--;
   \                     ??Mem_Cmp_12: (+1)
   \   0000006C   0x1F24             SUBS     R4,R4,#+4
    696                          p2_mem_align--;
   \   0000006E   0x1F09             SUBS     R1,R1,#+4
    697                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x680D             LDR      R5,[R1, #+0]
   \   00000074   0x42A8             CMP      R0,R5
   \   00000076   0xD000             BEQ.N    ??Mem_Cmp_13
    698                               mem_cmp = DEF_NO;
   \   00000078   0x2300             MOVS     R3,#+0
    699                          }
    700                          size_rem -= sizeof(CPU_ALIGN);
   \                     ??Mem_Cmp_13: (+1)
   \   0000007A   0x1F12             SUBS     R2,R2,#+4
    701                      }
   \                     ??Mem_Cmp_11: (+1)
   \   0000007C   0x0018             MOVS     R0,R3
   \   0000007E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000080   0x2801             CMP      R0,#+1
   \   00000082   0xD101             BNE.N    ??Mem_Cmp_14
   \   00000084   0x2A04             CMP      R2,#+4
   \   00000086   0xD2F1             BCS.N    ??Mem_Cmp_12
    702          
    703                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
    704                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
   \                     ??Mem_Cmp_14: (+1)
   \   00000088   0xE007             B.N      ??Mem_Cmp_6
    705                  }
    706              }
    707          
    708              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    709                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
    710                  p1_mem_08--;
   \                     ??Mem_Cmp_15: (+1)
   \   0000008A   0x1E64             SUBS     R4,R4,#+1
    711                  p2_mem_08--;
   \   0000008C   0x1E49             SUBS     R1,R1,#+1
    712                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
   \   0000008E   0x7820             LDRB     R0,[R4, #+0]
   \   00000090   0x780D             LDRB     R5,[R1, #+0]
   \   00000092   0x42A8             CMP      R0,R5
   \   00000094   0xD000             BEQ.N    ??Mem_Cmp_16
    713                       mem_cmp = DEF_NO;
   \   00000096   0x2300             MOVS     R3,#+0
    714                  }
    715                  size_rem -= sizeof(CPU_INT08U);
   \                     ??Mem_Cmp_16: (+1)
   \   00000098   0x1E52             SUBS     R2,R2,#+1
    716              }
   \                     ??Mem_Cmp_6: (+1)
   \   0000009A   0x0018             MOVS     R0,R3
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x2801             CMP      R0,#+1
   \   000000A0   0xD101             BNE.N    ??Mem_Cmp_17
   \   000000A2   0x2A00             CMP      R2,#+0
   \   000000A4   0xD1F1             BNE.N    ??Mem_Cmp_15
    717          
    718              return (mem_cmp);
   \                     ??Mem_Cmp_17: (+1)
   \   000000A6   0x0018             MOVS     R0,R3
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??Mem_Cmp_1: (+1)
   \   000000AA   0xBC70             POP      {R4-R6}
   \   000000AC   0x4770             BX       LR               ;; return
    719          }
    720          
    721          
    722          /*
    723          *********************************************************************************************************
    724          *                                           Mem_HeapAlloc()
    725          *
    726          * Description : Allocates a memory block from the heap memory segment.
    727          *
    728          * Argument(s) : size            Size      of memory block to allocate (in bytes).
    729          *
    730          *               align           Alignment of memory block to specific word boundary (in bytes).
    731          *
    732          *               p_bytes_reqd    Optional pointer to a variable to ... :
    733          *
    734          *                                   (a) Return the number of bytes required to successfully
    735          *                                           allocate the memory block, if any error(s);
    736          *                                   (b) Return 0, otherwise.
    737          *
    738          *               p_err           Pointer to variable that will receive the return error code from this function :
    739          *
    740          *                                   LIB_MEM_ERR_NONE                Operation was successful.
    741          *                                   LIB_MEM_ERR_HEAP_EMPTY          No more memory available on heap.
    742          *
    743          *                                   ---------------------RETURNED BY Mem_SegAllocInternal()---------------------
    744          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
    745          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
    746          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
    747          *
    748          * Return(s)   : Pointer to memory block, if NO error(s).
    749          *
    750          *               Pointer to NULL,         otherwise.
    751          *
    752          * Caller(s)   : Application.
    753          *
    754          * Note(s)     : (1) Pointers to variables that return values MUST be initialized PRIOR to all other
    755          *                   validation or function handling in case of any error(s).
    756          *
    757          *               (2) This function is DEPRECATED and will be removed in a future version of this product.
    758          *                   Mem_SegAlloc(), Mem_SegAllocExt() or Mem_SegAllocHW() should be used instead.
    759          *********************************************************************************************************
    760          */
    761          
    762          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
    763          void  *Mem_HeapAlloc (CPU_SIZE_T   size,
    764                                CPU_SIZE_T   align,
    765                                CPU_SIZE_T  *p_bytes_reqd,
    766                                LIB_ERR     *p_err)
    767          {
   \                     Mem_HeapAlloc: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x001C             MOVS     R4,R3
    768              void  *p_mem;
    769          
    770          
    771              p_mem = Mem_SegAllocInternal(DEF_NULL,
    772                                          &Mem_SegHeap,
    773                                           size,
    774                                           align,
    775                                           LIB_MEM_CFG_HEAP_PADDING_ALIGN,
    776                                           p_bytes_reqd,
    777                                           p_err);
   \   00000004   0x9402             STR      R4,[SP, #+8]
   \   00000006   0x9201             STR      R2,[SP, #+4]
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x9200             STR      R2,[SP, #+0]
   \   0000000C   0x000B             MOVS     R3,R1
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      BL       Mem_SegAllocInternal
    778              if (*p_err == LIB_MEM_ERR_SEG_OVF) {
   \   0000001A   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   0000001E   0xF242 0x72D9      MOVW     R2,#+10201
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD102             BNE.N    ??Mem_HeapAlloc_0
    779                 *p_err = LIB_MEM_ERR_HEAP_OVF;
   \   00000026   0xF242 0x71E3      MOVW     R1,#+10211
   \   0000002A   0x8021             STRH     R1,[R4, #+0]
    780              }
    781          
    782              return (p_mem);
   \                     ??Mem_HeapAlloc_0: (+1)
   \   0000002C   0xB004             ADD      SP,SP,#+16
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    783          }
    784          #endif
    785          
    786          
    787          /*
    788          *********************************************************************************************************
    789          *                                        Mem_HeapGetSizeRem()
    790          *
    791          * Description : Gets remaining heap memory size available to allocate.
    792          *
    793          * Argument(s) : align       Desired word boundary alignment (in bytes) to return remaining memory size from.
    794          *
    795          *               p_err       Pointer to variable that will receive the return error code from this function
    796          *
    797          *                               LIB_MEM_ERR_NONE                Operation was successful.
    798          *
    799          *                               --------------------RETURNED BY Mem_SegRemSizeGet()--------------------
    800          *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
    801          *                               LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
    802          *
    803          * Return(s)   : Remaining heap memory size (in bytes), if NO error(s).
    804          *
    805          *               0,                                     otherwise.
    806          *
    807          * Caller(s)   : Application.
    808          *
    809          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
    810          *                   Mem_SegRemSizeGet() should be used instead.
    811          *********************************************************************************************************
    812          */
    813          
    814          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
    815          CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
    816                                          LIB_ERR     *p_err)
    817          {
   \                     Mem_HeapGetSizeRem: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    818              CPU_SIZE_T  rem_size;
    819          
    820          
    821              rem_size = Mem_SegRemSizeGet(&Mem_SegHeap,
    822                                            align,
    823                                            DEF_NULL,
    824                                            p_err);
   \   00000004   0x0023             MOVS     R3,R4
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000000E   0x.... 0x....      BL       Mem_SegRemSizeGet
    825              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000012   0xF9B4 0x1000      LDRSH    R1,[R4, #+0]
   \   00000016   0xF242 0x7210      MOVW     R2,#+10000
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD001             BEQ.N    ??Mem_HeapGetSizeRem_0
    826                  return (0u);
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE7FF             B.N      ??Mem_HeapGetSizeRem_1
    827              }
    828          
    829              return (rem_size);
   \                     ??Mem_HeapGetSizeRem_0: (+1)
   \                     ??Mem_HeapGetSizeRem_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    830          }
    831          #endif
    832          
    833          
    834          /*
    835          *********************************************************************************************************
    836          *                                            Mem_SegCreate()
    837          *
    838          * Description : Creates a new memory segment to be used for runtime memory allocation.
    839          *
    840          * Argument(s) : p_name          Pointer to segment name.
    841          *
    842          *               p_seg           Pointer to segment data. Must be allocated by caller.
    843          *
    844          *               seg_base_addr   Address of segment's first byte.
    845          *
    846          *               size            Total size of segment, in bytes.
    847          *
    848          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
    849          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
    850          *                               means no padding.
    851          *
    852          *               p_err           Pointer to variable that will receive the return error code from this function :
    853          *
    854          *                                   LIB_MEM_ERR_NONE                    Operation was successful.
    855          *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size specified.
    856          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid padding alignment.
    857          *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
    858          *
    859          *                                   -------------------RETURNED BY Mem_SegOverlapChkCritical()-------------------
    860          *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
    861          *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
    862          *
    863          * Return(s)   : None.
    864          *
    865          * Caller(s)   : Application.
    866          *
    867          * Note(s)     : (1) New segments are checked for overlap with existing segments. A critical section needs
    868          *                   to be maintained during the whole list search and add procedure to prevent a reentrant
    869          *                   call from creating another segment overlapping with the one being added.
    870          *********************************************************************************************************
    871          */
    872          

   \                                 In section .text, align 2, keep-with-next
    873          void  Mem_SegCreate (const  CPU_CHAR    *p_name,
    874                                      MEM_SEG     *p_seg,
    875                                      CPU_ADDR     seg_base_addr,
    876                                      CPU_SIZE_T   size,
    877                                      CPU_SIZE_T   padding_align,
    878                                      LIB_ERR     *p_err)
    879          {
   \                     Mem_SegCreate: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   00000010   0x9C0B             LDR      R4,[SP, #+44]
    880              CPU_SR_ALLOC();
   \   00000012   0x2000             MOVS     R0,#+0
    881          
    882          
    883          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    884              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
    885                  CPU_SW_EXCEPTION(;);
    886              }
    887          
    888              if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
    889                 *p_err = LIB_MEM_ERR_NULL_PTR;
    890                  return;
    891              }
    892          
    893              if (size < 1u) {                                            /* Chk for invalid sized seg.                           */
    894                 *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
    895                  return;
    896              }
    897                                                                          /* Chk for addr space ovf.                              */
    898              if (seg_base_addr + (size - 1u) < seg_base_addr) {
    899                 *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
    900                  return;
    901              }
    902          
    903              if ((padding_align               != LIB_MEM_PADDING_ALIGN_NONE) &&
    904                  (MATH_IS_PWR2(padding_align) != DEF_YES)) {
    905                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
    906                  return;
    907              }
    908          #endif
    909          
    910              CPU_CRITICAL_ENTER();
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   \   0000001A   0x4682             MOV      R10,R0
    911          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
    912              (LIB_MEM_CFG_HEAP_SIZE       > 0u)
    913              (void)Mem_SegOverlapChkCritical(seg_base_addr,              /* Chk for overlap.                                     */
    914                                              size,
    915                                              p_err);
    916              if (*p_err != LIB_MEM_ERR_NONE) {
    917                  CPU_CRITICAL_EXIT();
    918                  return;
    919              }
    920          #endif
    921          
    922              Mem_SegCreateCritical(p_name,                               /* Create seg.                                          */
    923                                    p_seg,
    924                                    seg_base_addr,
    925                                    padding_align,
    926                                    size);
   \   0000001C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   00000020   0x464B             MOV      R3,R9
   \   00000022   0x003A             MOVS     R2,R7
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x0028             MOVS     R0,R5
   \   00000028   0x.... 0x....      BL       Mem_SegCreateCritical
    927              CPU_CRITICAL_EXIT();
   \   0000002C   0x4650             MOV      R0,R10
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
    928          
    929             *p_err = LIB_MEM_ERR_NONE;
   \   00000032   0xF242 0x7010      MOVW     R0,#+10000
   \   00000036   0x8020             STRH     R0,[R4, #+0]
    930          }
   \   00000038   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    931          
    932          
    933          /*
    934          *********************************************************************************************************
    935          *                                            Mem_SegClr()
    936          *
    937          * Description : Clears a memory segment.
    938          *
    939          * Argument(s) : p_seg           Pointer to segment data. Must be allocated by caller.
    940          *
    941          *               p_err           Pointer to variable that will receive the return error code from this function :
    942          *
    943          *                               LIB_MEM_ERR_NONE                Operation was successful.
    944          *                               LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
    945          *
    946          * Return(s)   : None.
    947          *
    948          * Caller(s)   : Application.
    949          *
    950          * Note(s)     : (1) This function must be used with extreme caution. It must only be called on memory
    951          *                   segments that are no longer used.
    952          *
    953          *               (2) This function is disabled when debug mode is enabled to avoid heap memory leaks.
    954          *********************************************************************************************************
    955          */
    956          
    957          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_DISABLED)

   \                                 In section .text, align 2, keep-with-next
    958          void  Mem_SegClr (MEM_SEG  *p_seg,
    959                            LIB_ERR  *p_err)
    960          {
   \                     Mem_SegClr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    961              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    962          
    963          
    964          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    965              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
    966                  CPU_SW_EXCEPTION(;);
    967              }
    968          
    969              if (p_seg == DEF_NULL) {                                    /* Chk for null seg ptr.                                */
    970                 *p_err = LIB_MEM_ERR_NULL_PTR;
    971                  return;
    972              }
    973          #endif
    974          
    975              CPU_CRITICAL_ENTER();
   \   00000008   0x2040             MOVS     R0,#+64
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
    976              p_seg->AddrNext = p_seg->AddrBase;
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x60A1             STR      R1,[R4, #+8]
    977              CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_SR_Restore
    978          
    979             *p_err = LIB_MEM_ERR_NONE;
   \   00000016   0xF242 0x7010      MOVW     R0,#+10000
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    980          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    981          #endif
    982          
    983          
    984          /*
    985          *********************************************************************************************************
    986          *                                         Mem_SegRemSizeGet()
    987          *
    988          * Description : Gets free space of memory segment.
    989          *
    990          * Argument(s) : p_seg       Pointer to segment data.
    991          *
    992          *               align       Alignment in bytes to assume for calculation of free space.
    993          *
    994          *               p_seg_info  Pointer to structure that will receive further segment info data (used size,
    995          *                           total size, base address and next allocation address).
    996          *
    997          *               p_err       Pointer to variable that will receive the return error code from this function :
    998          *
    999          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1000          *                           LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
   1001          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
   1002          *
   1003          * Return(s)   : Memory segment remaining size in bytes,     if successful.
   1004          *               0,                                          otherwise or if memory segment empty.
   1005          *
   1006          * Caller(s)   : Application,
   1007          *               Mem_HeapGetSizeRem(),
   1008          *               Mem_OutputUsage().
   1009          *
   1010          * Note(s)     : None.
   1011          *********************************************************************************************************
   1012          */
   1013          

   \                                 In section .text, align 2, keep-with-next
   1014          CPU_SIZE_T  Mem_SegRemSizeGet (MEM_SEG       *p_seg,
   1015                                         CPU_SIZE_T     align,
   1016                                         MEM_SEG_INFO  *p_seg_info,
   1017                                         LIB_ERR       *p_err)
   1018          {
   \                     Mem_SegRemSizeGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x001E             MOVS     R6,R3
   1019              CPU_SIZE_T  rem_size;
   1020              CPU_SIZE_T  total_size;
   1021              CPU_SIZE_T  used_size;
   1022              CPU_ADDR    next_addr_align;
   1023              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
   1024          
   1025          
   1026          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1027              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   1028                  CPU_SW_EXCEPTION(0);
   1029              }
   1030          
   1031              if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk for invalid align val.                           */
   1032                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   1033                  return (0u);
   1034              }
   1035          #endif
   1036          
   1037              if (p_seg == DEF_NULL) {                                    /* Dflt to heap in case p_seg is null.                  */
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD101             BNE.N    ??Mem_SegRemSizeGet_0
   1038          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1039                  p_seg = &Mem_SegHeap;
   \   00000010   0x.... 0x....      LDR.W    R5,??DataTable12_2
   1040          #else
   1041                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1042                  return (0u);
   1043          #endif
   1044              }
   1045          
   1046              CPU_CRITICAL_ENTER();                                       /* Calc seg stats.                                      */
   \                     ??Mem_SegRemSizeGet_0: (+1)
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   1047              next_addr_align = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext, align);
   \   0000001A   0x68A9             LDR      R1,[R5, #+8]
   \   0000001C   0x1E7A             SUBS     R2,R7,#+1
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD101             BNE.N    ??Mem_SegRemSizeGet_1
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xE000             B.N      ??Mem_SegRemSizeGet_2
   \                     ??Mem_SegRemSizeGet_1: (+1)
   \   00000026   0x0039             MOVS     R1,R7
   \                     ??Mem_SegRemSizeGet_2: (+1)
   \   00000028   0x68AA             LDR      R2,[R5, #+8]
   \   0000002A   0x1E7F             SUBS     R7,R7,#+1
   \   0000002C   0xEA32 0x0707      BICS     R7,R2,R7
   \   00000030   0x19CF             ADDS     R7,R1,R7
   1048              CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
   1049          
   1050              total_size = (p_seg->AddrEnd  - p_seg->AddrBase) + 1u;
   \   00000036   0x6868             LDR      R0,[R5, #+4]
   \   00000038   0x682A             LDR      R2,[R5, #+0]
   \   0000003A   0x1A82             SUBS     R2,R0,R2
   \   0000003C   0x1C52             ADDS     R2,R2,#+1
   1051              used_size  =  p_seg->AddrNext - p_seg->AddrBase;
   \   0000003E   0x68A8             LDR      R0,[R5, #+8]
   \   00000040   0x682B             LDR      R3,[R5, #+0]
   \   00000042   0x1AC3             SUBS     R3,R0,R3
   1052          
   1053              if (next_addr_align > p_seg->AddrEnd){
   \   00000044   0x6868             LDR      R0,[R5, #+4]
   \   00000046   0x42B8             CMP      R0,R7
   \   00000048   0xD202             BCS.N    ??Mem_SegRemSizeGet_3
   1054                  next_addr_align = 0u;
   \   0000004A   0x2700             MOVS     R7,#+0
   1055                  rem_size        = 0u;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE002             B.N      ??Mem_SegRemSizeGet_4
   1056              } else {
   1057                  rem_size        = total_size - (next_addr_align - p_seg->AddrBase);
   \                     ??Mem_SegRemSizeGet_3: (+1)
   \   00000050   0x1BD0             SUBS     R0,R2,R7
   \   00000052   0x6829             LDR      R1,[R5, #+0]
   \   00000054   0x1808             ADDS     R0,R1,R0
   1058              }
   1059          
   1060              if (p_seg_info != DEF_NULL) {
   \                     ??Mem_SegRemSizeGet_4: (+1)
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD004             BEQ.N    ??Mem_SegRemSizeGet_5
   1061                  p_seg_info->TotalSize     = total_size;
   \   0000005A   0x6062             STR      R2,[R4, #+4]
   1062                  p_seg_info->UsedSize      = used_size;
   \   0000005C   0x6023             STR      R3,[R4, #+0]
   1063                  p_seg_info->AddrBase      = p_seg->AddrBase;
   \   0000005E   0x6829             LDR      R1,[R5, #+0]
   \   00000060   0x60A1             STR      R1,[R4, #+8]
   1064                  p_seg_info->AddrNextAlloc = next_addr_align;
   \   00000062   0x60E7             STR      R7,[R4, #+12]
   1065              }
   1066          
   1067             *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_SegRemSizeGet_5: (+1)
   \   00000064   0xF242 0x7110      MOVW     R1,#+10000
   \   00000068   0x8031             STRH     R1,[R6, #+0]
   1068          
   1069              return (rem_size);
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1070          }
   1071          
   1072          
   1073          /*
   1074          *********************************************************************************************************
   1075          *                                            Mem_SegAlloc()
   1076          *
   1077          * Description : Allocates memory from specified segment. Returned memory block will be aligned on a CPU
   1078          *               word boundary.
   1079          *
   1080          * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1081          *
   1082          *               p_seg   Pointer to segment from which to allocate memory. Will be allocated from
   1083          *                       general-purpose heap if null.
   1084          *
   1085          *               size    Size of memory block to allocate, in bytes.
   1086          *
   1087          *               p_err   Pointer to variable that will receive the return error code from this function :
   1088          *
   1089          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1090          *
   1091          *                           ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1092          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1093          *                           LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1094          *                           LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1095          *                           LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1096          *
   1097          * Return(s)   : Pointer to allocated memory block, if successful.
   1098          *
   1099          *               DEF_NULL, otherwise.
   1100          *
   1101          * Caller(s)   : Application.
   1102          *
   1103          * Note(s)     : (1) The memory block returned  by this function will be aligned on a word boundary. In
   1104          *                   order to specify a specific alignment value, use either Mem_SegAllocExt() or
   1105          *                   Mem_SegAllocHW().
   1106          *********************************************************************************************************
   1107          */
   1108          

   \                                 In section .text, align 2, keep-with-next
   1109          void  *Mem_SegAlloc (const  CPU_CHAR    *p_name,
   1110                                      MEM_SEG     *p_seg,
   1111                                      CPU_SIZE_T   size,
   1112                                      LIB_ERR     *p_err)
   1113          {
   \                     Mem_SegAlloc: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
   1114              void  *p_blk;
   1115          
   1116          
   1117              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??Mem_SegAlloc_0
   1118          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1119                  p_seg = &Mem_SegHeap;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12_2
   1120          #else
   1121                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1122                  return (DEF_NULL);
   1123          #endif
   1124              }
   1125          
   1126              p_blk = Mem_SegAllocInternal(p_name,
   1127                                           p_seg,
   1128                                           size,
   1129                                           sizeof(CPU_ALIGN),
   1130                                           LIB_MEM_PADDING_ALIGN_NONE,
   1131                                           DEF_NULL,
   1132                                           p_err);
   \                     ??Mem_SegAlloc_0: (+1)
   \   0000000A   0x9302             STR      R3,[SP, #+8]
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x9301             STR      R3,[SP, #+4]
   \   00000010   0x2301             MOVS     R3,#+1
   \   00000012   0x9300             STR      R3,[SP, #+0]
   \   00000014   0x2304             MOVS     R3,#+4
   \   00000016   0x.... 0x....      BL       Mem_SegAllocInternal
   1133          
   1134              return (p_blk);
   \   0000001A   0xBD0E             POP      {R1-R3,PC}       ;; return
   1135          }
   1136          
   1137          
   1138          /*
   1139          *********************************************************************************************************
   1140          *                                           Mem_SegAllocExt()
   1141          *
   1142          * Description : Allocates memory from specified memory segment.
   1143          *
   1144          * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1145          *
   1146          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1147          *                               general-purpose heap if null.
   1148          *
   1149          *               size            Size of memory block to allocate, in bytes.
   1150          *
   1151          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   1152          *
   1153          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   1154          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   1155          *
   1156          *               p_err           Pointer to variable that will receive the return error code from this function :
   1157          *
   1158          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1159          *
   1160          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1161          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1162          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1163          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1164          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1165          *
   1166          * Return(s)   : Pointer to allocated memory block, if successful.
   1167          *
   1168          *               DEF_NULL, otherwise.
   1169          *
   1170          * Caller(s)   : Application.
   1171          *
   1172          * Note(s)     : none.
   1173          *********************************************************************************************************
   1174          */
   1175          

   \                                 In section .text, align 2, keep-with-next
   1176          void  *Mem_SegAllocExt (const  CPU_CHAR    *p_name,
   1177                                         MEM_SEG     *p_seg,
   1178                                         CPU_SIZE_T   size,
   1179                                         CPU_SIZE_T   align,
   1180                                         CPU_SIZE_T  *p_bytes_reqd,
   1181                                         LIB_ERR     *p_err)
   1182          {
   \                     Mem_SegAllocExt: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   1183              void  *p_blk;
   1184          
   1185          
   1186              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??Mem_SegAllocExt_0
   1187          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1188                  p_seg = &Mem_SegHeap;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \                     ??Mem_SegAllocExt_0: (+1)
   \   0000000A   0x9D07             LDR      R5,[SP, #+28]
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
   1189          #else
   1190                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1191                  return (DEF_NULL);
   1192          #endif
   1193              }
   1194          
   1195              p_blk = Mem_SegAllocInternal(p_name,
   1196                                           p_seg,
   1197                                           size,
   1198                                           align,
   1199                                           LIB_MEM_PADDING_ALIGN_NONE,
   1200                                           p_bytes_reqd,
   1201                                           p_err);
   \   0000000E   0x9502             STR      R5,[SP, #+8]
   \   00000010   0x9401             STR      R4,[SP, #+4]
   \   00000012   0x2401             MOVS     R4,#+1
   \   00000014   0x9400             STR      R4,[SP, #+0]
   \   00000016   0x.... 0x....      BL       Mem_SegAllocInternal
   1202          
   1203              return (p_blk);
   \   0000001A   0xBD3E             POP      {R1-R5,PC}       ;; return
   1204          }
   1205          
   1206          
   1207          /*
   1208          *********************************************************************************************************
   1209          *                                          Mem_SegAllocHW()
   1210          *
   1211          * Description : Allocates memory from specified segment. The returned buffer will be padded in function
   1212          *               of memory segment's properties.
   1213          *
   1214          * Argument(s) : p_name          Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   1215          *
   1216          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1217          *                               general-purpose heap if null.
   1218          *
   1219          *               size            Size of memory block to allocate, in bytes.
   1220          *
   1221          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   1222          *
   1223          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   1224          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   1225          *
   1226          *               p_err           Pointer to variable that will receive the return error code from this function :
   1227          *
   1228          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1229          *
   1230          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1231          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1232          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1233          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1234          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1235          *
   1236          * Return(s)   : Pointer to allocated memory block, if successful.
   1237          *
   1238          *               DEF_NULL, otherwise.
   1239          *
   1240          * Caller(s)   : Application.
   1241          *
   1242          * Note(s)     : none.
   1243          *********************************************************************************************************
   1244          */
   1245          

   \                                 In section .text, align 2, keep-with-next
   1246          void  *Mem_SegAllocHW (const  CPU_CHAR    *p_name,
   1247                                        MEM_SEG     *p_seg,
   1248                                        CPU_SIZE_T   size,
   1249                                        CPU_SIZE_T   align,
   1250                                        CPU_SIZE_T  *p_bytes_reqd,
   1251                                        LIB_ERR     *p_err)
   1252          {
   \                     Mem_SegAllocHW: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   1253              void  *p_blk;
   1254          
   1255          
   1256              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??Mem_SegAllocHW_0
   1257          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1258                  p_seg = &Mem_SegHeap;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \                     ??Mem_SegAllocHW_0: (+1)
   \   0000000A   0x9D07             LDR      R5,[SP, #+28]
   \   0000000C   0x9C06             LDR      R4,[SP, #+24]
   1259          #else
   1260                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1261                  return (DEF_NULL);
   1262          #endif
   1263              }
   1264          
   1265              p_blk = Mem_SegAllocInternal(p_name,
   1266                                           p_seg,
   1267                                           size,
   1268                                           align,
   1269                                           p_seg->PaddingAlign,
   1270                                           p_bytes_reqd,
   1271                                           p_err);
   \   0000000E   0x9502             STR      R5,[SP, #+8]
   \   00000010   0x9401             STR      R4,[SP, #+4]
   \   00000012   0x690C             LDR      R4,[R1, #+16]
   \   00000014   0x9400             STR      R4,[SP, #+0]
   \   00000016   0x.... 0x....      BL       Mem_SegAllocInternal
   1272          
   1273              return (p_blk);
   \   0000001A   0xBD3E             POP      {R1-R5,PC}       ;; return
   1274          }
   1275          
   1276          
   1277          /*
   1278          *********************************************************************************************************
   1279          *                                          Mem_PoolCreate()
   1280          *
   1281          * Description : (1) Creates a memory pool :
   1282          *
   1283          *                   (a) Create    memory pool from heap or dedicated memory
   1284          *                   (b) Allocate  memory pool memory blocks
   1285          *                   (c) Configure memory pool
   1286          *
   1287          *
   1288          * Argument(s) : p_pool          Pointer to a memory pool structure to create (see Note #1).
   1289          *
   1290          *               p_mem_base      Memory pool segment base address :
   1291          *
   1292          *                                       (a)     Null address    Memory pool allocated from general-purpose heap.
   1293          *                                       (b) Non-null address    Memory pool allocated from dedicated memory
   1294          *                                                                   specified by its base address.
   1295          *
   1296          *               mem_size        Size      of memory pool segment          (in bytes).
   1297          *
   1298          *               blk_nbr         Number    of memory pool blocks to create.
   1299          *
   1300          *               blk_size        Size      of memory pool blocks to create (in bytes).
   1301          *
   1302          *               blk_align       Alignment of memory pool blocks to specific word boundary (in bytes).
   1303          *
   1304          *               p_bytes_reqd    Optional pointer to a variable to ... :
   1305          *
   1306          *                                   (a) Return the number of bytes required to successfully
   1307          *                                               allocate the memory pool, if any error(s);
   1308          *                                   (b) Return 0, otherwise.
   1309          *
   1310          *               p_err           Pointer to variable that will receive the return error code from this function :
   1311          *
   1312          *                                   LIB_MEM_ERR_NONE                    Operation was successful.
   1313          *                                   LIB_MEM_ERR_NULL_PTR                Pointer to memory pool is null.
   1314          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN       Invalid block alignment requested.
   1315          *                                   LIB_MEM_ERR_INVALID_BLK_NBR         Invalid number of blocks specified.
   1316          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE        Invalid block size specified.
   1317          *                                   LIB_MEM_ERR_INVALID_SEG_SIZE        Invalid segment size.
   1318          *                                   LIB_MEM_ERR_HEAP_EMPTY              No more memory available on heap.
   1319          *                                   LIB_MEM_ERR_ADDR_OVF                Memory allocation exceeds address space.
   1320          *
   1321          *                                   ---------------RETURNED BY Mem_SegOverlapChkCritical()----------------
   1322          *                                   LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
   1323          *                                   LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
   1324          *
   1325          *                                   -----------------RETURNED BY Mem_SegAllocExtCritical()-----------------
   1326          *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1327          *
   1328          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   1329          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
   1330          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
   1331          *                                   LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
   1332          *                                   LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1333          *
   1334          *                                   -----------------------RETURNED BY Mem_PoolClr()-----------------------
   1335          *                                   LIB_MEM_ERR_NULL_PTR                Argument 'p_pool' passed a NULL pointer.
   1336          *
   1337          * Return(s)   : none.
   1338          *
   1339          * Caller(s)   : Application.
   1340          *
   1341          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1342          *                   Mem_DynPoolCreate() or Mem_DynPoolCreateHW() should be used instead.
   1343          *********************************************************************************************************
   1344          */
   1345          
   1346          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1347          void  Mem_PoolCreate (MEM_POOL          *p_pool,
   1348                                void              *p_mem_base,
   1349                                CPU_SIZE_T         mem_size,
   1350                                MEM_POOL_BLK_QTY   blk_nbr,
   1351                                CPU_SIZE_T         blk_size,
   1352                                CPU_SIZE_T         blk_align,
   1353                                CPU_SIZE_T        *p_bytes_reqd,
   1354                                LIB_ERR           *p_err)
   1355          {
   \                     Mem_PoolCreate: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x4699             MOV      R9,R3
   \   0000000C   0xF8DD 0x803C      LDR      R8,[SP, #+60]
   1356              MEM_SEG           *p_seg;
   1357              void              *p_pool_mem;
   1358              CPU_SIZE_T         pool_size;
   1359              CPU_SIZE_T         tbl_size;
   1360              CPU_SIZE_T         blk_size_align;
   1361              CPU_ADDR           pool_addr_end;
   1362              MEM_POOL_BLK_QTY   blk_ix;
   1363              CPU_INT08U        *p_blk;
   1364              CPU_SR_ALLOC();
   \   00000010   0x2000             MOVS     R0,#+0
   1365          
   1366          
   1367          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* --------------- VALIDATE RTN ERR PTR --------------- */
   1368              if (p_err == DEF_NULL) {
   1369                  CPU_SW_EXCEPTION(;);
   1370              }
   1371          
   1372                                                                          /* ------------- VALIDATE MEM POOL CREATE ------------- */
   1373              if (p_pool == DEF_NULL) {
   1374                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1375                  return;
   1376              }
   1377          
   1378              if (p_mem_base != DEF_NULL) {
   1379                  if (mem_size < 1u) {
   1380                     *p_err = LIB_MEM_ERR_INVALID_SEG_SIZE;
   1381                      return;
   1382                  }
   1383              }
   1384          
   1385              if (blk_nbr < 1u) {
   1386                 *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
   1387                  return;
   1388              }
   1389          
   1390              if (blk_size < 1u) {
   1391                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1392                  return;
   1393              }
   1394          
   1395              if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk that req alignment is a pwr of 2.                */
   1396                 *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   1397                  return;
   1398              }
   1399          #endif
   1400          
   1401              Mem_PoolClr(p_pool, p_err);                                 /* Init mem pool.                                       */
   \   00000012   0x4641             MOV      R1,R8
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       Mem_PoolClr
   1402              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000001A   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   0000001E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xF040 0x8094      BNE.W    ??Mem_PoolCreate_0
   1403                   return;
   \                     ??Mem_PoolCreate_1: (+1)
   \   00000028   0x9F0E             LDR      R7,[SP, #+56]
   1404              }
   1405          
   1406                                                                          /* -------- DETERMINE AND/OR ALLOC SEG TO USE --------- */
   1407              if (p_mem_base == DEF_NULL) {                               /* Use heap seg.                                        */
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD102             BNE.N    ??Mem_PoolCreate_2
   1408                  p_seg = &Mem_SegHeap;
   \   0000002E   0x.... 0x....      LDR.W    R10,??DataTable12_2
   \   00000032   0xE014             B.N      ??Mem_PoolCreate_3
   1409              } else {                                                    /* Use other seg.                                       */
   1410                  CPU_CRITICAL_ENTER();
   \                     ??Mem_PoolCreate_2: (+1)
   \   00000034   0x2040             MOVS     R0,#+64
   \   00000036   0x.... 0x....      BL       CPU_SR_Save
   \   0000003A   0x4683             MOV      R11,R0
   1411                  p_seg = Mem_SegOverlapChkCritical((CPU_ADDR)p_mem_base,
   1412                                                              mem_size,
   1413                                                              p_err);
   \   0000003C   0x4642             MOV      R2,R8
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       Mem_SegOverlapChkCritical
   \   00000046   0x4682             MOV      R10,R0
   1414                  switch (*p_err) {
   \   00000048   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   0000004C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000050   0x1A40             SUBS     R0,R0,R1
   \   00000052   0xD00B             BEQ.N    ??Mem_PoolCreate_4
   \   00000054   0x3870             SUBS     R0,R0,#+112
   \   00000056   0xD126             BNE.N    ??Mem_PoolCreate_5
   1415                      case LIB_MEM_ERR_INVALID_SEG_EXISTS:                /* Seg already exists.                                  */
   1416                           break;
   1417          
   1418                      case LIB_MEM_ERR_NONE:                              /* Seg must be created.                                 */
   1419                           p_seg = (MEM_SEG *)Mem_SegAllocExtCritical(&Mem_SegHeap,
   1420                                                                       sizeof(MEM_SEG),
   1421                                                                       sizeof(CPU_ALIGN),
   1422                                                                       LIB_MEM_PADDING_ALIGN_NONE,
   1423                                                                       p_bytes_reqd,
   1424                                                                       p_err);
   1425                           if (*p_err != LIB_MEM_ERR_NONE) {
   1426                               CPU_CRITICAL_EXIT();
   1427                               return;
   1428                           }
   1429          
   1430          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
   1431                           Mem_SegAllocTrackCritical("Unknown segment data",
   1432                                                     &Mem_SegHeap,
   1433                                                      sizeof(MEM_SEG),
   1434                                                      p_err);
   1435                           if (*p_err != LIB_MEM_ERR_NONE) {
   1436                               CPU_CRITICAL_EXIT();
   1437                               return;
   1438                           }
   1439          #endif
   1440          
   1441                           Mem_SegCreateCritical(          DEF_NULL,
   1442                                                           p_seg,
   1443                                                 (CPU_ADDR)p_mem_base,
   1444                                                           LIB_MEM_PADDING_ALIGN_NONE,
   1445                                                           mem_size);
   1446                           break;
   1447          
   1448          
   1449                      case LIB_MEM_ERR_INVALID_SEG_OVERLAP:
   1450                      default:
   1451                           CPU_CRITICAL_EXIT();
   1452                           return;                                        /* Prevent 'break NOT reachable' compiler warning.      */
   1453                  }
   1454          
   1455                  CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolCreate_6: (+1)
   \                     ??Mem_PoolCreate_7: (+1)
   \   00000058   0x4658             MOV      R0,R11
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
   \                     ??Mem_PoolCreate_3: (+1)
   \   0000005E   0x9B0D             LDR      R3,[SP, #+52]
   \   00000060   0x9C0C             LDR      R4,[SP, #+48]
   1456              }
   1457          
   1458                                                                          /* ---------------- ALLOC MEM FOR POOL ---------------- */
   1459                                                                          /* Calc blk size with align.                            */
   1460              blk_size_align =  MATH_ROUND_INC_UP_PWR2(blk_size, blk_align);
   \   00000062   0x1E58             SUBS     R0,R3,#+1
   \   00000064   0x4204             TST      R4,R0
   \   00000066   0xD122             BNE.N    ??Mem_PoolCreate_8
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0xE021             B.N      ??Mem_PoolCreate_9
   \                     ??Mem_PoolCreate_4: (+1)
   \   0000006C   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000070   0x9700             STR      R7,[SP, #+0]
   \   00000072   0x2301             MOVS     R3,#+1
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0x2114             MOVS     R1,#+20
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000007C   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \   00000080   0x4682             MOV      R10,R0
   \   00000082   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   00000086   0xF242 0x7110      MOVW     R1,#+10000
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xD003             BEQ.N    ??Mem_PoolCreate_10
   \   0000008E   0x4658             MOV      R0,R11
   \   00000090   0x.... 0x....      BL       CPU_SR_Restore
   \   00000094   0xE05C             B.N      ??Mem_PoolCreate_0
   \                     ??Mem_PoolCreate_10: (+1)
   \   00000096   0x9500             STR      R5,[SP, #+0]
   \   00000098   0x2301             MOVS     R3,#+1
   \   0000009A   0x0022             MOVS     R2,R4
   \   0000009C   0x4651             MOV      R1,R10
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      BL       Mem_SegCreateCritical
   \   000000A4   0xE7D8             B.N      ??Mem_PoolCreate_7
   \                     ??Mem_PoolCreate_5: (+1)
   \   000000A6   0x4658             MOV      R0,R11
   \   000000A8   0x.... 0x....      BL       CPU_SR_Restore
   \   000000AC   0xE050             B.N      ??Mem_PoolCreate_0
   \                     ??Mem_PoolCreate_8: (+1)
   \   000000AE   0x0019             MOVS     R1,R3
   \                     ??Mem_PoolCreate_9: (+1)
   \   000000B0   0x1E58             SUBS     R0,R3,#+1
   \   000000B2   0x4384             BICS     R4,R4,R0
   \   000000B4   0x190C             ADDS     R4,R1,R4
   1461              pool_size      =  blk_size_align * blk_nbr;                 /* Calc required size for pool.                         */
   \   000000B6   0xFB09 0xF504      MUL      R5,R9,R4
   1462              tbl_size       =  blk_nbr * sizeof(void *);                 /* Calc required size for free block table.             */
   \   000000BA   0xEA5F 0x0B89      LSLS     R11,R9,#+2
   1463          
   1464                                                                          /* Detect integer overflows in the size calculations.   */
   1465              if ((blk_size_align >  (DEF_INT_CPU_U_MAX_VAL / blk_nbr       )) ||
   1466                  (blk_nbr        >  (DEF_INT_CPU_U_MAX_VAL / sizeof(void *)))) {
   \   000000BE   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000C2   0xFBB0 0xF0F9      UDIV     R0,R0,R9
   \   000000C6   0x42A0             CMP      R0,R4
   \   000000C8   0xD302             BCC.N    ??Mem_PoolCreate_11
   \   000000CA   0xF1B9 0x4F80      CMP      R9,#+1073741824
   \   000000CE   0xD304             BCC.N    ??Mem_PoolCreate_12
   1467                 *p_err = LIB_MEM_ERR_ADDR_OVF;
   \                     ??Mem_PoolCreate_11: (+1)
   \   000000D0   0xF642 0x003C      MOVW     R0,#+10300
   \   000000D4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1468                  return;
   \   000000D8   0xE03A             B.N      ??Mem_PoolCreate_0
   1469              }
   1470          
   1471                                                                          /* Alloc mem for pool.                                  */
   1472              p_pool_mem = (void *)Mem_SegAllocInternal("Unnamed static pool",
   1473                                                         p_seg,
   1474                                                         pool_size,
   1475                                                         blk_align,
   1476                                                         LIB_MEM_PADDING_ALIGN_NONE,
   1477                                                         p_bytes_reqd,
   1478                                                         p_err);
   \                     ??Mem_PoolCreate_12: (+1)
   \   000000DA   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \   000000DE   0x9701             STR      R7,[SP, #+4]
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x9000             STR      R0,[SP, #+0]
   \   000000E4   0x002A             MOVS     R2,R5
   \   000000E6   0x4651             MOV      R1,R10
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable12_4
   \   000000EC   0x.... 0x....      BL       Mem_SegAllocInternal
   \   000000F0   0x4682             MOV      R10,R0
   1479              if (*p_err != LIB_MEM_ERR_NONE) {
   \   000000F2   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   000000F6   0xF242 0x7110      MOVW     R1,#+10000
   \   000000FA   0x4288             CMP      R0,R1
   \   000000FC   0xD128             BNE.N    ??Mem_PoolCreate_0
   1480                  return;
   1481              }
   1482          
   1483                                                                          /* ------------ ALLOC MEM FOR FREE BLK TBL ------------ */
   1484              p_pool->BlkFreeTbl = (void **)Mem_SegAllocInternal("Unnamed static pool free blk tbl",
   1485                                                                 &Mem_SegHeap,
   1486                                                                  tbl_size,
   1487                                                                  sizeof(CPU_ALIGN),
   1488                                                                  LIB_MEM_PADDING_ALIGN_NONE,
   1489                                                                  p_bytes_reqd,
   1490                                                                  p_err);
   \                     ??Mem_PoolCreate_13: (+1)
   \   000000FE   0xF8CD 0x8008      STR      R8,[SP, #+8]
   \   00000102   0x9701             STR      R7,[SP, #+4]
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0x9000             STR      R0,[SP, #+0]
   \   00000108   0x2304             MOVS     R3,#+4
   \   0000010A   0x465A             MOV      R2,R11
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   00000114   0x.... 0x....      BL       Mem_SegAllocInternal
   \   00000118   0x6130             STR      R0,[R6, #+16]
   1491              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000011A   0xF9B8 0x0000      LDRSH    R0,[R8, #+0]
   \   0000011E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD114             BNE.N    ??Mem_PoolCreate_0
   1492                  return;
   1493              }
   1494          
   1495                                                                          /* ------------------ INIT BLK LIST ------------------- */
   1496              p_blk = (CPU_INT08U *)p_pool_mem;
   \                     ??Mem_PoolCreate_14: (+1)
   \   00000126   0x4651             MOV      R1,R10
   1497              for (blk_ix = 0; blk_ix < blk_nbr; blk_ix++) {
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xE004             B.N      ??Mem_PoolCreate_15
   1498                  p_pool->BlkFreeTbl[blk_ix]  = p_blk;
   \                     ??Mem_PoolCreate_16: (+1)
   \   0000012C   0x6932             LDR      R2,[R6, #+16]
   \   0000012E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   1499                  p_blk                      += blk_size_align;
   \   00000132   0x4421             ADD      R1,R1,R4
   1500              }
   \   00000134   0x1C40             ADDS     R0,R0,#+1
   \                     ??Mem_PoolCreate_15: (+1)
   \   00000136   0x4548             CMP      R0,R9
   \   00000138   0xD3F8             BCC.N    ??Mem_PoolCreate_16
   1501          
   1502          
   1503                                                                          /* ------------------ INIT POOL DATA ------------------ */
   1504              pool_addr_end         = (CPU_ADDR)p_pool_mem + (pool_size - 1u);
   \   0000013A   0xEB15 0x050A      ADDS     R5,R5,R10
   \   0000013E   0x1E6D             SUBS     R5,R5,#+1
   1505              p_pool->PoolAddrStart =  p_pool_mem;
   \   00000140   0xF8C6 0xA000      STR      R10,[R6, #+0]
   1506              p_pool->PoolAddrEnd   = (void *)pool_addr_end;
   \   00000144   0x6075             STR      R5,[R6, #+4]
   1507              p_pool->BlkNbr        =  blk_nbr;
   \   00000146   0xF8C6 0x9008      STR      R9,[R6, #+8]
   1508              p_pool->BlkSize       =  blk_size_align;
   \   0000014A   0x60F4             STR      R4,[R6, #+12]
   1509              p_pool->BlkFreeTblIx  =  blk_nbr;
   \   0000014C   0xF8C6 0x9014      STR      R9,[R6, #+20]
   1510          }
   \                     ??Mem_PoolCreate_0: (+1)
   \   00000150   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   1511          #endif
   1512          
   1513          
   1514          /*
   1515          *********************************************************************************************************
   1516          *                                            Mem_PoolClr()
   1517          *
   1518          * Description : Clears a memory pool (see Note #1).
   1519          *
   1520          * Argument(s) : p_pool   Pointer to a memory pool structure to clear (see Note #2).
   1521          *
   1522          *               p_err    Pointer to variable that will receive the return error code from this function :
   1523          *
   1524          *                               LIB_MEM_ERR_NONE                Operation was successful.
   1525          *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1526          *
   1527          * Return(s)   : none.
   1528          *
   1529          * Caller(s)   : Application,
   1530          *               Mem_PoolCreate().
   1531          *
   1532          * Note(s)     : (1) (a) Mem_PoolClr() ONLY clears a memory pool structure's variables & should ONLY be
   1533          *                       called to initialize a memory pool structure prior to calling Mem_PoolCreate().
   1534          *
   1535          *                   (b) Mem_PoolClr() does NOT deallocate memory from the memory pool or deallocate the
   1536          *                       memory pool itself & MUST NOT be called after calling Mem_PoolCreate() since
   1537          *                       this will likely corrupt the memory pool management.
   1538          *
   1539          *               (2) Assumes 'p_pool' points to a valid memory pool (if non-NULL).
   1540          *
   1541          *               (3) This function is DEPRECATED and will be removed in a future version of this product.
   1542          *********************************************************************************************************
   1543          */
   1544          
   1545          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1546          void  Mem_PoolClr (MEM_POOL  *p_pool,
   1547                             LIB_ERR   *p_err)
   1548          {
   1549          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
   1550              if (p_err == DEF_NULL) {
   1551                  CPU_SW_EXCEPTION(;);
   1552              }
   1553          
   1554                                                                          /* -------------- VALIDATE MEM POOL PTR --------------- */
   1555              if (p_pool == DEF_NULL) {
   1556                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1557                  return;
   1558              }
   1559          #endif
   1560          
   1561              p_pool->PoolAddrStart = DEF_NULL;
   \                     Mem_PoolClr: (+1)
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1562              p_pool->PoolAddrEnd   = DEF_NULL;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6042             STR      R2,[R0, #+4]
   1563              p_pool->BlkSize       = 0u;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x60C2             STR      R2,[R0, #+12]
   1564              p_pool->BlkNbr        = 0u;
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x6082             STR      R2,[R0, #+8]
   1565              p_pool->BlkFreeTbl    = DEF_NULL;
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x6102             STR      R2,[R0, #+16]
   1566              p_pool->BlkFreeTblIx  = 0u;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x6142             STR      R2,[R0, #+20]
   1567          
   1568             *p_err = LIB_MEM_ERR_NONE;
   \   00000018   0xF242 0x7010      MOVW     R0,#+10000
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
   1569          }
   \   0000001E   0x4770             BX       LR               ;; return
   1570          #endif
   1571          
   1572          
   1573          /*
   1574          *********************************************************************************************************
   1575          *                                          Mem_PoolBlkGet()
   1576          *
   1577          * Description : Gets a memory block from memory pool.
   1578          *
   1579          * Argument(s) : p_pool  Pointer to  memory pool to get memory block from.
   1580          *
   1581          *               size    Size of requested memory (in bytes).
   1582          *
   1583          *               p_err   Pointer to variable that will receive the return error code from this function :
   1584          *
   1585          *                           LIB_MEM_ERR_NONE                Operation was successful.
   1586          *                           LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid memory pool block size requested.
   1587          *                           LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1588          *                           LIB_MEM_ERR_POOL_EMPTY          NO memory blocks available in memory pool.
   1589          *
   1590          * Return(s)   : Pointer to memory block, if NO error(s).
   1591          *
   1592          *               Pointer to NULL,         otherwise.
   1593          *
   1594          * Caller(s)   : Application.
   1595          *
   1596          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1597          *                   Mem_DynPoolBlkGet() should be used instead.
   1598          *********************************************************************************************************
   1599          */
   1600          
   1601          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1602          void  *Mem_PoolBlkGet (MEM_POOL    *p_pool,
   1603                                 CPU_SIZE_T   size,
   1604                                 LIB_ERR     *p_err)
   1605          {
   \                     Mem_PoolBlkGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x0016             MOVS     R6,R2
   1606              CPU_INT08U  *p_blk;
   1607              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
   1608          
   1609          
   1610          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL GET --------------- */
   1611              if (p_err == DEF_NULL) {                                    /* Validate err ptr.                                    */
   1612                  CPU_SW_EXCEPTION(DEF_NULL);
   1613              }
   1614          
   1615              if (p_pool == DEF_NULL) {                                   /* Validate pool ptr.                                   */
   1616                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1617                  return (DEF_NULL);
   1618              }
   1619          
   1620              if (size < 1u) {                                            /* Validate req'd size as non-NULL.                     */
   1621                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1622                  return (DEF_NULL);
   1623              }
   1624          
   1625              if (size > p_pool->BlkSize) {                               /* Validate req'd size <= mem pool blk size.            */
   1626                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   1627                  return (DEF_NULL);
   1628              }
   1629          #else
   1630              (void)size;                                                 /* Prevent possible 'variable unused' warning.          */
   1631          #endif
   1632          
   1633          
   1634                                                                          /* -------------- GET MEM BLK FROM POOL --------------- */
   1635              p_blk = DEF_NULL;
   \   00000008   0x2400             MOVS     R4,#+0
   1636              CPU_CRITICAL_ENTER();
   \   0000000A   0x2040             MOVS     R0,#+64
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   1637              if (p_pool->BlkFreeTblIx > 0u) {
   \   00000010   0x6969             LDR      R1,[R5, #+20]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD00B             BEQ.N    ??Mem_PoolBlkGet_0
   1638                  p_pool->BlkFreeTblIx                     -=  1u;
   \   00000016   0x6969             LDR      R1,[R5, #+20]
   \   00000018   0x1E49             SUBS     R1,R1,#+1
   \   0000001A   0x6169             STR      R1,[R5, #+20]
   1639                  p_blk                                     = (CPU_INT08U *)p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx];
   \   0000001C   0x6929             LDR      R1,[R5, #+16]
   \   0000001E   0x696A             LDR      R2,[R5, #+20]
   \   00000020   0xF851 0x4022      LDR      R4,[R1, R2, LSL #+2]
   1640                  p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  =  DEF_NULL;
   \   00000024   0x6929             LDR      R1,[R5, #+16]
   \   00000026   0x696A             LDR      R2,[R5, #+20]
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0xF841 0x3022      STR      R3,[R1, R2, LSL #+2]
   1641              }
   1642              CPU_CRITICAL_EXIT();
   \                     ??Mem_PoolBlkGet_0: (+1)
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
   1643          
   1644              if (p_blk == DEF_NULL) {
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD103             BNE.N    ??Mem_PoolBlkGet_1
   1645                 *p_err = LIB_MEM_ERR_POOL_EMPTY;
   \   00000036   0xF242 0x70DE      MOVW     R0,#+10206
   \   0000003A   0x8030             STRH     R0,[R6, #+0]
   \   0000003C   0xE002             B.N      ??Mem_PoolBlkGet_2
   1646              } else {
   1647                 *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_PoolBlkGet_1: (+1)
   \   0000003E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000042   0x8030             STRH     R0,[R6, #+0]
   1648              }
   1649          
   1650              return (p_blk);
   \                     ??Mem_PoolBlkGet_2: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
   1651          }
   1652          #endif
   1653          
   1654          
   1655          /*
   1656          *********************************************************************************************************
   1657          *                                          Mem_PoolBlkFree()
   1658          *
   1659          * Description : Free a memory block to memory pool.
   1660          *
   1661          * Argument(s) : p_pool  Pointer to memory pool to free memory block.
   1662          *
   1663          *               p_blk   Pointer to memory block address to free.
   1664          *
   1665          *               p_err   Pointer to variable that will receive the return error code from this function :
   1666          *
   1667          *                           LIB_MEM_ERR_NONE                        Operation was successful.
   1668          *                           LIB_MEM_ERR_NULL_PTR                    Argument 'p_pool'/'p_blk' passed
   1669          *                                                                       a NULL pointer.
   1670          *                           LIB_MEM_ERR_INVALID_BLK_ADDR            Invalid memory block address.
   1671          *                           LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL            Memory block address already
   1672          *                                                                        in memory pool.
   1673          *                           LIB_MEM_ERR_POOL_FULL                   Pool is full.
   1674          *
   1675          * Return(s)   : none.
   1676          *
   1677          * Caller(s)   : Application.
   1678          *
   1679          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1680          *                   Mem_DynPoolBlkFree() should be used instead.
   1681          *********************************************************************************************************
   1682          */
   1683          
   1684          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1685          void  Mem_PoolBlkFree (MEM_POOL  *p_pool,
   1686                                 void      *p_blk,
   1687                                 LIB_ERR   *p_err)
   1688          {
   \                     Mem_PoolBlkFree: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   1689          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1690              CPU_SIZE_T   tbl_ix;
   1691              CPU_BOOLEAN  addr_valid;
   1692          #endif
   1693              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   1694          
   1695          
   1696          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE MEM POOL FREE -------------- */
   1697              if (p_err == DEF_NULL) {
   1698                  CPU_SW_EXCEPTION(;);
   1699              }
   1700          
   1701              if (p_pool == DEF_NULL) {                                   /* Validate mem ptrs.                                   */
   1702                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1703                  return;
   1704              }
   1705          
   1706              if (p_blk == DEF_NULL) {
   1707                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1708                  return;
   1709              }
   1710          
   1711              addr_valid = Mem_PoolBlkIsValidAddr(p_pool, p_blk);         /* Validate mem blk as valid pool blk addr.             */
   1712              if (addr_valid != DEF_OK) {
   1713                 *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR;
   1714                  return;
   1715              }
   1716          
   1717              CPU_CRITICAL_ENTER();                                       /* Make sure blk isn't already in free list.            */
   1718              for (tbl_ix = 0u; tbl_ix < p_pool->BlkNbr; tbl_ix++) {
   1719                  if (p_pool->BlkFreeTbl[tbl_ix] == p_blk) {
   1720                      CPU_CRITICAL_EXIT();
   1721                     *p_err = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
   1722                      return;
   1723                  }
   1724              }
   1725          #else                                                           /* Double-free possibility if not in critical section.  */
   1726              CPU_CRITICAL_ENTER();
   \   0000000A   0x2040             MOVS     R0,#+64
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
   1727          #endif
   1728                                                                          /* --------------- FREE MEM BLK TO POOL --------------- */
   1729              if (p_pool->BlkFreeTblIx >= p_pool->BlkNbr) {
   \   00000010   0x6969             LDR      R1,[R5, #+20]
   \   00000012   0x68AA             LDR      R2,[R5, #+8]
   \   00000014   0x4291             CMP      R1,R2
   \   00000016   0xD305             BCC.N    ??Mem_PoolBlkFree_0
   1730                  CPU_CRITICAL_EXIT();
   \   00000018   0x.... 0x....      BL       CPU_SR_Restore
   1731                 *p_err = LIB_MEM_ERR_POOL_FULL;
   \   0000001C   0xF242 0x70DD      MOVW     R0,#+10205
   \   00000020   0x8020             STRH     R0,[R4, #+0]
   1732                  return;
   \   00000022   0xE00B             B.N      ??Mem_PoolBlkFree_1
   1733              }
   1734          
   1735              p_pool->BlkFreeTbl[p_pool->BlkFreeTblIx]  = p_blk;
   \                     ??Mem_PoolBlkFree_0: (+1)
   \   00000024   0x6929             LDR      R1,[R5, #+16]
   \   00000026   0x696A             LDR      R2,[R5, #+20]
   \   00000028   0xF841 0x6022      STR      R6,[R1, R2, LSL #+2]
   1736              p_pool->BlkFreeTblIx                     += 1u;
   \   0000002C   0x6969             LDR      R1,[R5, #+20]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x6169             STR      R1,[R5, #+20]
   1737              CPU_CRITICAL_EXIT();
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
   1738          
   1739             *p_err = LIB_MEM_ERR_NONE;
   \   00000036   0xF242 0x7010      MOVW     R0,#+10000
   \   0000003A   0x8020             STRH     R0,[R4, #+0]
   1740          }
   \                     ??Mem_PoolBlkFree_1: (+1)
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
   1741          #endif
   1742          
   1743          
   1744          /*
   1745          *********************************************************************************************************
   1746          *                                      Mem_PoolBlkGetNbrAvail()
   1747          *
   1748          * Description : Get memory pool's remaining number of blocks available to allocate.
   1749          *
   1750          * Argument(s) : p_pool   Pointer to a memory pool structure.
   1751          *
   1752          *               p_err    Pointer to variable that will receive the return error code from this function :
   1753          *
   1754          *                               LIB_MEM_ERR_NONE                Operation was successful.
   1755          *                               LIB_MEM_ERR_NULL_PTR            Argument 'p_pool' passed a NULL pointer.
   1756          *
   1757          * Return(s)   : Remaining memory pool blocks,   if NO error(s).
   1758          *
   1759          *               0,                              otherwise.
   1760          *
   1761          * Caller(s)   : Application.
   1762          *
   1763          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   1764          *                   Mem_DynPoolBlkNbrAvailGet() should be used instead.
   1765          *********************************************************************************************************
   1766          */
   1767          
   1768          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1769          MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *p_pool,
   1770                                                    LIB_ERR   *p_err)
   1771          {
   \                     Mem_PoolBlkGetNbrAvail: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1772              CPU_SIZE_T  nbr_avail;
   1773              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
   1774          
   1775          
   1776          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1777                                                                          /* --------------- VALIDATE RTN ERR PTR --------------- */
   1778              if (p_err == DEF_NULL) {
   1779                  CPU_SW_EXCEPTION(0u);
   1780              }
   1781                                                                          /* ---------------- VALIDATE MEM POOL ----------------- */
   1782              if (p_pool == DEF_NULL) {                                   /* Validate mem ptr.                                    */
   1783                 *p_err =  LIB_MEM_ERR_NULL_PTR;
   1784                  return (0u);
   1785              }
   1786          #endif
   1787          
   1788              CPU_CRITICAL_ENTER();
   \   00000008   0x2040             MOVS     R0,#+64
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
   1789              nbr_avail = p_pool->BlkFreeTblIx;
   \   0000000E   0x6964             LDR      R4,[R4, #+20]
   1790              CPU_CRITICAL_EXIT();
   \   00000010   0x.... 0x....      BL       CPU_SR_Restore
   1791          
   1792             *p_err = LIB_MEM_ERR_NONE;
   \   00000014   0xF242 0x7010      MOVW     R0,#+10000
   \   00000018   0x8028             STRH     R0,[R5, #+0]
   1793          
   1794              return (nbr_avail);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1795          }
   1796          #endif
   1797          
   1798          
   1799          /*
   1800          *********************************************************************************************************
   1801          *                                          Mem_DynPoolCreate()
   1802          *
   1803          * Description : Creates a dynamic memory pool.
   1804          *
   1805          * Argument(s) : p_name          Pointer to pool name.
   1806          *
   1807          *               p_pool          Pointer to pool data.
   1808          *
   1809          *               p_seg           Pointer to segment from which to allocate memory. Will be allocated from
   1810          *                               general-purpose heap if null.
   1811          *
   1812          *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
   1813          *
   1814          *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
   1815          *
   1816          *               blk_qty_init    Initial number of elements to be allocated in pool.
   1817          *
   1818          *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1819          *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1820          *
   1821          *               p_err           Pointer to variable that will receive the return error code from this function :
   1822          *
   1823          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1824          *
   1825          *                                   --------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
   1826          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
   1827          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
   1828          *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
   1829          *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
   1830          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1831          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1832          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1833          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1834          *                                   LIB_MEM_ERR_ADDR_OVF            Memory allocation exceeds address space.
   1835          *
   1836          * Return(s)   : None.
   1837          *
   1838          * Caller(s)   : Application.
   1839          *
   1840          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1841          *                   block is stored in the block itself (only when free/unused).
   1842          *********************************************************************************************************
   1843          */
   1844          

   \                                 In section .text, align 2, keep-with-next
   1845          void  Mem_DynPoolCreate (const  CPU_CHAR      *p_name,
   1846                                          MEM_DYN_POOL  *p_pool,
   1847                                          MEM_SEG       *p_seg,
   1848                                          CPU_SIZE_T     blk_size,
   1849                                          CPU_SIZE_T     blk_align,
   1850                                          CPU_SIZE_T     blk_qty_init,
   1851                                          CPU_SIZE_T     blk_qty_max,
   1852                                          LIB_ERR       *p_err)
   1853          {
   \                     Mem_DynPoolCreate: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1854              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??Mem_DynPoolCreate_0
   1855          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1856                  p_seg = &Mem_SegHeap;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \                     ??Mem_DynPoolCreate_0: (+1)
   \   0000000C   0x9F0D             LDR      R7,[SP, #+52]
   \   0000000E   0x9E0C             LDR      R6,[SP, #+48]
   \   00000010   0x9D0B             LDR      R5,[SP, #+44]
   \   00000012   0x9C0A             LDR      R4,[SP, #+40]
   1857          #else
   1858                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1859                  return;
   1860          #endif
   1861              }
   1862          
   1863              Mem_DynPoolCreateInternal(p_name,
   1864                                        p_pool,
   1865                                        p_seg,
   1866                                        blk_size,
   1867                                        blk_align,
   1868                                        LIB_MEM_PADDING_ALIGN_NONE,
   1869                                        blk_qty_init,
   1870                                        blk_qty_max,
   1871                                        p_err);
   \   00000014   0x9704             STR      R7,[SP, #+16]
   \   00000016   0x9603             STR      R6,[SP, #+12]
   \   00000018   0x9502             STR      R5,[SP, #+8]
   \   0000001A   0x2501             MOVS     R5,#+1
   \   0000001C   0x9501             STR      R5,[SP, #+4]
   \   0000001E   0x9400             STR      R4,[SP, #+0]
   \   00000020   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1872          }
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBDF0             POP      {R4-R7,PC}       ;; return
   1873          
   1874          
   1875          /*
   1876          *********************************************************************************************************
   1877          *                                        Mem_DynPoolCreateHW()
   1878          *
   1879          * Description : Creates a dynamic memory pool. Memory blocks will be padded according to memory segment's
   1880          *               properties.
   1881          *
   1882          * Argument(s) : p_name          Pointer to pool name.
   1883          *
   1884          *               p_pool          Pointer to pool data.
   1885          *
   1886          *               p_seg           Pointer to segment from which to allocate memory. Will allocate from
   1887          *                               general-purpose heap if null.
   1888          *
   1889          *               blk_size        Size of memory block to allocate from pool, in bytes. See Note #1.
   1890          *
   1891          *               blk_align       Required alignment of memory block, in bytes. MUST be a power of 2.
   1892          *
   1893          *               blk_qty_init    Initial number of elements to be allocated in pool.
   1894          *
   1895          *               blk_qty_max     Maximum number of elements that can be allocated from this pool. Set to
   1896          *                               LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   1897          *
   1898          *               p_err           Pointer to variable that will receive the return error code from this function :
   1899          *
   1900          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   1901          *
   1902          *                                   -------------------RETURNED BY Mem_DynPoolCreateInternal()-------------------
   1903          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   1904          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   1905          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   1906          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   1907          *                                   LIB_MEM_ERR_ADDR_OVF            Memory allocation exceeds address space.
   1908          *
   1909          * Return(s)   : None.
   1910          *
   1911          * Caller(s)   : Application.
   1912          *
   1913          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   1914          *                   block is stored in the block itself (only when free/unused).
   1915          *********************************************************************************************************
   1916          */
   1917          

   \                                 In section .text, align 2, keep-with-next
   1918          void  Mem_DynPoolCreateHW (const  CPU_CHAR      *p_name,
   1919                                            MEM_DYN_POOL  *p_pool,
   1920                                            MEM_SEG       *p_seg,
   1921                                            CPU_SIZE_T     blk_size,
   1922                                            CPU_SIZE_T     blk_align,
   1923                                            CPU_SIZE_T     blk_qty_init,
   1924                                            CPU_SIZE_T     blk_qty_max,
   1925                                            LIB_ERR       *p_err)
   1926          {
   \                     Mem_DynPoolCreateHW: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1927              if (p_seg == DEF_NULL) {                                    /* Alloc from heap if p_seg is null.                    */
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??Mem_DynPoolCreateHW_0
   1928          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   1929                  p_seg = &Mem_SegHeap;
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \                     ??Mem_DynPoolCreateHW_0: (+1)
   \   0000000C   0x9F0D             LDR      R7,[SP, #+52]
   \   0000000E   0x9E0C             LDR      R6,[SP, #+48]
   \   00000010   0x9D0B             LDR      R5,[SP, #+44]
   \   00000012   0x9C0A             LDR      R4,[SP, #+40]
   1930          #else
   1931                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1932                  return;
   1933          #endif
   1934              }
   1935          
   1936              Mem_DynPoolCreateInternal(p_name,
   1937                                        p_pool,
   1938                                        p_seg,
   1939                                        blk_size,
   1940                                        blk_align,
   1941                                        p_seg->PaddingAlign,
   1942                                        blk_qty_init,
   1943                                        blk_qty_max,
   1944                                        p_err);
   \   00000014   0x9704             STR      R7,[SP, #+16]
   \   00000016   0x9603             STR      R6,[SP, #+12]
   \   00000018   0x9502             STR      R5,[SP, #+8]
   \   0000001A   0x6915             LDR      R5,[R2, #+16]
   \   0000001C   0x9501             STR      R5,[SP, #+4]
   \   0000001E   0x9400             STR      R4,[SP, #+0]
   \   00000020   0x.... 0x....      BL       Mem_DynPoolCreateInternal
   1945          }
   \   00000024   0xB005             ADD      SP,SP,#+20
   \   00000026   0xBDF0             POP      {R4-R7,PC}       ;; return
   1946          
   1947          
   1948          /*
   1949          *********************************************************************************************************
   1950          *                                          Mem_DynPoolBlkGet()
   1951          *
   1952          * Description : Gets a memory block from specified pool, growing it if needed.
   1953          *
   1954          * Argument(s) : p_pool  Pointer to pool data.
   1955          *
   1956          *               p_err   Pointer to variable that will receive the return error code from this function :
   1957          *
   1958          *                           LIB_MEM_ERR_NONE                    Operation was successful.
   1959          *                           LIB_MEM_ERR_NULL_PTR                Pool data pointer NULL.
   1960          *                           LIB_MEM_ERR_POOL_EMPTY              Pools is empty.
   1961          *
   1962          *                           ----------------------RETURNED BY Mem_SegAllocInternal()-----------------------
   1963          *                           LIB_MEM_ERR_INVALID_MEM_ALIGN       Invalid memory block alignment requested.
   1964          *                           LIB_MEM_ERR_INVALID_MEM_SIZE        Invalid memory block size specified.
   1965          *                           LIB_MEM_ERR_NULL_PTR                Error or segment data pointer NULL.
   1966          *                           LIB_MEM_ERR_SEG_OVF                 Allocation would overflow memory segment.
   1967          *
   1968          * Return(s)   : Pointer to memory block, if successful.
   1969          *
   1970          *               DEF_NULL, otherwise.
   1971          *
   1972          * Caller(s)   : Application.
   1973          *
   1974          * Note(s)     : none.
   1975          *********************************************************************************************************
   1976          */
   1977          

   \                                 In section .text, align 2, keep-with-next
   1978          void  *Mem_DynPoolBlkGet (MEM_DYN_POOL  *p_pool,
   1979                                    LIB_ERR       *p_err)
   1980          {
   \                     Mem_DynPoolBlkGet: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1981                     void      *p_blk;
   1982              const  CPU_CHAR  *p_pool_name;
   1983              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
   1984          
   1985          
   1986          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   1987              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   1988                  CPU_SW_EXCEPTION(DEF_NULL);
   1989              }
   1990          
   1991              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   1992                 *p_err = LIB_MEM_ERR_NULL_PTR;
   1993                  return (DEF_NULL);
   1994              }
   1995          #endif
   1996          
   1997                                                                          /* Ensure pool is not empty if qty is limited.          */
   1998              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD012             BEQ.N    ??Mem_DynPoolBlkGet_0
   1999                  CPU_CRITICAL_ENTER();
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   2000                  if (p_pool->BlkAllocCnt >= p_pool->BlkQtyMax) {
   \   00000014   0x69A1             LDR      R1,[R4, #+24]
   \   00000016   0x6962             LDR      R2,[R4, #+20]
   \   00000018   0x4291             CMP      R1,R2
   \   0000001A   0xD306             BCC.N    ??Mem_DynPoolBlkGet_1
   2001                      CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
   2002          
   2003                     *p_err = LIB_MEM_ERR_POOL_EMPTY;
   \   00000020   0xF242 0x70DE      MOVW     R0,#+10206
   \   00000024   0x8028             STRH     R0,[R5, #+0]
   2004                      return (DEF_NULL);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE02F             B.N      ??Mem_DynPoolBlkGet_2
   2005                  }
   2006          
   2007                  p_pool->BlkAllocCnt++;
   \                     ??Mem_DynPoolBlkGet_1: (+1)
   \   0000002A   0x69A1             LDR      R1,[R4, #+24]
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x61A1             STR      R1,[R4, #+24]
   2008                  CPU_CRITICAL_EXIT();
   \   00000030   0x.... 0x....      BL       CPU_SR_Restore
   2009              }
   2010          
   2011                                                                          /* --------------- ALLOC FROM FREE LIST --------------- */
   2012              CPU_CRITICAL_ENTER();
   \                     ??Mem_DynPoolBlkGet_0: (+1)
   \   00000034   0x2040             MOVS     R0,#+64
   \   00000036   0x.... 0x....      BL       CPU_SR_Save
   2013              if (p_pool->BlkFreePtr != DEF_NULL) {
   \   0000003A   0x6921             LDR      R1,[R4, #+16]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD009             BEQ.N    ??Mem_DynPoolBlkGet_3
   2014                  p_blk              = p_pool->BlkFreePtr;
   \   00000040   0x6926             LDR      R6,[R4, #+16]
   2015                  p_pool->BlkFreePtr = *((void **)p_blk);
   \   00000042   0x6831             LDR      R1,[R6, #+0]
   \   00000044   0x6121             STR      R1,[R4, #+16]
   2016                  CPU_CRITICAL_EXIT();
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
   2017          
   2018                 *p_err = LIB_MEM_ERR_NONE;
   \   0000004A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000004E   0x8028             STRH     R0,[R5, #+0]
   2019          
   2020                  return (p_blk);
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0xE01A             B.N      ??Mem_DynPoolBlkGet_2
   2021              }
   2022              CPU_CRITICAL_EXIT();
   \                     ??Mem_DynPoolBlkGet_3: (+1)
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
   2023          
   2024                                                                          /* ------------------ ALLOC NEW BLK ------------------- */
   2025          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2026              p_pool_name = p_pool->NamePtr;
   2027          #else
   2028              p_pool_name = DEF_NULL;
   \   00000058   0x2000             MOVS     R0,#+0
   2029          #endif
   2030              p_blk = Mem_SegAllocInternal(p_pool_name,
   2031                                           p_pool->PoolSegPtr,
   2032                                           p_pool->BlkSize,
   2033                                           p_pool->BlkAlign,
   2034                                           p_pool->BlkPaddingAlign,
   2035                                           DEF_NULL,
   2036                                           p_err);
   \   0000005A   0x9502             STR      R5,[SP, #+8]
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x9101             STR      R1,[SP, #+4]
   \   00000060   0x68E1             LDR      R1,[R4, #+12]
   \   00000062   0x9100             STR      R1,[SP, #+0]
   \   00000064   0x68A3             LDR      R3,[R4, #+8]
   \   00000066   0x6862             LDR      R2,[R4, #+4]
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x.... 0x....      BL       Mem_SegAllocInternal
   2037              if (*p_err != LIB_MEM_ERR_NONE) {
   \   0000006E   0xF9B5 0x1000      LDRSH    R1,[R5, #+0]
   \   00000072   0xF242 0x7210      MOVW     R2,#+10000
   \   00000076   0x4291             CMP      R1,R2
   \   00000078   0xD007             BEQ.N    ??Mem_DynPoolBlkGet_4
   2038                  if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \   0000007A   0x6960             LDR      R0,[R4, #+20]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??Mem_DynPoolBlkGet_5
   2039                      p_pool->BlkAllocCnt--;
   \   00000080   0x69A0             LDR      R0,[R4, #+24]
   \   00000082   0x1E40             SUBS     R0,R0,#+1
   \   00000084   0x61A0             STR      R0,[R4, #+24]
   2040                  }
   2041                  return (DEF_NULL);
   \                     ??Mem_DynPoolBlkGet_5: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE7FF             B.N      ??Mem_DynPoolBlkGet_2
   2042              }
   2043          
   2044              return (p_blk);
   \                     ??Mem_DynPoolBlkGet_4: (+1)
   \                     ??Mem_DynPoolBlkGet_2: (+1)
   \   0000008A   0xB004             ADD      SP,SP,#+16
   \   0000008C   0xBD70             POP      {R4-R6,PC}       ;; return
   2045          }
   2046          
   2047          
   2048          /*
   2049          *********************************************************************************************************
   2050          *                                         Mem_DynPoolBlkFree()
   2051          *
   2052          * Description : Frees memory block, making it available for future use.
   2053          *
   2054          * Argument(s) : p_pool  Pointer to pool data.
   2055          *
   2056          *               p_blk   Pointer to first byte of memory block.
   2057          *
   2058          *               p_err   Pointer to variable that will receive the return error code from this function :
   2059          *
   2060          *                           LIB_MEM_ERR_NONE        Operation was successful.
   2061          *                           LIB_MEM_ERR_NULL_PTR    'p_pool' or 'p_blk' pointer passed is NULL.
   2062          *                           LIB_MEM_ERR_POOL_FULL   Pool is full.
   2063          *
   2064          * Return(s)   : none.
   2065          *
   2066          * Caller(s)   : Application.
   2067          *
   2068          * Note(s)     : none.
   2069          *********************************************************************************************************
   2070          */
   2071          

   \                                 In section .text, align 2, keep-with-next
   2072          void  Mem_DynPoolBlkFree (MEM_DYN_POOL  *p_pool,
   2073                                    void          *p_blk,
   2074                                    LIB_ERR       *p_err)
   2075          {
   \                     Mem_DynPoolBlkFree: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   2076              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   2077          
   2078          
   2079          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2080              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2081                  CPU_SW_EXCEPTION(;);
   2082              }
   2083          
   2084              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   2085                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2086                  return;
   2087              }
   2088          
   2089              if (p_blk == DEF_NULL) {
   2090                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2091                  return;
   2092              }
   2093          #endif
   2094          
   2095              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {       /* Ensure pool is not full.                             */
   \   0000000A   0x6968             LDR      R0,[R5, #+20]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD010             BEQ.N    ??Mem_DynPoolBlkFree_0
   2096                  CPU_CRITICAL_ENTER();
   \   00000010   0x2040             MOVS     R0,#+64
   \   00000012   0x.... 0x....      BL       CPU_SR_Save
   2097                  if (p_pool->BlkAllocCnt == 0u) {
   \   00000016   0x69A9             LDR      R1,[R5, #+24]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD105             BNE.N    ??Mem_DynPoolBlkFree_1
   2098                      CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
   2099          
   2100                     *p_err = LIB_MEM_ERR_POOL_FULL;
   \   00000020   0xF242 0x70DD      MOVW     R0,#+10205
   \   00000024   0x8020             STRH     R0,[R4, #+0]
   2101                      return;
   \   00000026   0xE00F             B.N      ??Mem_DynPoolBlkFree_2
   2102                  }
   2103          
   2104                  p_pool->BlkAllocCnt--;
   \                     ??Mem_DynPoolBlkFree_1: (+1)
   \   00000028   0x69A9             LDR      R1,[R5, #+24]
   \   0000002A   0x1E49             SUBS     R1,R1,#+1
   \   0000002C   0x61A9             STR      R1,[R5, #+24]
   2105                  CPU_CRITICAL_EXIT();
   \   0000002E   0x.... 0x....      BL       CPU_SR_Restore
   2106              }
   2107          
   2108              CPU_CRITICAL_ENTER();
   \                     ??Mem_DynPoolBlkFree_0: (+1)
   \   00000032   0x2040             MOVS     R0,#+64
   \   00000034   0x.... 0x....      BL       CPU_SR_Save
   2109             *((void **)p_blk)   = p_pool->BlkFreePtr;
   \   00000038   0x6929             LDR      R1,[R5, #+16]
   \   0000003A   0x6031             STR      R1,[R6, #+0]
   2110              p_pool->BlkFreePtr = p_blk;
   \   0000003C   0x612E             STR      R6,[R5, #+16]
   2111              CPU_CRITICAL_EXIT();
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
   2112          
   2113             *p_err = LIB_MEM_ERR_NONE;
   \   00000042   0xF242 0x7010      MOVW     R0,#+10000
   \   00000046   0x8020             STRH     R0,[R4, #+0]
   2114          }
   \                     ??Mem_DynPoolBlkFree_2: (+1)
   \   00000048   0xBD70             POP      {R4-R6,PC}       ;; return
   2115          
   2116          
   2117          /*
   2118          *********************************************************************************************************
   2119          *                                     Mem_DynPoolBlkNbrAvailGet()
   2120          *
   2121          * Description : Gets number of available blocks in dynamic memory pool. This call will fail with a
   2122          *               dynamic memory pool for which no limit was set at creation.
   2123          *
   2124          * Argument(s) : p_pool  Pointer to pool data.
   2125          *
   2126          *               p_err   Pointer to variable that will receive the return error code from this function :
   2127          *
   2128          *                           LIB_MEM_ERR_NONE                Operation was successful.
   2129          *                           LIB_MEM_ERR_NULL_PTR            'p_pool' pointer passed is NULL.
   2130          *                           LIB_MEM_ERR_POOL_UNLIMITED      Pool has no specified limit.
   2131          *
   2132          * Return(s)   : Number of blocks available in dynamic memory pool, if successful.
   2133          *
   2134          *               0, if pool is empty or if an error occurred.
   2135          *
   2136          * Caller(s)   : Application.
   2137          *
   2138          * Note(s)     : None.
   2139          *********************************************************************************************************
   2140          */
   2141          

   \                                 In section .text, align 2, keep-with-next
   2142          CPU_SIZE_T  Mem_DynPoolBlkNbrAvailGet (MEM_DYN_POOL  *p_pool,
   2143                                                 LIB_ERR       *p_err)
   2144          {
   \                     Mem_DynPoolBlkNbrAvailGet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   2145              CPU_SIZE_T  blk_nbr_avail;
   2146              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
   2147          
   2148          
   2149          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2150              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2151                  CPU_SW_EXCEPTION(0);
   2152              }
   2153          
   2154              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   2155                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2156                  return (0u);
   2157              }
   2158          #endif
   2159          
   2160              if (p_pool->BlkQtyMax != LIB_MEM_BLK_QTY_UNLIMITED) {
   \   00000008   0x6968             LDR      R0,[R5, #+20]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00B             BEQ.N    ??Mem_DynPoolBlkNbrAvailGet_0
   2161                  CPU_CRITICAL_ENTER();
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   2162                  blk_nbr_avail = p_pool->BlkQtyMax - p_pool->BlkAllocCnt;
   \   00000014   0x6969             LDR      R1,[R5, #+20]
   \   00000016   0x69AD             LDR      R5,[R5, #+24]
   \   00000018   0x1B4D             SUBS     R5,R1,R5
   2163                  CPU_CRITICAL_EXIT();
   \   0000001A   0x.... 0x....      BL       CPU_SR_Restore
   2164          
   2165                 *p_err = LIB_MEM_ERR_NONE;
   \   0000001E   0xF242 0x7010      MOVW     R0,#+10000
   \   00000022   0x8020             STRH     R0,[R4, #+0]
   \   00000024   0xE003             B.N      ??Mem_DynPoolBlkNbrAvailGet_1
   2166              } else {
   2167                  blk_nbr_avail = 0u;
   \                     ??Mem_DynPoolBlkNbrAvailGet_0: (+1)
   \   00000026   0x2500             MOVS     R5,#+0
   2168                 *p_err         = LIB_MEM_ERR_POOL_UNLIMITED;
   \   00000028   0xF242 0x70DF      MOVW     R0,#+10207
   \   0000002C   0x8020             STRH     R0,[R4, #+0]
   2169              }
   2170          
   2171              return (blk_nbr_avail);
   \                     ??Mem_DynPoolBlkNbrAvailGet_1: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2172          }
   2173          
   2174          
   2175          /*
   2176          *********************************************************************************************************
   2177          *                                           Mem_OutputUsage()
   2178          *
   2179          * Description : Outputs memory usage report through 'out_fnct'.
   2180          *
   2181          * Argument(s) : out_fnct        Pointer to output function.
   2182          *
   2183          *               print_details   DEF_YES, if the size of each allocation should be printed.
   2184          *                               DEF_NO,  otherwise.
   2185          *
   2186          *               p_err           Pointer to variable that will receive the return error code from this function :
   2187          *
   2188          *                                   LIB_MEM_ERR_NONE                Operation was successful.
   2189          *                                   LIB_MEM_ERR_NULL_PTR            'out_fnct' pointer passed is NULL.
   2190          *
   2191          *                                   ---------------------RETURNED BY Mem_SegRemSizeGet()--------------------
   2192          *                                   LIB_MEM_ERR_NULL_PTR            Segment data pointer NULL.
   2193          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory alignment.
   2194          *
   2195          * Return(s)   : None.
   2196          *
   2197          * Caller(s)   : Application.
   2198          *
   2199          * Note(s)     : none.
   2200          *********************************************************************************************************
   2201          */
   2202          
   2203          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2204          void  Mem_OutputUsage(void     (*out_fnct) (CPU_CHAR *),
   2205                                LIB_ERR   *p_err)
   2206          {
   2207              CPU_CHAR   str[DEF_INT_32U_NBR_DIG_MAX];
   2208              MEM_SEG   *p_seg;
   2209              CPU_SR_ALLOC();
   2210          
   2211          
   2212          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2213              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2214                  CPU_SW_EXCEPTION(;);
   2215              }
   2216          
   2217              if (out_fnct == DEF_NULL) {                                 /* Chk for NULL out fnct ptr.                           */
   2218                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2219                  return;
   2220              }
   2221          #endif
   2222          
   2223              out_fnct((CPU_CHAR *)"---------------- Memory allocation info ----------------\r\n");
   2224              out_fnct((CPU_CHAR *)"| Type    | Size       | Free size  | Name\r\n");
   2225              out_fnct((CPU_CHAR *)"|---------|------------|------------|-------------------\r\n");
   2226          
   2227              CPU_CRITICAL_ENTER();
   2228              p_seg = Mem_SegHeadPtr;
   2229              while (p_seg != DEF_NULL) {
   2230                  CPU_SIZE_T       rem_size;
   2231                  MEM_SEG_INFO     seg_info;
   2232                  MEM_ALLOC_INFO  *p_alloc;
   2233          
   2234          
   2235                  rem_size = Mem_SegRemSizeGet(p_seg, 1u, &seg_info, p_err);
   2236                  if (*p_err != LIB_MEM_ERR_NONE) {
   2237                      return;
   2238                  }
   2239          
   2240                  out_fnct((CPU_CHAR *)"| Section | ");
   2241          
   2242                  (void)Str_FmtNbr_Int32U(seg_info.TotalSize,
   2243                                          10u,
   2244                                          DEF_NBR_BASE_DEC,
   2245                                          ' ',
   2246                                          DEF_NO,
   2247                                          DEF_YES,
   2248                                         &str[0u]);
   2249          
   2250                  out_fnct(str);
   2251                  out_fnct((CPU_CHAR *)" | ");
   2252          
   2253                  (void)Str_FmtNbr_Int32U(rem_size,
   2254                                          10u,
   2255                                          DEF_NBR_BASE_DEC,
   2256                                          ' ',
   2257                                          DEF_NO,
   2258                                          DEF_YES,
   2259                                         &str[0u]);
   2260          
   2261                  out_fnct(str);
   2262                  out_fnct((CPU_CHAR *)" | ");
   2263                  out_fnct((p_seg->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_seg->NamePtr : (CPU_CHAR *)"Unknown");
   2264                  out_fnct((CPU_CHAR *)"\r\n");
   2265          
   2266                  p_alloc = p_seg->AllocInfoHeadPtr;
   2267                  while (p_alloc != DEF_NULL) {
   2268                      out_fnct((CPU_CHAR *)"| -> Obj  | ");
   2269          
   2270                      (void)Str_FmtNbr_Int32U(p_alloc->Size,
   2271                                              10u,
   2272                                              DEF_NBR_BASE_DEC,
   2273                                              ' ',
   2274                                              DEF_NO,
   2275                                              DEF_YES,
   2276                                             &str[0u]);
   2277          
   2278                      out_fnct(str);
   2279                      out_fnct((CPU_CHAR *)" |            | ");
   2280          
   2281                      out_fnct((p_alloc->NamePtr != DEF_NULL) ? (CPU_CHAR *)p_alloc->NamePtr : (CPU_CHAR *)"Unknown");
   2282                      out_fnct((CPU_CHAR *)"\r\n");
   2283          
   2284                      p_alloc = p_alloc->NextPtr;
   2285                  }
   2286          
   2287                  p_seg = p_seg->NextPtr;
   2288              }
   2289              CPU_CRITICAL_EXIT();
   2290          
   2291             *p_err = LIB_MEM_ERR_NONE;
   2292          }
   2293          #endif
   2294          
   2295          
   2296          /*
   2297          *********************************************************************************************************
   2298          *********************************************************************************************************
   2299          *                                           LOCAL FUNCTIONS
   2300          *********************************************************************************************************
   2301          *********************************************************************************************************
   2302          */
   2303          
   2304          /*
   2305          *********************************************************************************************************
   2306          *                                       Mem_SegCreateCritical()
   2307          *
   2308          * Description : Creates a new memory segment to be used for runtime memory allocation or dynamic pools.
   2309          *
   2310          * Argument(s) : p_name          Pointer to segment name.
   2311          *
   2312          *               p_seg           Pointer to segment data. Must be allocated by caller.
   2313          *               -----           Argument validated by caller.
   2314          *
   2315          *               seg_base_addr   Segment's first byte address.
   2316          *
   2317          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer
   2318          *                               from this memory segment. MUST be a power of 2.
   2319          *                               LIB_MEM_PADDING_ALIGN_NONE means no padding.
   2320          *               -------------   Argument validated by caller.
   2321          *
   2322          *               size            Total size of segment, in bytes.
   2323          *               ----            Argument validated by caller.
   2324          *
   2325          * Return(s)   : Pointer to segment data, if successful.
   2326          *
   2327          *               DEF_NULL, otherwise.
   2328          *
   2329          * Caller(s)   : Mem_PoolCreate(),
   2330          *               Mem_SegCreate().
   2331          *
   2332          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2333          *********************************************************************************************************
   2334          */
   2335          

   \                                 In section .text, align 2, keep-with-next
   2336          static  void  Mem_SegCreateCritical(const  CPU_CHAR    *p_name,
   2337                                                     MEM_SEG     *p_seg,
   2338                                                     CPU_ADDR     seg_base_addr,
   2339                                                     CPU_SIZE_T   padding_align,
   2340                                                     CPU_SIZE_T   size)
   2341          {
   \                     Mem_SegCreateCritical: (+1)
   \   00000000   0x9800             LDR      R0,[SP, #+0]
   2342              p_seg->AddrBase         =  seg_base_addr;
   \   00000002   0x600A             STR      R2,[R1, #+0]
   2343              p_seg->AddrEnd          = (seg_base_addr + (size - 1u));
   \   00000004   0x1880             ADDS     R0,R0,R2
   \   00000006   0x1E40             SUBS     R0,R0,#+1
   \   00000008   0x6048             STR      R0,[R1, #+4]
   2344              p_seg->AddrNext         =  seg_base_addr;
   \   0000000A   0x608A             STR      R2,[R1, #+8]
   2345              p_seg->NextPtr          =  Mem_SegHeadPtr;
   \   0000000C   0x....             LDR.N    R0,??DataTable12
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x60C8             STR      R0,[R1, #+12]
   2346              p_seg->PaddingAlign     =  padding_align;
   \   00000012   0x610B             STR      R3,[R1, #+16]
   2347          
   2348          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2349              p_seg->NamePtr          = p_name;
   2350              p_seg->AllocInfoHeadPtr = DEF_NULL;
   2351          #else
   2352              (void)p_name;
   2353          #endif
   2354          
   2355              Mem_SegHeadPtr = p_seg;
   \   00000014   0x....             LDR.N    R0,??DataTable12
   \   00000016   0x6001             STR      R1,[R0, #+0]
   2356          }
   \   00000018   0x4770             BX       LR               ;; return
   2357          
   2358          
   2359          /*
   2360          *********************************************************************************************************
   2361          *                                      Mem_SegOverlapChkCritical()
   2362          *
   2363          * Description : Checks if existing memory segment exists or overlaps with specified memory area.
   2364          *
   2365          * Argument(s) : seg_base_addr   Address of first byte of memory area.
   2366          *
   2367          *               size            Size of memory area, in bytes.
   2368          *
   2369          *               p_err       Pointer to variable that will receive the return error code from this function :
   2370          *
   2371          *                               LIB_MEM_ERR_INVALID_SEG_OVERLAP     Segment overlaps another existing segment.
   2372          *                               LIB_MEM_ERR_INVALID_SEG_EXISTS      Segment already exists.
   2373          *
   2374          * Return(s)   : Pointer to memory segment that overlaps.
   2375          *
   2376          *               DEF_NULL, otherwise.
   2377          *
   2378          * Caller(s)   : Mem_PoolCreate(),
   2379          *               Mem_SegCreate().
   2380          *
   2381          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2382          *********************************************************************************************************
   2383          */
   2384          
   2385          #if  (LIB_MEM_CFG_HEAP_SIZE      >  0u)

   \                                 In section .text, align 2, keep-with-next
   2386          static  MEM_SEG  *Mem_SegOverlapChkCritical (CPU_ADDR     seg_base_addr,
   2387                                                       CPU_SIZE_T   size,
   2388                                                       LIB_ERR     *p_err)
   2389          {
   \                     Mem_SegOverlapChkCritical: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
   2390              MEM_SEG   *p_seg_chk;
   2391              CPU_ADDR   seg_new_end;
   2392              CPU_ADDR   seg_chk_start;
   2393              CPU_ADDR   seg_chk_end;
   2394          
   2395          
   2396              seg_new_end = seg_base_addr + (size - 1u);
   \   00000004   0x18C9             ADDS     R1,R1,R3
   \   00000006   0x1E49             SUBS     R1,R1,#+1
   2397              p_seg_chk   = Mem_SegHeadPtr;
   \   00000008   0x....             LDR.N    R0,??DataTable12
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0xE008             B.N      ??Mem_SegOverlapChkCritical_0
   2398          
   2399              while (p_seg_chk != DEF_NULL) {
   2400                  seg_chk_start = (CPU_ADDR)p_seg_chk->AddrBase;
   2401                  seg_chk_end   = (CPU_ADDR)p_seg_chk->AddrEnd;
   2402          
   2403                  if ((seg_base_addr == seg_chk_start) && (seg_new_end == seg_chk_end)) {
   2404                     *p_err = LIB_MEM_ERR_INVALID_SEG_EXISTS;
   2405                      return (p_seg_chk);
   2406                  } else if (((seg_base_addr >= seg_chk_start) && (seg_base_addr <= seg_chk_end)) ||
   2407                             ((seg_base_addr <= seg_chk_start) && (seg_new_end   >= seg_chk_start))) {
   \                     ??Mem_SegOverlapChkCritical_1: (+1)
   \   0000000E   0x42A3             CMP      R3,R4
   \   00000010   0xD301             BCC.N    ??Mem_SegOverlapChkCritical_2
   \   00000012   0x429D             CMP      R5,R3
   \   00000014   0xD210             BCS.N    ??Mem_SegOverlapChkCritical_3
   \                     ??Mem_SegOverlapChkCritical_2: (+1)
   \   00000016   0x429C             CMP      R4,R3
   \   00000018   0xD301             BCC.N    ??Mem_SegOverlapChkCritical_4
   \   0000001A   0x42A1             CMP      R1,R4
   \   0000001C   0xD20C             BCS.N    ??Mem_SegOverlapChkCritical_3
   2408                     *p_err = LIB_MEM_ERR_INVALID_SEG_OVERLAP;
   2409                      return (p_seg_chk);
   2410                  } else {
   2411                                                                          /* Empty Else Statement                                 */
   2412                  }
   2413          
   2414                  p_seg_chk = p_seg_chk->NextPtr;
   \                     ??Mem_SegOverlapChkCritical_4: (+1)
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \                     ??Mem_SegOverlapChkCritical_0: (+1)
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD00D             BEQ.N    ??Mem_SegOverlapChkCritical_5
   \   00000024   0x6804             LDR      R4,[R0, #+0]
   \   00000026   0x6845             LDR      R5,[R0, #+4]
   \   00000028   0x42A3             CMP      R3,R4
   \   0000002A   0xD1F0             BNE.N    ??Mem_SegOverlapChkCritical_1
   \   0000002C   0x42A9             CMP      R1,R5
   \   0000002E   0xD1EE             BNE.N    ??Mem_SegOverlapChkCritical_1
   \   00000030   0xF44F 0x511E      MOV      R1,#+10112
   \   00000034   0x8011             STRH     R1,[R2, #+0]
   \   00000036   0xE007             B.N      ??Mem_SegOverlapChkCritical_6
   \                     ??Mem_SegOverlapChkCritical_3: (+1)
   \   00000038   0xF242 0x717F      MOVW     R1,#+10111
   \   0000003C   0x8011             STRH     R1,[R2, #+0]
   \   0000003E   0xE003             B.N      ??Mem_SegOverlapChkCritical_6
   2415              }
   2416          
   2417             *p_err = LIB_MEM_ERR_NONE;
   \                     ??Mem_SegOverlapChkCritical_5: (+1)
   \   00000040   0xF242 0x7010      MOVW     R0,#+10000
   \   00000044   0x8010             STRH     R0,[R2, #+0]
   2418          
   2419              return (DEF_NULL);
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??Mem_SegOverlapChkCritical_6: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
   2420          }
   2421          #endif
   2422          
   2423          
   2424          /*
   2425          *********************************************************************************************************
   2426          *                                       Mem_SegAllocInternal()
   2427          *
   2428          * Description : Allocates memory from specified segment.
   2429          *
   2430          * Argument(s) : p_name  Pointer to allocated object name. Used for allocations tracking. May be DEF_NULL.
   2431          *
   2432          *               p_seg           Pointer to segment from which to allocate memory.
   2433          *               -----           Argument validated by caller.
   2434          *
   2435          *               size            Size of memory block to allocate, in bytes.
   2436          *
   2437          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2438          *
   2439          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
   2440          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2441          *                               means no padding.
   2442          *
   2443          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   2444          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   2445          *
   2446          *               p_err           Pointer to variable that will receive the return error code from this function :
   2447          *
   2448          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   2449          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   2450          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   2451          *
   2452          *                                   ------------------RETURNED BY Mem_SegAllocExtCritical()------------------
   2453          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   2454          *
   2455          * Return(s)   : Pointer to allocated memory block, if successful.
   2456          *
   2457          *               DEF_NULL, otherwise.
   2458          *
   2459          * Caller(s)   : Mem_DynPoolBlkGet(),
   2460          *               Mem_DynPoolCreateInternal(),
   2461          *               Mem_HeapAlloc(),
   2462          *               Mem_PoolCreate(),
   2463          *               Mem_SegAlloc(),
   2464          *               Mem_SegAllocExt(),
   2465          *               Mem_SegAllocHW().
   2466          *
   2467          * Note(s)     : none.
   2468          *********************************************************************************************************
   2469          */
   2470          

   \                                 In section .text, align 2, keep-with-next
   2471          static  void  *Mem_SegAllocInternal (const  CPU_CHAR    *p_name,
   2472                                                      MEM_SEG     *p_seg,
   2473                                                      CPU_SIZE_T   size,
   2474                                                      CPU_SIZE_T   align,
   2475                                                      CPU_SIZE_T   padding_align,
   2476                                                      CPU_SIZE_T  *p_bytes_reqd,
   2477                                                      LIB_ERR     *p_err)
   2478          {
   \                     Mem_SegAllocInternal: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0017             MOVS     R7,R2
   \   00000008   0x4698             MOV      R8,R3
   \   0000000A   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   \   0000000E   0xF8DD 0xA02C      LDR      R10,[SP, #+44]
   \   00000012   0x9C0C             LDR      R4,[SP, #+48]
   2479              void  *p_blk;
   2480              CPU_SR_ALLOC();
   \   00000014   0x2000             MOVS     R0,#+0
   2481          
   2482          
   2483          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2484              if (p_err == DEF_NULL) {                                    /* Chk for null err ptr.                                */
   2485                  CPU_SW_EXCEPTION(DEF_NULL);
   2486              }
   2487          
   2488              if (size < 1u) {                                            /* Chk for invalid sized mem req.                       */
   2489                 *p_err = LIB_MEM_ERR_INVALID_MEM_SIZE;
   2490                  return (DEF_NULL);
   2491              }
   2492          
   2493              if (MATH_IS_PWR2(align) != DEF_YES) {                       /* Chk that align is a pwr of 2.                        */
   2494                 *p_err = LIB_MEM_ERR_INVALID_MEM_ALIGN;
   2495                  return (DEF_NULL);
   2496              }
   2497          #endif
   2498          
   2499              CPU_CRITICAL_ENTER();
   \   00000016   0x2040             MOVS     R0,#+64
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x0005             MOVS     R5,R0
   2500              p_blk = Mem_SegAllocExtCritical(p_seg,
   2501                                              size,
   2502                                              align,
   2503                                              padding_align,
   2504                                              p_bytes_reqd,
   2505                                              p_err);
   \   0000001E   0x9401             STR      R4,[SP, #+4]
   \   00000020   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000024   0x464B             MOV      R3,R9
   \   00000026   0x4642             MOV      R2,R8
   \   00000028   0x0039             MOVS     R1,R7
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0x.... 0x....      BL       Mem_SegAllocExtCritical
   \   00000030   0x0006             MOVS     R6,R0
   2506              if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000032   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000036   0xF242 0x7110      MOVW     R1,#+10000
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD004             BEQ.N    ??Mem_SegAllocInternal_0
   2507                  CPU_CRITICAL_EXIT();
   \   0000003E   0x0028             MOVS     R0,R5
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
   2508                  return (DEF_NULL);
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE003             B.N      ??Mem_SegAllocInternal_1
   2509              }
   2510          
   2511          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)                    /* Track alloc if req'd.                                */
   2512              Mem_SegAllocTrackCritical(p_name,
   2513                                        p_seg,
   2514                                        size,
   2515                                        p_err);
   2516              if (*p_err != LIB_MEM_ERR_NONE) {
   2517                  CPU_CRITICAL_EXIT();
   2518                  return (DEF_NULL);
   2519              }
   2520          #else
   2521              (void)p_name;
   2522          #endif
   2523              CPU_CRITICAL_EXIT();
   \                     ??Mem_SegAllocInternal_0: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
   2524          
   2525              return (p_blk);
   \   0000004E   0x0030             MOVS     R0,R6
   \                     ??Mem_SegAllocInternal_1: (+1)
   \   00000050   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   2526          }
   2527          
   2528          
   2529          /*
   2530          *********************************************************************************************************
   2531          *                                      Mem_SegAllocExtCritical()
   2532          *
   2533          * Description : Allocates memory from specified segment.
   2534          *
   2535          * Argument(s) : p_seg           Pointer to segment from which to allocate memory.
   2536          *
   2537          *               size            Size of memory block to allocate, in bytes.
   2538          *
   2539          *               align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2540          *
   2541          *               padding_align   Padding alignment, in bytes, that will be added to any allocated buffer from
   2542          *                               this memory segment. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2543          *                               means no padding.
   2544          *
   2545          *               p_bytes_reqd    Pointer to variable that will receive the number of free bytes missing for
   2546          *                               the allocation to succeed. Set to DEF_NULL to skip calculation.
   2547          *
   2548          *               p_err           Pointer to variable that will receive the return error code from this function :
   2549          *
   2550          *                                   LIB_MEM_ERR_SEG_OVF     Allocation would overflow memory segment.
   2551          *
   2552          * Return(s)   : Pointer to allocated memory block, if successful.
   2553          *
   2554          *               DEF_NULL, otherwise.
   2555          *
   2556          * Caller(s)   : Mem_PoolCreate(),
   2557          *               Mem_SegAllocInternal(),
   2558          *               Mem_SegAllocTrackCritical().
   2559          *
   2560          * Note(s)     : (1) This function MUST be called within a CRITICAL_SECTION.
   2561          *********************************************************************************************************
   2562          */
   2563          

   \                                 In section .text, align 2, keep-with-next
   2564          static  void  *Mem_SegAllocExtCritical (MEM_SEG     *p_seg,
   2565                                                  CPU_SIZE_T   size,
   2566                                                  CPU_SIZE_T   align,
   2567                                                  CPU_SIZE_T   padding_align,
   2568                                                  CPU_SIZE_T  *p_bytes_reqd,
   2569                                                  LIB_ERR     *p_err)
   2570          {
   \                     Mem_SegAllocExtCritical: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0010             MOVS     R0,R2
   2571              CPU_ADDR    blk_addr;
   2572              CPU_ADDR    addr_next;
   2573              CPU_SIZE_T  size_rem_seg;
   2574              CPU_SIZE_T  size_tot_blk;
   2575              CPU_SIZE_T  blk_align = DEF_MAX(align, padding_align);
   \   00000006   0x4283             CMP      R3,R0
   \   00000008   0xD300             BCC.N    ??Mem_SegAllocExtCritical_0
   \                     ??Mem_SegAllocExtCritical_1: (+1)
   \   0000000A   0x0018             MOVS     R0,R3
   2576          
   2577          
   2578              blk_addr     = MATH_ROUND_INC_UP_PWR2(p_seg->AddrNext,      /* Compute align'ed blk addr.                           */
   2579                                                    blk_align);
   \                     ??Mem_SegAllocExtCritical_0: (+1)
   \   0000000C   0x68A2             LDR      R2,[R4, #+8]
   \   0000000E   0x1E45             SUBS     R5,R0,#+1
   \   00000010   0x422A             TST      R2,R5
   \   00000012   0xD101             BNE.N    ??Mem_SegAllocExtCritical_2
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xE000             B.N      ??Mem_SegAllocExtCritical_3
   \                     ??Mem_SegAllocExtCritical_2: (+1)
   \   00000018   0x0002             MOVS     R2,R0
   \                     ??Mem_SegAllocExtCritical_3: (+1)
   \   0000001A   0x68A5             LDR      R5,[R4, #+8]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0xEA35 0x0000      BICS     R0,R5,R0
   \   00000022   0x1810             ADDS     R0,R2,R0
   2580              addr_next    = MATH_ROUND_INC_UP_PWR2(blk_addr + size,      /* Compute addr of next alloc.                          */
   2581                                                    padding_align);
   \   00000024   0x180A             ADDS     R2,R1,R0
   \   00000026   0x1E5D             SUBS     R5,R3,#+1
   \   00000028   0x422A             TST      R2,R5
   \   0000002A   0xD101             BNE.N    ??Mem_SegAllocExtCritical_4
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0xE000             B.N      ??Mem_SegAllocExtCritical_5
   \                     ??Mem_SegAllocExtCritical_4: (+1)
   \   00000030   0x001D             MOVS     R5,R3
   \                     ??Mem_SegAllocExtCritical_5: (+1)
   \   00000032   0x9A03             LDR      R2,[SP, #+12]
   \   00000034   0x1809             ADDS     R1,R1,R0
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0x4399             BICS     R1,R1,R3
   \   0000003A   0x1869             ADDS     R1,R5,R1
   2582              size_rem_seg = (p_seg->AddrEnd - p_seg->AddrNext) + 1u;
   \   0000003C   0x6865             LDR      R5,[R4, #+4]
   \   0000003E   0x68A3             LDR      R3,[R4, #+8]
   \   00000040   0x1AEB             SUBS     R3,R5,R3
   \   00000042   0x1C5B             ADDS     R3,R3,#+1
   2583              size_tot_blk =  addr_next      - p_seg->AddrNext;           /* Compute tot blk size including align and padding.    */
   \   00000044   0x68A5             LDR      R5,[R4, #+8]
   \   00000046   0x1B4D             SUBS     R5,R1,R5
   2584              if (size_rem_seg < size_tot_blk) {                          /* If seg doesn't have enough space ...                 */
   \   00000048   0x42AB             CMP      R3,R5
   \   0000004A   0xD209             BCS.N    ??Mem_SegAllocExtCritical_6
   \   0000004C   0x9802             LDR      R0,[SP, #+8]
   2585                  if (p_bytes_reqd != DEF_NULL) {                         /* ... calc nbr of req'd bytes.                         */
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD001             BEQ.N    ??Mem_SegAllocExtCritical_7
   2586                     *p_bytes_reqd = size_tot_blk - size_rem_seg;
   \   00000052   0x1AEB             SUBS     R3,R5,R3
   \   00000054   0x6003             STR      R3,[R0, #+0]
   2587                  }
   2588          
   2589                 *p_err = LIB_MEM_ERR_SEG_OVF;
   \                     ??Mem_SegAllocExtCritical_7: (+1)
   \   00000056   0xF242 0x70D9      MOVW     R0,#+10201
   \   0000005A   0x8010             STRH     R0,[R2, #+0]
   2590                  return (DEF_NULL);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??Mem_SegAllocExtCritical_8
   2591              }
   2592          
   2593              p_seg->AddrNext = addr_next;
   \                     ??Mem_SegAllocExtCritical_6: (+1)
   \   00000060   0x60A1             STR      R1,[R4, #+8]
   2594          
   2595             *p_err = LIB_MEM_ERR_NONE;
   \   00000062   0xF242 0x7110      MOVW     R1,#+10000
   \   00000066   0x8011             STRH     R1,[R2, #+0]
   2596          
   2597              return ((void *)blk_addr);
   \                     ??Mem_SegAllocExtCritical_8: (+1)
   \   00000068   0xBC30             POP      {R4,R5}
   \   0000006A   0x4770             BX       LR               ;; return
   2598          }
   2599          
   2600          
   2601          /*
   2602          *********************************************************************************************************
   2603          *                                     Mem_SegAllocTrackCritical()
   2604          *
   2605          * Description : Tracks segment allocation, adding the 'size' of the allocation under the 'p_name' entry.
   2606          *
   2607          * Argument(s) : p_name  Pointer to the name of the object. This string is not copied and its memory should
   2608          *                       remain accessible at all times.
   2609          *
   2610          *               p_seg   Pointer to segment data.
   2611          *
   2612          *               size    Allocation size, in bytes.
   2613          *
   2614          *               p_err   Pointer to variable that will receive the return error code from this function :
   2615          *
   2616          *                           LIB_MEM_ERR_HEAP_EMPTY      No more memory available on heap
   2617          *
   2618          *                           --------------RETURNED BY Mem_SegAllocExtCritical()---------------
   2619          *                           LIB_MEM_ERR_SEG_OVF         Allocation would overflow memory segment.
   2620          *
   2621          * Return(s)   : none.
   2622          *
   2623          * Caller(s)   : Mem_PoolCreate(),
   2624          *               Mem_SegAllocInternal().
   2625          *
   2626          * Note(s)     : none.
   2627          *********************************************************************************************************
   2628          */
   2629          
   2630          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2631          static  void  Mem_SegAllocTrackCritical (const  CPU_CHAR    *p_name,
   2632                                                          MEM_SEG     *p_seg,
   2633                                                          CPU_SIZE_T   size,
   2634                                                          LIB_ERR     *p_err)
   2635          {
   2636              MEM_ALLOC_INFO  *p_alloc;
   2637          
   2638          
   2639                                                                          /* ------- UPDATE ALLOC INFO LIST, IF POSSIBLE -------- */
   2640              p_alloc = p_seg->AllocInfoHeadPtr;
   2641              while (p_alloc != DEF_NULL) {
   2642                  if (p_alloc->NamePtr == p_name) {
   2643                      p_alloc->Size += size;
   2644                     *p_err = LIB_MEM_ERR_NONE;
   2645                      return;
   2646                  }
   2647          
   2648                  p_alloc = p_alloc->NextPtr;
   2649              }
   2650          
   2651                                                                          /* --------- ADD NEW ALLOC INFO ENTRY IN LIST --------- */
   2652              p_alloc = (MEM_ALLOC_INFO *)Mem_SegAllocExtCritical(&Mem_SegHeap,             /* Alloc new alloc info struct on heap.                 */
   2653                                                                   sizeof(MEM_ALLOC_INFO),
   2654                                                                   sizeof(CPU_ALIGN),
   2655                                                                   LIB_MEM_PADDING_ALIGN_NONE,
   2656                                                                   DEF_NULL,
   2657                                                                   p_err);
   2658              if (*p_err != LIB_MEM_ERR_NONE) {
   2659                  return;
   2660              }
   2661          
   2662              p_alloc->NamePtr = p_name;                                  /* Populate alloc info.                                 */
   2663              p_alloc->Size    = size;
   2664          
   2665              p_alloc->NextPtr        = p_seg->AllocInfoHeadPtr;          /* Prepend new item in list.                            */
   2666              p_seg->AllocInfoHeadPtr = p_alloc;
   2667          }
   2668          #endif
   2669          
   2670          
   2671          /*
   2672          *********************************************************************************************************
   2673          *                                     Mem_DynPoolCreateInternal()
   2674          *
   2675          * Description : Creates a dynamic memory pool.
   2676          *
   2677          * Argument(s) : p_name              Pointer to pool name.
   2678          *
   2679          *               p_pool              Pointer to pool data.
   2680          *
   2681          *               p_seg               Pointer to segment from which to allocate memory.
   2682          *
   2683          *               blk_size            Size of memory block to allocate from pool, in bytes. See Note #1.
   2684          *
   2685          *               blk_align           Required alignment of memory block, in bytes. MUST be a power of 2.
   2686          *
   2687          *               blk_padding_align   Block's padding alignment, in bytes, that will be added at the end
   2688          *                                   of block's buffer. MUST be a power of 2. LIB_MEM_PADDING_ALIGN_NONE
   2689          *                                   means no padding.
   2690          *
   2691          *               blk_qty_init        Initial number of elements to be allocated in pool.
   2692          *
   2693          *               blk_qty_max         Maximum number of elements that can be allocated from this pool. Set to
   2694          *                                   LIB_MEM_BLK_QTY_UNLIMITED if no limit.
   2695          *
   2696          *               p_err           Pointer to variable that will receive the return error code from this function :
   2697          *
   2698          *                                   LIB_MEM_ERR_INVALID_BLK_ALIGN   Invalid requested block alignment.
   2699          *                                   LIB_MEM_ERR_INVALID_BLK_SIZE    Invalid requested block size.
   2700          *                                   LIB_MEM_ERR_INVALID_BLK_NBR     Invalid requested block quantity max.
   2701          *                                   LIB_MEM_ERR_NULL_PTR            Pool data pointer NULL.
   2702          *                                   LIB_MEM_ERR_ADDR_OVF            Memory allocation exceeds address space.
   2703          *
   2704          *                                   ------------------RETURNED BY Mem_SegAllocInternal()-------------------
   2705          *                                   LIB_MEM_ERR_INVALID_MEM_ALIGN   Invalid memory block alignment requested.
   2706          *                                   LIB_MEM_ERR_INVALID_MEM_SIZE    Invalid memory block size specified.
   2707          *                                   LIB_MEM_ERR_NULL_PTR            Error or segment data pointer NULL.
   2708          *                                   LIB_MEM_ERR_SEG_OVF             Allocation would overflow memory segment.
   2709          *
   2710          * Return(s)   : None.
   2711          *
   2712          * Caller(s)   : Mem_DynPoolCreate(),
   2713          *               Mem_DynPoolCreateHW().
   2714          *
   2715          * Note(s)     : (1) 'blk_size' must be big enough to fit a pointer since the pointer to the next free
   2716          *                   block is stored in the block itself (only when free/unused).
   2717          *********************************************************************************************************
   2718          */
   2719          

   \                                 In section .text, align 2, keep-with-next
   2720          static  void  Mem_DynPoolCreateInternal (const  CPU_CHAR      *p_name,
   2721                                                          MEM_DYN_POOL  *p_pool,
   2722                                                          MEM_SEG       *p_seg,
   2723                                                          CPU_SIZE_T     blk_size,
   2724                                                          CPU_SIZE_T     blk_align,
   2725                                                          CPU_SIZE_T     blk_padding_align,
   2726                                                          CPU_SIZE_T     blk_qty_init,
   2727                                                          CPU_SIZE_T     blk_qty_max,
   2728                                                          LIB_ERR       *p_err)
   2729          {
   \                     Mem_DynPoolCreateInternal: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0xF8DD 0xC030      LDR      R12,[SP, #+48]
   \   00000008   0xF8DD 0xA034      LDR      R10,[SP, #+52]
   2730              CPU_INT08U  *p_blks          = DEF_NULL;
   \   0000000C   0x2400             MOVS     R4,#+0
   2731              CPU_SIZE_T   seg_size;
   2732              CPU_SIZE_T   blk_size_align;
   2733              CPU_SIZE_T   blk_align_worst = DEF_MAX(blk_align, blk_padding_align);
   \   0000000E   0x45E2             CMP      R10,R12
   \   00000010   0xD201             BCS.N    ??Mem_DynPoolCreateInternal_0
   \   00000012   0x46E1             MOV      R9,R12
   \   00000014   0xE000             B.N      ??Mem_DynPoolCreateInternal_1
   \                     ??Mem_DynPoolCreateInternal_0: (+1)
   \   00000016   0x46D1             MOV      R9,R10
   \                     ??Mem_DynPoolCreateInternal_1: (+1)
   \   00000018   0x4698             MOV      R8,R3
   2734          
   2735          
   2736          #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
   2737              if (p_err == DEF_NULL) {                                    /* Chk for NULL err ptr.                                */
   2738                  CPU_SW_EXCEPTION(;);
   2739              }
   2740          
   2741              if (p_pool == DEF_NULL) {                                   /* Chk for NULL pool data ptr.                          */
   2742                 *p_err = LIB_MEM_ERR_NULL_PTR;
   2743                  return;
   2744              }
   2745          
   2746              if (blk_size < 1u) {                                        /* Chk for inv blk size.                                */
   2747                 *p_err = LIB_MEM_ERR_INVALID_BLK_SIZE;
   2748                  return;
   2749              }
   2750          
   2751              if ((blk_qty_max  != LIB_MEM_BLK_QTY_UNLIMITED) &&          /* Chk for invalid blk qty.                             */
   2752                  (blk_qty_init >  blk_qty_max)) {
   2753                 *p_err = LIB_MEM_ERR_INVALID_BLK_NBR;
   2754                  return;
   2755              }
   2756          
   2757              if (MATH_IS_PWR2(blk_align) != DEF_YES) {                   /* Chk for illegal align spec.                          */
   2758                 *p_err = LIB_MEM_ERR_INVALID_BLK_ALIGN;
   2759                  return;
   2760              }
   2761          #endif
   2762          
   2763                                                                          /* Calc blk size with align.                            */
   2764              if (blk_size < sizeof(void *)) {                            /* If size if smaller than ptr ...                      */
   \   0000001A   0xF1B8 0x0F04      CMP      R8,#+4
   \   0000001E   0xD20D             BCS.N    ??Mem_DynPoolCreateInternal_2
   2765                                                                          /* ... inc size to ptr size.                            */
   2766                  blk_size_align = MATH_ROUND_INC_UP_PWR2(sizeof(void *), blk_align_worst);
   \   00000020   0xF1B9 0x0301      SUBS     R3,R9,#+1
   \   00000024   0x075B             LSLS     R3,R3,#+29
   \   00000026   0xD401             BMI.N    ??Mem_DynPoolCreateInternal_3
   \   00000028   0x2300             MOVS     R3,#+0
   \   0000002A   0xE000             B.N      ??Mem_DynPoolCreateInternal_4
   \                     ??Mem_DynPoolCreateInternal_3: (+1)
   \   0000002C   0x464B             MOV      R3,R9
   \                     ??Mem_DynPoolCreateInternal_4: (+1)
   \   0000002E   0xF1B9 0x0701      SUBS     R7,R9,#+1
   \   00000032   0x43FF             MVNS     R7,R7
   \   00000034   0xF017 0x0704      ANDS     R7,R7,#0x4
   \   00000038   0x19DF             ADDS     R7,R3,R7
   \   0000003A   0xE00C             B.N      ??Mem_DynPoolCreateInternal_5
   2767              } else {
   2768                  blk_size_align = MATH_ROUND_INC_UP_PWR2(blk_size, blk_align_worst);
   \                     ??Mem_DynPoolCreateInternal_2: (+1)
   \   0000003C   0xF1B9 0x0301      SUBS     R3,R9,#+1
   \   00000040   0xEA18 0x0F03      TST      R8,R3
   \   00000044   0xD101             BNE.N    ??Mem_DynPoolCreateInternal_6
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0xE000             B.N      ??Mem_DynPoolCreateInternal_7
   \                     ??Mem_DynPoolCreateInternal_6: (+1)
   \   0000004A   0x464B             MOV      R3,R9
   \                     ??Mem_DynPoolCreateInternal_7: (+1)
   \   0000004C   0xF1B9 0x0701      SUBS     R7,R9,#+1
   \   00000050   0xEA38 0x0707      BICS     R7,R8,R7
   \   00000054   0x19DF             ADDS     R7,R3,R7
   \                     ??Mem_DynPoolCreateInternal_5: (+1)
   \   00000056   0x9E10             LDR      R6,[SP, #+64]
   \   00000058   0x9D0E             LDR      R5,[SP, #+56]
   \   0000005A   0x0014             MOVS     R4,R2
   \   0000005C   0x468B             MOV      R11,R1
   2769              }
   2770          
   2771              if (blk_qty_init != 0u) {                                   /* Alloc init blks.                                     */
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD02E             BEQ.N    ??Mem_DynPoolCreateInternal_8
   2772                  CPU_SIZE_T  i;
   2773          
   2774                  seg_size = blk_size_align * blk_qty_init;               /* Calc required size for pool.                         */
   \   00000062   0xFB05 0xF207      MUL      R2,R5,R7
   2775                                                                          /* Detect integer overflow in the seg_size calculation. */
   2776                  if (blk_size_align > (DEF_INT_CPU_U_MAX_VAL / blk_qty_init)) {
   \   00000066   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000006A   0xFBB1 0xF1F5      UDIV     R1,R1,R5
   \   0000006E   0x42B9             CMP      R1,R7
   \   00000070   0xD203             BCS.N    ??Mem_DynPoolCreateInternal_9
   2777                     *p_err = LIB_MEM_ERR_ADDR_OVF;
   \   00000072   0xF642 0x003C      MOVW     R0,#+10300
   \   00000076   0x8030             STRH     R0,[R6, #+0]
   2778                      return;
   \   00000078   0xE039             B.N      ??Mem_DynPoolCreateInternal_10
   2779                  }
   2780          
   2781                  p_blks = (CPU_INT08U *)Mem_SegAllocInternal(p_name,
   2782                                                              p_seg,
   2783                                                              seg_size,
   2784                                                              DEF_MAX(blk_align, sizeof(void *)),
   2785                                                              LIB_MEM_PADDING_ALIGN_NONE,
   2786                                                              DEF_NULL,
   2787                                                              p_err);
   \                     ??Mem_DynPoolCreateInternal_9: (+1)
   \   0000007A   0xF1BC 0x0F05      CMP      R12,#+5
   \   0000007E   0xD301             BCC.N    ??Mem_DynPoolCreateInternal_11
   \   00000080   0x4663             MOV      R3,R12
   \   00000082   0xE000             B.N      ??Mem_DynPoolCreateInternal_12
   \                     ??Mem_DynPoolCreateInternal_11: (+1)
   \   00000084   0x2304             MOVS     R3,#+4
   \                     ??Mem_DynPoolCreateInternal_12: (+1)
   \   00000086   0x9602             STR      R6,[SP, #+8]
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x9101             STR      R1,[SP, #+4]
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x9100             STR      R1,[SP, #+0]
   \   00000090   0x0021             MOVS     R1,R4
   \   00000092   0x.... 0x....      BL       Mem_SegAllocInternal
   2788                  if (*p_err != LIB_MEM_ERR_NONE) {
   \   00000096   0xF9B6 0x1000      LDRSH    R1,[R6, #+0]
   \   0000009A   0xF242 0x7210      MOVW     R2,#+10000
   \   0000009E   0x4291             CMP      R1,R2
   \   000000A0   0xD125             BNE.N    ??Mem_DynPoolCreateInternal_10
   2789                      return;
   2790                  }
   2791          
   2792                                                                          /* ----------------- CREATE POOL DATA ----------------- */
   2793                                                                          /* Init free list.                                      */
   2794                  p_pool->BlkFreePtr = (void *)p_blks;
   \                     ??Mem_DynPoolCreateInternal_13: (+1)
   \   000000A2   0xF8CB 0x0010      STR      R0,[R11, #+16]
   2795                  for (i = 0u; i < blk_qty_init - 1u; i++) {
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0xE004             B.N      ??Mem_DynPoolCreateInternal_14
   2796                     *((void **)p_blks)  = p_blks + blk_size_align;
   \                     ??Mem_DynPoolCreateInternal_15: (+1)
   \   000000AA   0xEB00 0x0207      ADD      R2,R0,R7
   \   000000AE   0x6002             STR      R2,[R0, #+0]
   2797                      p_blks            += blk_size_align;
   \   000000B0   0x4438             ADD      R0,R0,R7
   2798                  }
   \   000000B2   0x1C49             ADDS     R1,R1,#+1
   \                     ??Mem_DynPoolCreateInternal_14: (+1)
   \   000000B4   0x1E6A             SUBS     R2,R5,#+1
   \   000000B6   0x4291             CMP      R1,R2
   \   000000B8   0xD3F7             BCC.N    ??Mem_DynPoolCreateInternal_15
   2799                 *((void **)p_blks) = DEF_NULL;
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0x6001             STR      R1,[R0, #+0]
   \   000000BE   0xE002             B.N      ??Mem_DynPoolCreateInternal_16
   2800              } else {
   2801                  p_pool->BlkFreePtr = DEF_NULL;
   \                     ??Mem_DynPoolCreateInternal_8: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF8CB 0x0010      STR      R0,[R11, #+16]
   2802              }
   2803          
   2804          #if (LIB_MEM_CFG_HEAP_SIZE > 0u)
   2805              p_pool->PoolSegPtr      = ((p_seg != DEF_NULL) ? p_seg : &Mem_SegHeap);
   \                     ??Mem_DynPoolCreateInternal_16: (+1)
   \   000000C6   0x2C00             CMP      R4,#+0
   \   000000C8   0xD100             BNE.N    ??Mem_DynPoolCreateInternal_17
   \                     ??Mem_DynPoolCreateInternal_18: (+1)
   \   000000CA   0x....             LDR.N    R4,??DataTable12_2
   \                     ??Mem_DynPoolCreateInternal_17: (+1)
   \   000000CC   0x980F             LDR      R0,[SP, #+60]
   \   000000CE   0xF8CB 0x4000      STR      R4,[R11, #+0]
   2806          #else
   2807              p_pool->PoolSegPtr      =   p_seg;
   2808          #endif
   2809              p_pool->BlkSize         =   blk_size;
   \   000000D2   0xF8CB 0x8004      STR      R8,[R11, #+4]
   2810              p_pool->BlkAlign        =   blk_align_worst;
   \   000000D6   0xF8CB 0x9008      STR      R9,[R11, #+8]
   2811              p_pool->BlkPaddingAlign =   blk_padding_align;
   \   000000DA   0xF8CB 0xA00C      STR      R10,[R11, #+12]
   2812              p_pool->BlkQtyMax       =   blk_qty_max;
   \   000000DE   0xF8CB 0x0014      STR      R0,[R11, #+20]
   2813              p_pool->BlkAllocCnt     =   0u;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0xF8CB 0x0018      STR      R0,[R11, #+24]
   2814          
   2815          #if (LIB_MEM_CFG_DBG_INFO_EN == DEF_ENABLED)
   2816              p_pool->NamePtr = p_name;
   2817          #endif
   2818          
   2819             *p_err = LIB_MEM_ERR_NONE;
   \   000000E8   0xF242 0x7010      MOVW     R0,#+10000
   \   000000EC   0x8030             STRH     R0,[R6, #+0]
   2820          }
   \                     ??Mem_DynPoolCreateInternal_10: (+1)
   \   000000EE   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     Mem_SegHeadPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     Mem_Heap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     Mem_SegHeap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x48 0x65          DC8 "Heap"
   \              0x61 0x70    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x55 0x6E          DC8 "Unnamed static pool"
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x69 0x63    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x55 0x6E          DC8 "Unnamed static pool free blk tbl"
   \              0x6E 0x61    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x73 0x74    
   \              0x61 0x74    
   \              0x69 0x63    
   \              0x20 0x70    
   \              0x6F 0x6F    
   \              0x6C 0x20    
   \              0x66 0x72    
   \              0x65 0x65    
   \              0x20 0x62    
   \              0x6C 0x6B    
   \              0x20 0x74    
   \              0x62 0x6C    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   2821          
   2822          
   2823          /*
   2824          *********************************************************************************************************
   2825          *                                      Mem_PoolBlkIsValidAddr()
   2826          *
   2827          * Description : Calculates if a given memory block address is valid for the memory pool.
   2828          *
   2829          * Argument(s) : p_pool   Pointer to memory pool structure to validate memory block address.
   2830          *               ------   Argument validated by caller.
   2831          *
   2832          *               p_mem    Pointer to memory block address to validate.
   2833          *               -----    Argument validated by caller.
   2834          *
   2835          * Return(s)   : DEF_YES, if valid memory pool block address.
   2836          *
   2837          *               DEF_NO,  otherwise.
   2838          *
   2839          * Caller(s)   : Mem_PoolBlkFree().
   2840          *
   2841          * Note(s)     : (1) This function is DEPRECATED and will be removed in a future version of this product.
   2842          *********************************************************************************************************
   2843          */
   2844          
   2845          #if ((LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED) && \
   2846               (LIB_MEM_CFG_HEAP_SIZE      >  0u))
   2847          static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *p_pool,
   2848                                                       void      *p_mem)
   2849          {
   2850              CPU_ADDR  pool_offset;
   2851          
   2852          
   2853              if ((p_mem < p_pool->PoolAddrStart) ||
   2854                  (p_mem > p_pool->PoolAddrEnd)) {
   2855                  return (DEF_FALSE);
   2856              }
   2857          
   2858              pool_offset = (CPU_ADDR)p_mem - (CPU_ADDR)p_pool->PoolAddrStart;
   2859              if (pool_offset % p_pool->BlkSize != 0u) {
   2860                  return (DEF_FALSE);
   2861              } else {
   2862                  return (DEF_TRUE);
   2863              }
   2864          }
   2865          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   Mem_Clr
         8   -> Mem_Set
      12   Mem_Cmp
       4   Mem_Copy
      16   Mem_DynPoolBlkFree
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      32   Mem_DynPoolBlkGet
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> Mem_SegAllocInternal
      16   Mem_DynPoolBlkNbrAvailGet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      40   Mem_DynPoolCreate
        40   -> Mem_DynPoolCreateInternal
      40   Mem_DynPoolCreateHW
        40   -> Mem_DynPoolCreateInternal
      48   Mem_DynPoolCreateInternal
        48   -> Mem_SegAllocInternal
      24   Mem_HeapAlloc
        24   -> Mem_SegAllocInternal
       8   Mem_HeapGetSizeRem
         8   -> Mem_SegRemSizeGet
      16   Mem_Init
        16   -> CPU_SW_Exception
        16   -> Mem_SegCreate
       8   Mem_Move
         8   -> Mem_Copy
      16   Mem_PoolBlkFree
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   Mem_PoolBlkGet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   Mem_PoolBlkGetNbrAvail
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
       0   Mem_PoolClr
      48   Mem_PoolCreate
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> Mem_PoolClr
        48   -> Mem_SegAllocExtCritical
        48   -> Mem_SegAllocInternal
        48   -> Mem_SegCreateCritical
        48   -> Mem_SegOverlapChkCritical
      16   Mem_SegAlloc
        16   -> Mem_SegAllocInternal
      24   Mem_SegAllocExt
        24   -> Mem_SegAllocInternal
       8   Mem_SegAllocExtCritical
      24   Mem_SegAllocHW
        24   -> Mem_SegAllocInternal
      40   Mem_SegAllocInternal
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> Mem_SegAllocExtCritical
      16   Mem_SegClr
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      40   Mem_SegCreate
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> Mem_SegCreateCritical
       0   Mem_SegCreateCritical
       8   Mem_SegOverlapChkCritical
      24   Mem_SegRemSizeGet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       8   Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       8  ?_0
      20  ?_1
      36  ?_2
      12  Mem_Clr
     174  Mem_Cmp
      94  Mem_Copy
      74  Mem_DynPoolBlkFree
     142  Mem_DynPoolBlkGet
      50  Mem_DynPoolBlkNbrAvailGet
      40  Mem_DynPoolCreate
      40  Mem_DynPoolCreateHW
     242  Mem_DynPoolCreateInternal
    1024  Mem_Heap
      48  Mem_HeapAlloc
      36  Mem_HeapGetSizeRem
      56  Mem_Init
     124  Mem_Move
      62  Mem_PoolBlkFree
      72  Mem_PoolBlkGet
      30  Mem_PoolBlkGetNbrAvail
      32  Mem_PoolClr
     340  Mem_PoolCreate
      28  Mem_SegAlloc
      28  Mem_SegAllocExt
     108  Mem_SegAllocExtCritical
      28  Mem_SegAllocHW
      84  Mem_SegAllocInternal
      30  Mem_SegClr
      60  Mem_SegCreate
      26  Mem_SegCreateCritical
       4  Mem_SegHeadPtr
      20  Mem_SegHeap
      76  Mem_SegOverlapChkCritical
     108  Mem_SegRemSizeGet
      76  Mem_Set

 
 1 048 bytes in section .bss
    64 bytes in section .rodata
 2 344 bytes in section .text
 
 2 344 bytes of CODE  memory
    64 bytes of CONST memory
 1 048 bytes of DATA  memory

Errors: none
Warnings: none
