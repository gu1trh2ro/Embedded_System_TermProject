###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_flag.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3A3D.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_flag.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_flag.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_flag.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_flag.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                         EVENT FLAG MANAGEMENT
     20          *
     21          * File    : os_flag.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_flag__c = "$Id: $";
     31          #endif
     32          
     33          
     34          #if (OS_CFG_FLAG_EN > 0u)
     35          
     36          /*
     37          ************************************************************************************************************************
     38          *                                                 CREATE AN EVENT FLAG
     39          *
     40          * Description: This function is called to create an event flag group.
     41          *
     42          * Arguments  : p_grp          is a pointer to the event flag group to create
     43          *
     44          *              p_name         is the name of the event flag group
     45          *
     46          *              flags          contains the initial value to store in the event flag group (typically 0).
     47          *
     48          *              p_err          is a pointer to an error code which will be returned to your application:
     49          *
     50          *                                 OS_ERR_NONE                    If the call was successful
     51          *                                 OS_ERR_CREATE_ISR              If you attempted to create an Event Flag from an ISR
     52          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the Event Flag after you
     53          *                                                                   called OSSafetyCriticalStart().
     54          *                                 OS_ERR_OBJ_PTR_NULL            If 'p_grp' is a NULL pointer
     55          *                                 OS_ERR_OBJ_CREATED             If the event flag was already created
     56          *
     57          * Returns    : none
     58          ************************************************************************************************************************
     59          */
     60          

   \                                 In section .text, align 2, keep-with-next
     61          void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
     62                              CPU_CHAR     *p_name,
     63                              OS_FLAGS      flags,
     64                              OS_ERR       *p_err)
     65          {
   \                     OSFlagCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
     66              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
     67          
     68          
     69          #ifdef OS_SAFETY_CRITICAL
     70              if (p_err == (OS_ERR *)0) {
     71                  OS_SAFETY_CRITICAL_EXCEPTION();
     72                  return;
     73              }
     74          #endif
     75          
     76          #ifdef OS_SAFETY_CRITICAL_IEC61508
     77              if (OSSafetyCriticalStartFlag == OS_TRUE) {
     78                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
     79                  return;
     80              }
     81          #endif
     82          
     83          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
     84              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable7
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSFlagCreate_0
     85                 *p_err = OS_ERR_CREATE_ISR;                              /* ... can't CREATE from an ISR                         */
   \   00000014   0xF642 0x60E1      MOVW     R0,#+12001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
     86                  return;
   \   0000001A   0xE021             B.N      ??OSFlagCreate_1
     87              }
     88          #endif
     89          
     90          #if (OS_CFG_ARG_CHK_EN > 0u)
     91              if (p_grp == (OS_FLAG_GRP *)0) {                            /* Validate 'p_grp'                                     */
   \                     ??OSFlagCreate_0: (+1)
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD103             BNE.N    ??OSFlagCreate_2
     92                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000020   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000024   0x8028             STRH     R0,[R5, #+0]
     93                  return;
   \   00000026   0xE01B             B.N      ??OSFlagCreate_1
     94              }
     95          #endif
     96          
     97              CPU_CRITICAL_ENTER();
   \                     ??OSFlagCreate_2: (+1)
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x.... 0x....      BL       CPU_SR_Save
   \   0000002E   0x0007             MOVS     R7,R0
     98          #if (OS_OBJ_TYPE_REQ > 0u)
     99          #if (OS_CFG_OBJ_CREATED_CHK_EN > 0u)
    100              if (p_grp->Type == OS_OBJ_TYPE_FLAG) {
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x47414c46
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD106             BNE.N    ??OSFlagCreate_3
    101                  CPU_CRITICAL_EXIT();
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       CPU_SR_Restore
    102                  *p_err = OS_ERR_OBJ_CREATED;
   \   00000040   0xF645 0x50C1      MOVW     R0,#+24001
   \   00000044   0x8028             STRH     R0,[R5, #+0]
    103                  return;
   \   00000046   0xE00B             B.N      ??OSFlagCreate_1
    104              }
    105          #endif
    106              p_grp->Type    = OS_OBJ_TYPE_FLAG;                          /* Set to event flag group type                         */
   \                     ??OSFlagCreate_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable7_1  ;; 0x47414c46
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    107          #endif
    108          #if (OS_CFG_DBG_EN > 0u)
    109              p_grp->NamePtr = p_name;
    110          #else
    111              (void)p_name;
    112          #endif
    113              p_grp->Flags   = flags;                                     /* Set to desired initial value                         */
   \   0000004E   0x60E6             STR      R6,[R4, #+12]
    114          #if (OS_CFG_TS_EN > 0u)
    115              p_grp->TS      = 0u;
    116          #endif
    117              OS_PendListInit(&p_grp->PendList);
   \   00000050   0x1D20             ADDS     R0,R4,#+4
   \   00000052   0x.... 0x....      BL       OS_PendListInit
    118          
    119          #if (OS_CFG_DBG_EN > 0u)
    120              OS_FlagDbgListAdd(p_grp);
    121              OSFlagQty++;
    122          #endif
    123          
    124              OS_TRACE_FLAG_CREATE(p_grp, p_name);
    125          
    126              CPU_CRITICAL_EXIT();
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    127             *p_err = OS_ERR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8028             STRH     R0,[R5, #+0]
    128          }
   \                     ??OSFlagCreate_1: (+1)
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    129          
    130          
    131          /*
    132          ************************************************************************************************************************
    133          *                                             DELETE AN EVENT FLAG GROUP
    134          *
    135          * Description: This function deletes an event flag group and readies all tasks pending on the event flag group.
    136          *
    137          * Arguments  : p_grp     is a pointer to the desired event flag group.
    138          *
    139          *              opt       determines delete options as follows:
    140          *
    141          *                            OS_OPT_DEL_NO_PEND           Deletes the event flag group ONLY if no task pending
    142          *                            OS_OPT_DEL_ALWAYS            Deletes the event flag group even if tasks are waiting.
    143          *                                                         In this case, all the tasks pending will be readied.
    144          *
    145          *              p_err     is a pointer to an error code that can contain one of the following values:
    146          *
    147          *                            OS_ERR_NONE                    The call was successful and the event flag group was deleted
    148          *                            OS_ERR_DEL_ISR                 If you attempted to delete the event flag group from an ISR
    149          *                            OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the event flag group after you
    150          *                                                             called OSStart()
    151          *                            OS_ERR_OBJ_PTR_NULL            If 'p_grp' is a NULL pointer
    152          *                            OS_ERR_OBJ_TYPE                If you didn't pass a pointer to an event flag group
    153          *                            OS_ERR_OPT_INVALID             An invalid option was specified
    154          *                            OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    155          *                            OS_ERR_TASK_WAITING            One or more tasks were waiting on the event flag group
    156          *
    157          * Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
    158          *              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
    159          *
    160          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of the event flag
    161          *                 group MUST check the return code of OSFlagPost and OSFlagPend().
    162          ************************************************************************************************************************
    163          */
    164          
    165          #if (OS_CFG_FLAG_DEL_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    166          OS_OBJ_QTY  OSFlagDel (OS_FLAG_GRP  *p_grp,
    167                                 OS_OPT        opt,
    168                                 OS_ERR       *p_err)
    169          {
   \                     OSFlagDel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0015             MOVS     R5,R2
    170              OS_OBJ_QTY     nbr_tasks;
    171              OS_PEND_LIST  *p_pend_list;
    172              OS_TCB        *p_tcb;
    173              CPU_TS         ts;
    174              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    175          
    176          
    177          #ifdef OS_SAFETY_CRITICAL
    178              if (p_err == (OS_ERR *)0) {
    179                  OS_SAFETY_CRITICAL_EXCEPTION();
    180                  return (0u);
    181              }
    182          #endif
    183          
    184              OS_TRACE_FLAG_DEL_ENTER(p_grp, opt);
    185          
    186          #ifdef OS_SAFETY_CRITICAL_IEC61508
    187              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    188                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_ILLEGAL_DEL_RUN_TIME);
    189                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    190                  return (0u);
    191              }
    192          #endif
    193          
    194          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    195              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD004             BEQ.N    ??OSFlagDel_0
    196                 *p_err = OS_ERR_DEL_ISR;                                 /* ... can't DELETE from an ISR                         */
   \   00000016   0xF243 0x20C9      MOVW     R0,#+13001
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    197                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_DEL_ISR);
    198                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE05F             B.N      ??OSFlagDel_1
    199              }
    200          #endif
    201          
    202          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    203              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSFlagDel_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable7_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD004             BEQ.N    ??OSFlagDel_2
    204                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_OS_NOT_RUNNING);
    205                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002A   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
    206                  return (0u);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE055             B.N      ??OSFlagDel_1
    207              }
    208          #endif
    209          
    210          #if (OS_CFG_ARG_CHK_EN > 0u)
    211              if (p_grp == (OS_FLAG_GRP *)0) {                            /* Validate 'p_grp'                                     */
   \                     ??OSFlagDel_2: (+1)
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD104             BNE.N    ??OSFlagDel_3
    212                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_OBJ_PTR_NULL);
    213                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000038   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000003C   0x8028             STRH     R0,[R5, #+0]
    214                  return (0u);
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE04E             B.N      ??OSFlagDel_1
    215              }
    216          #endif
    217          
    218          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    219              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate event group object                          */
   \                     ??OSFlagDel_3: (+1)
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable7_1  ;; 0x47414c46
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD004             BEQ.N    ??OSFlagDel_4
    220                  OS_TRACE_FLAG_DEL_EXIT(OS_ERR_OBJ_TYPE);
    221                 *p_err = OS_ERR_OBJ_TYPE;
   \   0000004C   0xF645 0x50C4      MOVW     R0,#+24004
   \   00000050   0x8028             STRH     R0,[R5, #+0]
    222                  return (0u);
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE044             B.N      ??OSFlagDel_1
    223              }
    224          #endif
    225              CPU_CRITICAL_ENTER();
   \                     ??OSFlagDel_4: (+1)
   \   00000056   0x2040             MOVS     R0,#+64
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
   \   0000005C   0x0007             MOVS     R7,R0
    226              p_pend_list = &p_grp->PendList;
   \   0000005E   0xF114 0x0804      ADDS     R8,R4,#+4
    227              nbr_tasks   = 0u;
   \   00000062   0x2600             MOVS     R6,#+0
    228              switch (opt) {
   \   00000064   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000068   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000006C   0xD003             BEQ.N    ??OSFlagDel_5
   \   0000006E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000072   0xD014             BEQ.N    ??OSFlagDel_6
   \   00000074   0xE02C             B.N      ??OSFlagDel_7
    229                  case OS_OPT_DEL_NO_PEND:                                /* Delete group if no task waiting                      */
    230                       if (p_pend_list->HeadPtr == (OS_TCB *)0) {
   \                     ??OSFlagDel_5: (+1)
   \   00000076   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD108             BNE.N    ??OSFlagDel_8
    231          #if (OS_CFG_DBG_EN > 0u)
    232                           OS_FlagDbgListRemove(p_grp);
    233                           OSFlagQty--;
    234          #endif
    235                           OS_TRACE_FLAG_DEL(p_grp);
    236                           OS_FlagClr(p_grp);
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       OS_FlagClr
    237          
    238                           CPU_CRITICAL_EXIT();
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    239          
    240                          *p_err = OS_ERR_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x8028             STRH     R0,[R5, #+0]
   \   0000008E   0xE005             B.N      ??OSFlagDel_9
    241                       } else {
    242                           CPU_CRITICAL_EXIT();
   \                     ??OSFlagDel_8: (+1)
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
    243                          *p_err = OS_ERR_TASK_WAITING;
   \   00000096   0xF247 0x105F      MOVW     R0,#+29023
   \   0000009A   0x8028             STRH     R0,[R5, #+0]
    244                       }
    245                       break;
   \                     ??OSFlagDel_9: (+1)
   \   0000009C   0xE01E             B.N      ??OSFlagDel_10
    246          
    247                  case OS_OPT_DEL_ALWAYS:                                 /* Always delete the event flag group                   */
    248          #if (OS_CFG_TS_EN > 0u)
    249                       ts = OS_TS_GET();                                  /* Get local time stamp so all tasks get the same time  */
    250          #else
    251                       ts = 0u;
   \                     ??OSFlagDel_6: (+1)
   \   0000009E   0xF05F 0x0900      MOVS     R9,#+0
   \   000000A2   0xE006             B.N      ??OSFlagDel_11
    252          #endif
    253                       while (p_pend_list->HeadPtr != (OS_TCB *)0) {      /* Remove all tasks from the pend list                  */
    254                           p_tcb = p_pend_list->HeadPtr;
   \                     ??OSFlagDel_12: (+1)
   \   000000A4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
    255                           OS_PendAbort(p_tcb,
    256                                        ts,
    257                                        OS_STATUS_PEND_DEL);
   \   000000A8   0x2202             MOVS     R2,#+2
   \   000000AA   0x4649             MOV      R1,R9
   \   000000AC   0x.... 0x....      BL       OS_PendAbort
    258                           nbr_tasks++;
   \   000000B0   0x1C76             ADDS     R6,R6,#+1
    259                       }
   \                     ??OSFlagDel_11: (+1)
   \   000000B2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD1F4             BNE.N    ??OSFlagDel_12
    260          #if (OS_CFG_DBG_EN > 0u)
    261                       OS_FlagDbgListRemove(p_grp);
    262                       OSFlagQty--;
    263          #endif
    264                       OS_TRACE_FLAG_DEL(p_grp);
    265          
    266                       OS_FlagClr(p_grp);
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       OS_FlagClr
    267                       CPU_CRITICAL_EXIT();
   \   000000C0   0x0038             MOVS     R0,R7
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    268          
    269                       OSSched();                                         /* Find highest priority task ready to run              */
   \   000000C6   0x.... 0x....      BL       OSSched
    270                      *p_err = OS_ERR_NONE;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    271                       break;
   \   000000CE   0xE005             B.N      ??OSFlagDel_10
    272          
    273                  default:
    274                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagDel_7: (+1)
   \   000000D0   0x0038             MOVS     R0,R7
   \   000000D2   0x.... 0x....      BL       CPU_SR_Restore
    275                      *p_err = OS_ERR_OPT_INVALID;
   \   000000D6   0xF645 0x6025      MOVW     R0,#+24101
   \   000000DA   0x8028             STRH     R0,[R5, #+0]
    276                       break;
    277              }
    278          
    279              OS_TRACE_FLAG_DEL_EXIT(*p_err);
    280          
    281              return (nbr_tasks);
   \                     ??OSFlagDel_10: (+1)
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagDel_1: (+1)
   \   000000E0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    282          }
    283          #endif
    284          
    285          
    286          /*
    287          ************************************************************************************************************************
    288          *                                             WAIT ON AN EVENT FLAG GROUP
    289          *
    290          * Description: This function is called to wait for a combination of bits to be set in an event flag group.  Your
    291          *              application can wait for ANY bit to be set or ALL bits to be set.
    292          *
    293          * Arguments  : p_grp         is a pointer to the desired event flag group.
    294          *
    295          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    296          *                            The bits you want are specified by setting the corresponding bits in 'flags'.
    297          *                            e.g. if your application wants to wait for bits 0 and 1 then 'flags' would contain 0x03.
    298          *
    299          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    300          *                            desired bit combination.  If you specify 0, however, your task will wait
    301          *                            forever at the specified event flag group or, until a message arrives.
    302          *
    303          *              opt           specifies whether you want ALL bits to be set or ANY of the bits to be set.
    304          *                            You can specify the 'ONE' of the following arguments:
    305          *
    306          *                                OS_OPT_PEND_FLAG_CLR_ALL   You will wait for ALL bits in 'flags' to be clear (0)
    307          *                                OS_OPT_PEND_FLAG_CLR_ANY   You will wait for ANY bit  in 'flags' to be clear (0)
    308          *                                OS_OPT_PEND_FLAG_SET_ALL   You will wait for ALL bits in 'flags' to be set   (1)
    309          *                                OS_OPT_PEND_FLAG_SET_ANY   You will wait for ANY bit  in 'flags' to be set   (1)
    310          *
    311          *                            You can 'ADD' OS_OPT_PEND_FLAG_CONSUME if you want the event flag to be 'consumed' by
    312          *                                      the call.  Example, to wait for any flag in a group AND then clear
    313          *                                      the flags that are present, set 'wait_opt' to:
    314          *
    315          *                                      OS_OPT_PEND_FLAG_SET_ANY + OS_OPT_PEND_FLAG_CONSUME
    316          *
    317          *                            You can also 'ADD' the type of pend with 'ONE' of the two option:
    318          *
    319          *                                OS_OPT_PEND_NON_BLOCKING   Task will NOT block if flags are not available
    320          *                                OS_OPT_PEND_BLOCKING       Task will     block if flags are not available
    321          *
    322          *              p_ts          is a pointer to a variable that will receive the timestamp of when the event flag group was
    323          *                            posted, aborted or the event flag group deleted.  If you pass a NULL pointer (i.e. (CPU_TS *)0)
    324          *                            then you will not get the timestamp.  In other words, passing a NULL pointer is valid and
    325          *                            indicates that you don't need the timestamp.
    326          *
    327          *              p_err         is a pointer to an error code and can be:
    328          *
    329          *                                OS_ERR_NONE                The desired bits have been set within the specified 'timeout'
    330          *                                OS_ERR_OBJ_DEL             If the event group was deleted
    331          *                                OS_ERR_OBJ_PTR_NULL        If 'p_grp' is a NULL pointer.
    332          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
    333          *                                OS_ERR_OPT_INVALID         You didn't specify a proper 'opt' argument
    334          *                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    335          *                                OS_ERR_PEND_ABORT          The wait on the flag was aborted
    336          *                                OS_ERR_PEND_ISR            If you tried to PEND from an ISR
    337          *                                OS_ERR_PEND_WOULD_BLOCK    If you specified non-blocking but the flags were not
    338          *                                                           available
    339          *                                OS_ERR_SCHED_LOCKED        If you called this function when the scheduler is locked
    340          *                                OS_ERR_STATUS_INVALID      If the pend status has an invalid value
    341          *                                OS_ERR_TIMEOUT             The bit(s) have not been set in the specified 'timeout'
    342          *                                OS_ERR_TICK_DISABLED       If kernel ticks are disabled and a timeout is specified
    343          *
    344          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    345          *              occurred.
    346          *
    347          * Note(s)    : This API 'MUST NOT' be called from a timer callback function.
    348          ************************************************************************************************************************
    349          */
    350          

   \                                 In section .text, align 2, keep-with-next
    351          OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
    352                                OS_FLAGS      flags,
    353                                OS_TICK       timeout,
    354                                OS_OPT        opt,
    355                                CPU_TS       *p_ts,
    356                                OS_ERR       *p_err)
    357          {
   \                     OSFlagPend: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x001F             MOVS     R7,R3
   \   00000006   0xF8DD 0x802C      LDR      R8,[SP, #+44]
    358              CPU_BOOLEAN  consume;
    359              OS_FLAGS     flags_rdy;
    360              OS_OPT       mode;
    361              CPU_SR_ALLOC();
   \   0000000A   0x2300             MOVS     R3,#+0
    362          
    363          
    364          #ifdef OS_SAFETY_CRITICAL
    365              if (p_err == (OS_ERR *)0) {
    366                  OS_SAFETY_CRITICAL_EXCEPTION();
    367                  return (0u);
    368              }
    369          #endif
    370          
    371              OS_TRACE_FLAG_PEND_ENTER(p_grp, flags, timeout, opt, p_ts);
    372          
    373          #if (OS_CFG_TICK_EN == 0u)
    374              if (timeout != 0u) {
    375                 *p_err = OS_ERR_TICK_DISABLED;
    376                  OS_TRACE_FLAG_PEND_FAILED(p_grp);
    377                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_TICK_DISABLED);
    378                  return ((OS_FLAGS)0);
    379              }
    380          #endif
    381          
    382          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    383              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable7
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD009             BEQ.N    ??OSFlagPend_0
    384                  if ((opt & OS_OPT_PEND_NON_BLOCKING) != OS_OPT_PEND_NON_BLOCKING) {
   \   00000016   0x003B             MOVS     R3,R7
   \   00000018   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000001A   0x041B             LSLS     R3,R3,#+16
   \   0000001C   0xD405             BMI.N    ??OSFlagPend_0
    385                     *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                           */
   \   0000001E   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000022   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    386                      OS_TRACE_FLAG_PEND_FAILED(p_grp);
    387                      OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_ISR);
    388                      return ((OS_FLAGS)0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE1CF             B.N      ??OSFlagPend_1
    389                  }
    390              }
    391          #endif
    392          
    393          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    394              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSFlagPend_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable7_2
   \   0000002E   0x781B             LDRB     R3,[R3, #+0]
   \   00000030   0x2B01             CMP      R3,#+1
   \   00000032   0xD005             BEQ.N    ??OSFlagPend_2
    395                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    396                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000034   0xF645 0x6089      MOVW     R0,#+24201
   \   00000038   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    397                  return (0u);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE1C4             B.N      ??OSFlagPend_1
    398              }
   \                     ??OSFlagPend_2: (+1)
   \   00000040   0x0004             MOVS     R4,R0
    399          #endif
    400          
    401          #if (OS_CFG_ARG_CHK_EN > 0u)
    402              if (p_grp == (OS_FLAG_GRP *)0) {                            /* Validate 'p_grp'                                     */
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD105             BNE.N    ??OSFlagPend_3
    403                  OS_TRACE_FLAG_PEND_FAILED(p_grp);
    404                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OBJ_PTR_NULL);
    405                 *p_err = OS_ERR_OBJ_PTR_NULL;
   \   00000046   0xF645 0x50C3      MOVW     R0,#+24003
   \   0000004A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    406                  return (0u);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE1BB             B.N      ??OSFlagPend_1
    407              }
    408              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSFlagPend_3: (+1)
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000056   0x1E40             SUBS     R0,R0,#+1
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD91A             BLS.N    ??OSFlagPend_4
   \   0000005C   0x1EC0             SUBS     R0,R0,#+3
   \   0000005E   0xD018             BEQ.N    ??OSFlagPend_4
   \   00000060   0x1F00             SUBS     R0,R0,#+4
   \   00000062   0xD016             BEQ.N    ??OSFlagPend_4
   \   00000064   0x38F9             SUBS     R0,R0,#+249
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD913             BLS.N    ??OSFlagPend_4
   \   0000006A   0x1EC0             SUBS     R0,R0,#+3
   \   0000006C   0xD011             BEQ.N    ??OSFlagPend_4
   \   0000006E   0x1F00             SUBS     R0,R0,#+4
   \   00000070   0xD00F             BEQ.N    ??OSFlagPend_4
   \   00000072   0xF647 0x63F9      MOVW     R3,#+32505
   \   00000076   0x1AC0             SUBS     R0,R0,R3
   \   00000078   0x2801             CMP      R0,#+1
   \   0000007A   0xD90A             BLS.N    ??OSFlagPend_4
   \   0000007C   0x1EC0             SUBS     R0,R0,#+3
   \   0000007E   0xD008             BEQ.N    ??OSFlagPend_4
   \   00000080   0x1F00             SUBS     R0,R0,#+4
   \   00000082   0xD006             BEQ.N    ??OSFlagPend_4
   \   00000084   0x38F9             SUBS     R0,R0,#+249
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD903             BLS.N    ??OSFlagPend_4
   \   0000008A   0x1EC0             SUBS     R0,R0,#+3
   \   0000008C   0xD001             BEQ.N    ??OSFlagPend_4
   \   0000008E   0x1F00             SUBS     R0,R0,#+4
   \   00000090   0xD10B             BNE.N    ??OSFlagPend_5
    409                  case OS_OPT_PEND_FLAG_CLR_ALL:
    410                  case OS_OPT_PEND_FLAG_CLR_ANY:
    411                  case OS_OPT_PEND_FLAG_SET_ALL:
    412                  case OS_OPT_PEND_FLAG_SET_ANY:
    413                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
    414                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
    415                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
    416                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
    417                  case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
    418                  case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
    419                  case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
    420                  case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
    421                  case OS_OPT_PEND_FLAG_CLR_ALL | (OS_OPT)(OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING):
    422                  case OS_OPT_PEND_FLAG_CLR_ANY | (OS_OPT)(OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING):
    423                  case OS_OPT_PEND_FLAG_SET_ALL | (OS_OPT)(OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING):
    424                  case OS_OPT_PEND_FLAG_SET_ANY | (OS_OPT)(OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING):
    425                       break;
    426          
    427                  default:
    428                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    429                       OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OPT_INVALID);
    430                      *p_err = OS_ERR_OPT_INVALID;
    431                       return (0u);
    432              }
    433          #endif
    434          
    435          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    436              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Validate that we are pointing at an event flag       */
   \                     ??OSFlagPend_4: (+1)
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      LDR.W    R3,??DataTable7_1  ;; 0x47414c46
   \   00000098   0x4298             CMP      R0,R3
   \   0000009A   0xD10C             BNE.N    ??OSFlagPend_6
    437                  OS_TRACE_FLAG_PEND_FAILED(p_grp);
    438                  OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OBJ_TYPE);
    439                 *p_err = OS_ERR_OBJ_TYPE;
    440                  return (0u);
    441              }
    442          #endif
    443          
    444              if ((opt & OS_OPT_PEND_FLAG_CONSUME) != 0u) {               /* See if we need to consume the flags                  */
   \   0000009C   0x0038             MOVS     R0,R7
   \   0000009E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A0   0x05C0             LSLS     R0,R0,#+23
   \   000000A2   0xD50E             BPL.N    ??OSFlagPend_7
    445                  consume = OS_TRUE;
   \   000000A4   0xF05F 0x0901      MOVS     R9,#+1
   \   000000A8   0xE00D             B.N      ??OSFlagPend_8
    446              } else {
   \                     ??OSFlagPend_5: (+1)
   \   000000AA   0xF645 0x6025      MOVW     R0,#+24101
   \   000000AE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE189             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_6: (+1)
   \   000000B6   0xF645 0x50C4      MOVW     R0,#+24004
   \   000000BA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE183             B.N      ??OSFlagPend_1
    447                  consume = OS_FALSE;
   \                     ??OSFlagPend_7: (+1)
   \   000000C2   0xF05F 0x0900      MOVS     R9,#+0
    448              }
    449          
    450              if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_8: (+1)
   \   000000C6   0x980A             LDR      R0,[SP, #+40]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD002             BEQ.N    ??OSFlagPend_9
    451                 *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x9B0A             LDR      R3,[SP, #+40]
   \   000000D0   0x6018             STR      R0,[R3, #+0]
   \                     ??OSFlagPend_9: (+1)
   \   000000D2   0x0016             MOVS     R6,R2
   \   000000D4   0x468A             MOV      R10,R1
    452              }
    453          
    454              mode = opt & OS_OPT_PEND_FLAG_MASK;
   \   000000D6   0xF017 0x000F      ANDS     R0,R7,#0xF
   \   000000DA   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    455              CPU_CRITICAL_ENTER();
   \   000000DE   0x2040             MOVS     R0,#+64
   \   000000E0   0x.... 0x....      BL       CPU_SR_Save
   \   000000E4   0x4683             MOV      R11,R0
    456              switch (mode) {
   \   000000E6   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xF000 0x809F      BEQ.W    ??OSFlagPend_10
   \   000000F0   0x2802             CMP      R0,#+2
   \   000000F2   0xF000 0x80DB      BEQ.W    ??OSFlagPend_11
   \   000000F6   0x2804             CMP      R0,#+4
   \   000000F8   0xD002             BEQ.N    ??OSFlagPend_12
   \   000000FA   0x2808             CMP      R0,#+8
   \   000000FC   0xD058             BEQ.N    ??OSFlagPend_13
   \   000000FE   0xE114             B.N      ??OSFlagPend_14
    457                  case OS_OPT_PEND_FLAG_SET_ALL:                          /* See if all required flags are set                    */
    458                       flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
   \                     ??OSFlagPend_12: (+1)
   \   00000100   0x68E5             LDR      R5,[R4, #+12]
   \   00000102   0xEA1A 0x0505      ANDS     R5,R10,R5
    459                       if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
   \   00000106   0x4555             CMP      R5,R10
   \   00000108   0xD113             BNE.N    ??OSFlagPend_15
    460                           if (consume == OS_TRUE) {                      /* See if we need to consume the flags                  */
   \   0000010A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000010E   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000112   0xD102             BNE.N    ??OSFlagPend_16
    461                               p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we wanted                  */
   \   00000114   0x68E0             LDR      R0,[R4, #+12]
   \   00000116   0x43A8             BICS     R0,R0,R5
   \   00000118   0x60E0             STR      R0,[R4, #+12]
    462                           }
    463                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
   \                     ??OSFlagPend_16: (+1)
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   0000011E   0x6800             LDR      R0,[R0, #+0]
   \   00000120   0x6785             STR      R5,[R0, #+120]
    464          #if (OS_CFG_TS_EN > 0u)
    465                           if (p_ts != (CPU_TS *)0) {
    466                              *p_ts = p_grp->TS;
    467                           }
    468          #endif
    469                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
   \   00000122   0x4658             MOV      R0,R11
   \   00000124   0x.... 0x....      BL       CPU_SR_Restore
    470                           OS_TRACE_FLAG_PEND(p_grp);
    471                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    472                          *p_err = OS_ERR_NONE;
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    473                           return (flags_rdy);
   \   0000012E   0x0028             MOVS     R0,R5
   \   00000130   0xE14B             B.N      ??OSFlagPend_1
    474                       } else {                                           /* Block task until events occur or timeout             */
    475                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
   \                     ??OSFlagPend_15: (+1)
   \   00000132   0x0038             MOVS     R0,R7
   \   00000134   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000136   0x0400             LSLS     R0,R0,#+16
   \   00000138   0xD508             BPL.N    ??OSFlagPend_17
    476                               CPU_CRITICAL_EXIT();
   \   0000013A   0x4658             MOV      R0,R11
   \   0000013C   0x.... 0x....      BL       CPU_SR_Restore
    477                               OS_TRACE_FLAG_PEND_FAILED(p_grp);
    478                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    479                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
   \   00000140   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000144   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    480                               return ((OS_FLAGS)0);
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0xE13E             B.N      ??OSFlagPend_1
    481                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    482                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
   \                     ??OSFlagPend_17: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0x2800             CMP      R0,#+0
   \   00000154   0xD008             BEQ.N    ??OSFlagPend_18
    483                                   CPU_CRITICAL_EXIT();
   \   00000156   0x4658             MOV      R0,R11
   \   00000158   0x.... 0x....      BL       CPU_SR_Restore
    484                                   OS_TRACE_FLAG_PEND_FAILED(p_grp);
    485                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    486                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
   \   0000015C   0xF646 0x5063      MOVW     R0,#+28003
   \   00000160   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    487                                   return (0u);
   \   00000164   0x2000             MOVS     R0,#+0
   \   00000166   0xE130             B.N      ??OSFlagPend_1
    488                               }
    489                           }
    490                                                                          /* Lock the scheduler/re-enable interrupts              */
    491                           OS_FlagBlock(p_grp,
    492                                        flags,
    493                                        opt,
    494                                        timeout);
   \                     ??OSFlagPend_18: (+1)
   \   00000168   0x0033             MOVS     R3,R6
   \   0000016A   0x003A             MOVS     R2,R7
   \   0000016C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000016E   0x4651             MOV      R1,R10
   \   00000170   0x0020             MOVS     R0,R4
   \   00000172   0x.... 0x....      BL       OS_FlagBlock
    495                           CPU_CRITICAL_EXIT();
   \   00000176   0x4658             MOV      R0,R11
   \   00000178   0x.... 0x....      BL       CPU_SR_Restore
    496                       }
    497                       break;
    498          
    499                  case OS_OPT_PEND_FLAG_SET_ANY:
    500                       flags_rdy = (p_grp->Flags & flags);                /* Extract only the bits we want                        */
    501                       if (flags_rdy != 0u) {                             /* See if any flag set                                  */
    502                           if (consume == OS_TRUE) {                      /* See if we need to consume the flags                  */
    503                               p_grp->Flags &= ~flags_rdy;                /* Clear ONLY the flags that we got                     */
    504                           }
    505                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
    506          #if (OS_CFG_TS_EN > 0u)
    507                           if (p_ts != (CPU_TS *)0) {
    508                              *p_ts  = p_grp->TS;
    509                           }
    510          #endif
    511                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
    512                           OS_TRACE_FLAG_PEND(p_grp);
    513                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    514                          *p_err = OS_ERR_NONE;
    515                           return (flags_rdy);
    516                       } else {                                           /* Block task until events occur or timeout             */
    517                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    518                               CPU_CRITICAL_EXIT();
    519                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    520                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
    521                               return ((OS_FLAGS)0);
    522                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    523                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
    524                                   CPU_CRITICAL_EXIT();
    525                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    526                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
    527                                   return ((OS_FLAGS)0);
    528                               }
    529                           }
    530          
    531                           OS_FlagBlock(p_grp,
    532                                        flags,
    533                                        opt,
    534                                        timeout);
    535                           CPU_CRITICAL_EXIT();
    536                       }
    537                       break;
    538          
    539          #if (OS_CFG_FLAG_MODE_CLR_EN > 0u)
    540                  case OS_OPT_PEND_FLAG_CLR_ALL:                          /* See if all required flags are cleared                */
    541                       flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags);     /* Extract only the bits we want                        */
    542                       if (flags_rdy == flags) {                          /* Must match ALL the bits that we want                 */
    543                           if (consume == OS_TRUE) {                      /* See if we need to consume the flags                  */
    544                               p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we wanted                    */
    545                           }
    546                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
    547          #if (OS_CFG_TS_EN > 0u)
    548                           if (p_ts != (CPU_TS *)0) {
    549                              *p_ts  = p_grp->TS;
    550                           }
    551          #endif
    552                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
    553                           OS_TRACE_FLAG_PEND(p_grp);
    554                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    555                          *p_err = OS_ERR_NONE;
    556                           return (flags_rdy);
    557                       } else {                                           /* Block task until events occur or timeout             */
    558                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    559                               CPU_CRITICAL_EXIT();
    560                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    561                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
    562                               return ((OS_FLAGS)0);
    563                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    564                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
    565                                   CPU_CRITICAL_EXIT();
    566                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    567                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
    568                                   return (0);
    569                               }
    570                           }
    571          
    572                           OS_FlagBlock(p_grp,
    573                                        flags,
    574                                        opt,
    575                                        timeout);
    576                           CPU_CRITICAL_EXIT();
    577                       }
    578                       break;
    579          
    580                  case OS_OPT_PEND_FLAG_CLR_ANY:
    581                       flags_rdy = (~p_grp->Flags & flags);               /* Extract only the bits we want                        */
    582                       if (flags_rdy != 0u) {                             /* See if any flag cleared                              */
    583                           if (consume == OS_TRUE) {                      /* See if we need to consume the flags                  */
    584                               p_grp->Flags |= flags_rdy;                 /* Set ONLY the flags that we got                       */
    585                           }
    586                           OSTCBCurPtr->FlagsRdy = flags_rdy;             /* Save flags that were ready                           */
    587          #if (OS_CFG_TS_EN > 0u)
    588                           if (p_ts != (CPU_TS *)0) {
    589                              *p_ts  = p_grp->TS;
    590                           }
    591          #endif
    592                           CPU_CRITICAL_EXIT();                           /* Yes, condition met, return to caller                 */
    593                           OS_TRACE_FLAG_PEND(p_grp);
    594                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    595                          *p_err = OS_ERR_NONE;
    596                           return (flags_rdy);
    597                       } else {                                           /* Block task until events occur or timeout             */
    598                           if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {
    599                               CPU_CRITICAL_EXIT();
    600                               OS_TRACE_FLAG_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    601                              *p_err = OS_ERR_PEND_WOULD_BLOCK;           /* Specified non-blocking so task would block           */
    602                               return ((OS_FLAGS)0);
    603                           } else {                                       /* Specified blocking so check is scheduler is locked   */
    604                               if (OSSchedLockNestingCtr > 0u) {          /* See if called with scheduler locked ...        */
    605                                   CPU_CRITICAL_EXIT();
    606                                   OS_TRACE_FLAG_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    607                                  *p_err = OS_ERR_SCHED_LOCKED;           /* ... can't PEND when locked                           */
    608                                   return (0u);
    609                               }
    610                           }
    611          
    612                           OS_FlagBlock(p_grp,
    613                                        flags,
    614                                        opt,
    615                                        timeout);
    616                           CPU_CRITICAL_EXIT();
    617                       }
    618                       break;
    619          #endif
    620          
    621                  default:
    622                       CPU_CRITICAL_EXIT();
    623                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    624                       OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OPT_INVALID);
    625                      *p_err = OS_ERR_OPT_INVALID;
    626                       return (0u);
    627              }
    628          
    629              OS_TRACE_FLAG_PEND_BLOCK(p_grp);
    630          
    631              OSSched();                                                  /* Find next HPT ready to run                           */
   \                     ??OSFlagPend_19: (+1)
   \   0000017C   0x.... 0x....      BL       OSSched
    632          
    633              CPU_CRITICAL_ENTER();
   \   00000180   0x2040             MOVS     R0,#+64
   \   00000182   0x.... 0x....      BL       CPU_SR_Save
   \   00000186   0x0005             MOVS     R5,R0
    634              switch (OSTCBCurPtr->PendStatus) {
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   0000018C   0x6800             LDR      R0,[R0, #+0]
   \   0000018E   0xF890 0x002D      LDRB     R0,[R0, #+45]
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD008             BEQ.N    ??OSFlagPend_20
   \   00000196   0x2802             CMP      R0,#+2
   \   00000198   0xF000 0x80E6      BEQ.W    ??OSFlagPend_21
   \   0000019C   0xF0C0 0x80CE      BCC.W    ??OSFlagPend_22
   \   000001A0   0x2803             CMP      R0,#+3
   \   000001A2   0xF000 0x80D3      BEQ.W    ??OSFlagPend_23
   \   000001A6   0xE0E7             B.N      ??OSFlagPend_24
    635                  case OS_STATUS_PEND_OK:                                 /* We got the event flags                               */
    636          #if (OS_CFG_TS_EN > 0u)
    637                       if (p_ts != (CPU_TS *)0) {
    638                          *p_ts = OSTCBCurPtr->TS;
    639                       }
    640          #endif
    641                       OS_TRACE_FLAG_PEND(p_grp);
    642                      *p_err = OS_ERR_NONE;
   \                     ??OSFlagPend_20: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    643                       break;
   \   000001AE   0xE0EA             B.N      ??OSFlagPend_25
   \                     ??OSFlagPend_13: (+1)
   \   000001B0   0x68E5             LDR      R5,[R4, #+12]
   \   000001B2   0xEA1A 0x0505      ANDS     R5,R10,R5
   \   000001B6   0x2D00             CMP      R5,#+0
   \   000001B8   0xD013             BEQ.N    ??OSFlagPend_26
   \   000001BA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001BE   0xF1B9 0x0F01      CMP      R9,#+1
   \   000001C2   0xD102             BNE.N    ??OSFlagPend_27
   \   000001C4   0x68E0             LDR      R0,[R4, #+12]
   \   000001C6   0x43A8             BICS     R0,R0,R5
   \   000001C8   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSFlagPend_27: (+1)
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   000001CE   0x6800             LDR      R0,[R0, #+0]
   \   000001D0   0x6785             STR      R5,[R0, #+120]
   \   000001D2   0x4658             MOV      R0,R11
   \   000001D4   0x.... 0x....      BL       CPU_SR_Restore
   \   000001D8   0x2000             MOVS     R0,#+0
   \   000001DA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000001DE   0x0028             MOVS     R0,R5
   \   000001E0   0xE0F3             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_26: (+1)
   \   000001E2   0x0038             MOVS     R0,R7
   \   000001E4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001E6   0x0400             LSLS     R0,R0,#+16
   \   000001E8   0xD508             BPL.N    ??OSFlagPend_28
   \   000001EA   0x4658             MOV      R0,R11
   \   000001EC   0x.... 0x....      BL       CPU_SR_Restore
   \   000001F0   0xF246 0x10B0      MOVW     R0,#+25008
   \   000001F4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xE0E6             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_28: (+1)
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   00000200   0x7800             LDRB     R0,[R0, #+0]
   \   00000202   0x2800             CMP      R0,#+0
   \   00000204   0xD008             BEQ.N    ??OSFlagPend_29
   \   00000206   0x4658             MOV      R0,R11
   \   00000208   0x.... 0x....      BL       CPU_SR_Restore
   \   0000020C   0xF646 0x5063      MOVW     R0,#+28003
   \   00000210   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000214   0x2000             MOVS     R0,#+0
   \   00000216   0xE0D8             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_29: (+1)
   \   00000218   0x0033             MOVS     R3,R6
   \   0000021A   0x003A             MOVS     R2,R7
   \   0000021C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000021E   0x4651             MOV      R1,R10
   \   00000220   0x0020             MOVS     R0,R4
   \   00000222   0x.... 0x....      BL       OS_FlagBlock
   \   00000226   0x4658             MOV      R0,R11
   \   00000228   0x.... 0x....      BL       CPU_SR_Restore
   \   0000022C   0xE7A6             B.N      ??OSFlagPend_19
   \                     ??OSFlagPend_10: (+1)
   \   0000022E   0x68E5             LDR      R5,[R4, #+12]
   \   00000230   0xEA3A 0x0505      BICS     R5,R10,R5
   \   00000234   0x4555             CMP      R5,R10
   \   00000236   0xD113             BNE.N    ??OSFlagPend_30
   \   00000238   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000023C   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000240   0xD102             BNE.N    ??OSFlagPend_31
   \   00000242   0x68E0             LDR      R0,[R4, #+12]
   \   00000244   0x4328             ORRS     R0,R5,R0
   \   00000246   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSFlagPend_31: (+1)
   \   00000248   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   0000024C   0x6800             LDR      R0,[R0, #+0]
   \   0000024E   0x6785             STR      R5,[R0, #+120]
   \   00000250   0x4658             MOV      R0,R11
   \   00000252   0x.... 0x....      BL       CPU_SR_Restore
   \   00000256   0x2000             MOVS     R0,#+0
   \   00000258   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000025C   0x0028             MOVS     R0,R5
   \   0000025E   0xE0B4             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_30: (+1)
   \   00000260   0x0038             MOVS     R0,R7
   \   00000262   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000264   0x0400             LSLS     R0,R0,#+16
   \   00000266   0xD508             BPL.N    ??OSFlagPend_32
   \   00000268   0x4658             MOV      R0,R11
   \   0000026A   0x.... 0x....      BL       CPU_SR_Restore
   \   0000026E   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000272   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xE0A7             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_32: (+1)
   \   0000027A   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   0000027E   0x7800             LDRB     R0,[R0, #+0]
   \   00000280   0x2800             CMP      R0,#+0
   \   00000282   0xD008             BEQ.N    ??OSFlagPend_33
   \   00000284   0x4658             MOV      R0,R11
   \   00000286   0x.... 0x....      BL       CPU_SR_Restore
   \   0000028A   0xF646 0x5063      MOVW     R0,#+28003
   \   0000028E   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000292   0x2000             MOVS     R0,#+0
   \   00000294   0xE099             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_33: (+1)
   \   00000296   0x0033             MOVS     R3,R6
   \   00000298   0x003A             MOVS     R2,R7
   \   0000029A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000029C   0x4651             MOV      R1,R10
   \   0000029E   0x0020             MOVS     R0,R4
   \   000002A0   0x.... 0x....      BL       OS_FlagBlock
   \   000002A4   0x4658             MOV      R0,R11
   \   000002A6   0x.... 0x....      BL       CPU_SR_Restore
   \   000002AA   0xE767             B.N      ??OSFlagPend_19
   \                     ??OSFlagPend_11: (+1)
   \   000002AC   0x68E5             LDR      R5,[R4, #+12]
   \   000002AE   0xEA3A 0x0505      BICS     R5,R10,R5
   \   000002B2   0x2D00             CMP      R5,#+0
   \   000002B4   0xD013             BEQ.N    ??OSFlagPend_34
   \   000002B6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000002BA   0xF1B9 0x0F01      CMP      R9,#+1
   \   000002BE   0xD102             BNE.N    ??OSFlagPend_35
   \   000002C0   0x68E0             LDR      R0,[R4, #+12]
   \   000002C2   0x4328             ORRS     R0,R5,R0
   \   000002C4   0x60E0             STR      R0,[R4, #+12]
   \                     ??OSFlagPend_35: (+1)
   \   000002C6   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \   000002CA   0x6800             LDR      R0,[R0, #+0]
   \   000002CC   0x6785             STR      R5,[R0, #+120]
   \   000002CE   0x4658             MOV      R0,R11
   \   000002D0   0x.... 0x....      BL       CPU_SR_Restore
   \   000002D4   0x2000             MOVS     R0,#+0
   \   000002D6   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000002DA   0x0028             MOVS     R0,R5
   \   000002DC   0xE075             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_34: (+1)
   \   000002DE   0x0038             MOVS     R0,R7
   \   000002E0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000002E2   0x0400             LSLS     R0,R0,#+16
   \   000002E4   0xD508             BPL.N    ??OSFlagPend_36
   \   000002E6   0x4658             MOV      R0,R11
   \   000002E8   0x.... 0x....      BL       CPU_SR_Restore
   \   000002EC   0xF246 0x10B0      MOVW     R0,#+25008
   \   000002F0   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000002F4   0x2000             MOVS     R0,#+0
   \   000002F6   0xE068             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_36: (+1)
   \   000002F8   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \   000002FC   0x7800             LDRB     R0,[R0, #+0]
   \   000002FE   0x2800             CMP      R0,#+0
   \   00000300   0xD008             BEQ.N    ??OSFlagPend_37
   \   00000302   0x4658             MOV      R0,R11
   \   00000304   0x.... 0x....      BL       CPU_SR_Restore
   \   00000308   0xF646 0x5063      MOVW     R0,#+28003
   \   0000030C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000310   0x2000             MOVS     R0,#+0
   \   00000312   0xE05A             B.N      ??OSFlagPend_1
   \                     ??OSFlagPend_37: (+1)
   \   00000314   0x0033             MOVS     R3,R6
   \   00000316   0x003A             MOVS     R2,R7
   \   00000318   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000031A   0x4651             MOV      R1,R10
   \   0000031C   0x0020             MOVS     R0,R4
   \   0000031E   0x.... 0x....      BL       OS_FlagBlock
   \   00000322   0x4658             MOV      R0,R11
   \   00000324   0x.... 0x....      BL       CPU_SR_Restore
   \   00000328   0xE728             B.N      ??OSFlagPend_19
   \                     ??OSFlagPend_14: (+1)
   \   0000032A   0x4658             MOV      R0,R11
   \   0000032C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000330   0xF645 0x6025      MOVW     R0,#+24101
   \   00000334   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   00000338   0x2000             MOVS     R0,#+0
   \   0000033A   0xE046             B.N      ??OSFlagPend_1
    644          
    645                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    646          #if (OS_CFG_TS_EN > 0u)
    647                       if (p_ts != (CPU_TS *)0) {
    648                          *p_ts = OSTCBCurPtr->TS;
    649                       }
    650          #endif
    651                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_22: (+1)
   \   0000033C   0x0028             MOVS     R0,R5
   \   0000033E   0x.... 0x....      BL       CPU_SR_Restore
    652                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    653                      *p_err = OS_ERR_PEND_ABORT;
   \   00000342   0xF246 0x10A9      MOVW     R0,#+25001
   \   00000346   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    654                       break;
   \   0000034A   0xE01C             B.N      ??OSFlagPend_25
    655          
    656                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get semaphore within timeout */
    657                       if (p_ts != (CPU_TS *)0) {
   \                     ??OSFlagPend_23: (+1)
   \   0000034C   0x980A             LDR      R0,[SP, #+40]
   \   0000034E   0x2800             CMP      R0,#+0
   \   00000350   0xD002             BEQ.N    ??OSFlagPend_38
    658                          *p_ts = 0u;
   \   00000352   0x2000             MOVS     R0,#+0
   \   00000354   0x990A             LDR      R1,[SP, #+40]
   \   00000356   0x6008             STR      R0,[R1, #+0]
    659                       }
    660                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_38: (+1)
   \   00000358   0x0028             MOVS     R0,R5
   \   0000035A   0x.... 0x....      BL       CPU_SR_Restore
    661                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    662                      *p_err = OS_ERR_TIMEOUT;
   \   0000035E   0xF247 0x20D9      MOVW     R0,#+29401
   \   00000362   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    663                       break;
   \   00000366   0xE00E             B.N      ??OSFlagPend_25
    664          
    665                  case OS_STATUS_PEND_DEL:                                /* Indicate that object pended on has been deleted      */
    666          #if (OS_CFG_TS_EN > 0u)
    667                       if (p_ts != (CPU_TS *)0) {
    668                          *p_ts = OSTCBCurPtr->TS;
    669                       }
    670          #endif
    671                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_21: (+1)
   \   00000368   0x0028             MOVS     R0,R5
   \   0000036A   0x.... 0x....      BL       CPU_SR_Restore
    672                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    673                      *p_err = OS_ERR_OBJ_DEL;
   \   0000036E   0xF645 0x50C2      MOVW     R0,#+24002
   \   00000372   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    674                       break;
   \   00000376   0xE006             B.N      ??OSFlagPend_25
    675          
    676                  default:
    677                       CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_24: (+1)
   \   00000378   0x0028             MOVS     R0,R5
   \   0000037A   0x.... 0x....      BL       CPU_SR_Restore
    678                       OS_TRACE_FLAG_PEND_FAILED(p_grp);
    679                      *p_err = OS_ERR_STATUS_INVALID;
   \   0000037E   0xF646 0x602E      MOVW     R0,#+28206
   \   00000382   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    680                       break;
    681              }
    682              if (*p_err != OS_ERR_NONE) {
   \                     ??OSFlagPend_25: (+1)
   \   00000386   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000038A   0x2800             CMP      R0,#+0
   \   0000038C   0xD001             BEQ.N    ??OSFlagPend_39
    683                  OS_TRACE_FLAG_PEND_EXIT(*p_err);
    684                  return (0u);
   \   0000038E   0x2000             MOVS     R0,#+0
   \   00000390   0xE01B             B.N      ??OSFlagPend_1
    685              }
    686          
    687              flags_rdy = OSTCBCurPtr->FlagsRdy;
   \                     ??OSFlagPend_39: (+1)
   \   00000392   0x....             LDR.N    R0,??DataTable7_3
   \   00000394   0x6800             LDR      R0,[R0, #+0]
   \   00000396   0x6F86             LDR      R6,[R0, #+120]
    688              if (consume == OS_TRUE) {                                   /* See if we need to consume the flags                  */
   \   00000398   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000039C   0xF1B9 0x0F01      CMP      R9,#+1
   \   000003A0   0xD10C             BNE.N    ??OSFlagPend_40
    689                  switch (mode) {
   \   000003A2   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000003A6   0x2801             CMP      R0,#+1
   \   000003A8   0xD011             BEQ.N    ??OSFlagPend_41
   \   000003AA   0x2802             CMP      R0,#+2
   \   000003AC   0xD00F             BEQ.N    ??OSFlagPend_41
   \   000003AE   0x2804             CMP      R0,#+4
   \   000003B0   0xD001             BEQ.N    ??OSFlagPend_42
   \   000003B2   0x2808             CMP      R0,#+8
   \   000003B4   0xD10F             BNE.N    ??OSFlagPend_43
    690                      case OS_OPT_PEND_FLAG_SET_ALL:
    691                      case OS_OPT_PEND_FLAG_SET_ANY:                      /* Clear ONLY the flags we got                          */
    692                           p_grp->Flags &= ~flags_rdy;
   \                     ??OSFlagPend_42: (+1)
   \   000003B6   0x68E0             LDR      R0,[R4, #+12]
   \   000003B8   0x43B0             BICS     R0,R0,R6
   \   000003BA   0x60E0             STR      R0,[R4, #+12]
    693                           break;
    694          
    695          #if (OS_CFG_FLAG_MODE_CLR_EN > 0u)
    696                      case OS_OPT_PEND_FLAG_CLR_ALL:
    697                      case OS_OPT_PEND_FLAG_CLR_ANY:                      /* Set   ONLY the flags we got                          */
    698                           p_grp->Flags |=  flags_rdy;
    699                           break;
    700          #endif
    701                      default:
    702                           CPU_CRITICAL_EXIT();
    703                           OS_TRACE_FLAG_PEND_EXIT(OS_ERR_OPT_INVALID);
    704                          *p_err = OS_ERR_OPT_INVALID;
    705                           return (0u);
    706                  }
    707              }
    708              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPend_40: (+1)
   \   000003BC   0x0028             MOVS     R0,R5
   \   000003BE   0x.... 0x....      BL       CPU_SR_Restore
    709              OS_TRACE_FLAG_PEND_EXIT(OS_ERR_NONE);
    710             *p_err = OS_ERR_NONE;                                        /* Event(s) must have occurred                          */
   \   000003C2   0x2000             MOVS     R0,#+0
   \   000003C4   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    711              return (flags_rdy);
   \   000003C8   0x0030             MOVS     R0,R6
   \                     ??OSFlagPend_1: (+1)
   \   000003CA   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??OSFlagPend_41: (+1)
   \   000003CE   0x68E0             LDR      R0,[R4, #+12]
   \   000003D0   0x4330             ORRS     R0,R6,R0
   \   000003D2   0x60E0             STR      R0,[R4, #+12]
   \   000003D4   0xE7F2             B.N      ??OSFlagPend_40
   \                     ??OSFlagPend_43: (+1)
   \   000003D6   0x0028             MOVS     R0,R5
   \   000003D8   0x.... 0x....      BL       CPU_SR_Restore
   \   000003DC   0xF645 0x6025      MOVW     R0,#+24101
   \   000003E0   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000003E4   0x2000             MOVS     R0,#+0
   \   000003E6   0xE7F0             B.N      ??OSFlagPend_1
    712          }
    713          
    714          
    715          /*
    716          ************************************************************************************************************************
    717          *                                          ABORT WAITING ON AN EVENT FLAG GROUP
    718          *
    719          * Description: This function aborts & readies any tasks currently waiting on an event flag group.  This function should
    720          *              be used to fault-abort the wait on the event flag group, rather than to normally post to the event flag
    721          *              group OSFlagPost().
    722          *
    723          * Arguments  : p_grp     is a pointer to the event flag group
    724          *
    725          *              opt       determines the type of ABORT performed:
    726          *
    727          *                            OS_OPT_PEND_ABORT_1          ABORT wait for a single task (HPT) waiting on the event flag
    728          *                            OS_OPT_PEND_ABORT_ALL        ABORT wait for ALL tasks that are  waiting on the event flag
    729          *                            OS_OPT_POST_NO_SCHED         Do not call the scheduler
    730          *
    731          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    732          *
    733          *                            OS_ERR_NONE                  At least one task waiting on the event flag group and was
    734          *                                                         readied and informed of the aborted wait; check return value
    735          *                                                         for the number of tasks whose wait on the event flag group
    736          *                                                         was aborted
    737          *                            OS_ERR_OBJ_PTR_NULL          If 'p_grp' is a NULL pointer
    738          *                            OS_ERR_OBJ_TYPE              If 'p_grp' is not pointing at an event flag group
    739          *                            OS_ERR_OPT_INVALID           If you specified an invalid option
    740          *                            OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
    741          *                            OS_ERR_PEND_ABORT_ISR        If you called this function from an ISR
    742          *                            OS_ERR_PEND_ABORT_NONE       No task were pending
    743          *
    744          * Returns    : == 0          if no tasks were waiting on the event flag group, or upon error.
    745          *              >  0          if one or more tasks waiting on the event flag group are now readied and informed.
    746          *
    747          * Note(s)    : none
    748          ************************************************************************************************************************
    749          */
    750          
    751          #if (OS_CFG_FLAG_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    752          OS_OBJ_QTY  OSFlagPendAbort (OS_FLAG_GRP  *p_grp,
    753                                       OS_OPT        opt,
    754                                       OS_ERR       *p_err)
    755          {
   \                     OSFlagPendAbort: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    756              OS_PEND_LIST  *p_pend_list;
    757              OS_TCB        *p_tcb;
    758              CPU_TS         ts;
    759              OS_OBJ_QTY     nbr_tasks;
    760              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
    761          
    762          
    763          #ifdef OS_SAFETY_CRITICAL
    764              if (p_err == (OS_ERR *)0) {
    765                  OS_SAFETY_CRITICAL_EXCEPTION();
    766                  return ((OS_OBJ_QTY)0u);
    767              }
    768          #endif
    769          
    770          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    771              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to Pend Abort from an ISR                */
   \   0000000C   0x....             LDR.N    R0,??DataTable7
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSFlagPendAbort_0
    772                 *p_err = OS_ERR_PEND_ABORT_ISR;
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    773                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE059             B.N      ??OSFlagPendAbort_1
    774              }
    775          #endif
    776          
    777          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    778              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSFlagPendAbort_0: (+1)
   \   0000001E   0x....             LDR.N    R0,??DataTable7_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSFlagPendAbort_2
    779                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    780                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE050             B.N      ??OSFlagPendAbort_1
    781              }
    782          #endif
    783          
    784          #if (OS_CFG_ARG_CHK_EN > 0u)
    785              if (p_grp == (OS_FLAG_GRP *)0) {                            /* Validate 'p_grp'                                     */
   \                     ??OSFlagPendAbort_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD104             BNE.N    ??OSFlagPendAbort_3
    786                 *p_err  =  OS_ERR_OBJ_PTR_NULL;
   \   00000034   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000038   0x8028             STRH     R0,[R5, #+0]
    787                  return (0u);
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE049             B.N      ??OSFlagPendAbort_1
    788              }
    789              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSFlagPendAbort_3: (+1)
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD008             BEQ.N    ??OSFlagPendAbort_4
   \   00000046   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000004A   0xD005             BEQ.N    ??OSFlagPendAbort_4
   \   0000004C   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000050   0xD002             BEQ.N    ??OSFlagPendAbort_4
   \   00000052   0xF5B0 0x4F01      CMP      R0,#+33024
   \   00000056   0xD113             BNE.N    ??OSFlagPendAbort_5
    790                  case OS_OPT_PEND_ABORT_1:
    791                  case OS_OPT_PEND_ABORT_ALL:
    792                  case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
    793                  case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
    794                       break;
    795          
    796                  default:
    797                      *p_err = OS_ERR_OPT_INVALID;
    798                       return (0u);
    799              }
    800          #endif
    801          
    802          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    803              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure event flag group was created               */
   \                     ??OSFlagPendAbort_4: (+1)
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x....             LDR.N    R1,??DataTable7_1  ;; 0x47414c46
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD114             BNE.N    ??OSFlagPendAbort_6
    804                 *p_err = OS_ERR_OBJ_TYPE;
    805                  return (0u);
    806              }
    807          #endif
    808          
    809              CPU_CRITICAL_ENTER();
   \   00000060   0x2040             MOVS     R0,#+64
   \   00000062   0x.... 0x....      BL       CPU_SR_Save
   \   00000066   0x0007             MOVS     R7,R0
    810              p_pend_list = &p_grp->PendList;
   \   00000068   0x1D24             ADDS     R4,R4,#+4
    811              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on flag group?                      */
   \   0000006A   0x6820             LDR      R0,[R4, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD111             BNE.N    ??OSFlagPendAbort_7
    812                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000070   0x0038             MOVS     R0,R7
   \   00000072   0x.... 0x....      BL       CPU_SR_Restore
    813                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   00000076   0xF246 0x10AB      MOVW     R0,#+25003
   \   0000007A   0x8028             STRH     R0,[R5, #+0]
    814                  return (0u);
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xE028             B.N      ??OSFlagPendAbort_1
    815              }
   \                     ??OSFlagPendAbort_5: (+1)
   \   00000080   0xF645 0x6025      MOVW     R0,#+24101
   \   00000084   0x8028             STRH     R0,[R5, #+0]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE023             B.N      ??OSFlagPendAbort_1
   \                     ??OSFlagPendAbort_6: (+1)
   \   0000008A   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000008E   0x8028             STRH     R0,[R5, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xE01E             B.N      ??OSFlagPendAbort_1
    816          
    817              nbr_tasks = 0u;
   \                     ??OSFlagPendAbort_7: (+1)
   \   00000094   0xF05F 0x0900      MOVS     R9,#+0
    818          #if (OS_CFG_TS_EN > 0u)
    819              ts        = OS_TS_GET();                                    /* Get local time stamp so all tasks get the same time  */
    820          #else
    821              ts        = 0u;
   \   00000098   0xF05F 0x0800      MOVS     R8,#+0
    822          #endif
    823          
    824              while (p_pend_list->HeadPtr != (OS_TCB *)0) {
   \                     ??OSFlagPendAbort_8: (+1)
   \   0000009C   0x6820             LDR      R0,[R4, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD00B             BEQ.N    ??OSFlagPendAbort_9
    825                  p_tcb = p_pend_list->HeadPtr;
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
    826                  OS_PendAbort(p_tcb,
    827                               ts,
    828                               OS_STATUS_PEND_ABORT);
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0x4641             MOV      R1,R8
   \   000000A8   0x.... 0x....      BL       OS_PendAbort
    829                  nbr_tasks++;
   \   000000AC   0xF119 0x0901      ADDS     R9,R9,#+1
    830                  if (opt != OS_OPT_PEND_ABORT_ALL) {                     /* Pend abort all tasks waiting?                        */
   \   000000B0   0x0030             MOVS     R0,R6
   \   000000B2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B4   0xF5B0 0x7F80      CMP      R0,#+256
   \   000000B8   0xD0F0             BEQ.N    ??OSFlagPendAbort_8
    831                      break;                                              /* No                                                   */
    832                  }
    833              }
    834              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPendAbort_9: (+1)
   \   000000BA   0x0038             MOVS     R0,R7
   \   000000BC   0x.... 0x....      BL       CPU_SR_Restore
    835          
    836              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000C0   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C2   0x0430             LSLS     R0,R6,#+16
   \   000000C4   0xD401             BMI.N    ??OSFlagPendAbort_10
    837                  OSSched();                                              /* Run the scheduler                                    */
   \   000000C6   0x.... 0x....      BL       OSSched
    838              }
    839          
    840             *p_err = OS_ERR_NONE;
   \                     ??OSFlagPendAbort_10: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x8028             STRH     R0,[R5, #+0]
    841              return (nbr_tasks);
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSFlagPendAbort_1: (+1)
   \   000000D2   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    842          }
    843          #endif
    844          
    845          
    846          /*
    847          ************************************************************************************************************************
    848          *                                       GET FLAGS WHO CAUSED TASK TO BECOME READY
    849          *
    850          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    851          *              In other words, this function allows you to tell "Who done it!".
    852          *
    853          * Arguments  : p_err     is a pointer to an error code
    854          *
    855          *                            OS_ERR_NONE              If the call was successful
    856          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    857          *                            OS_ERR_PEND_ISR          If called from an ISR
    858          *
    859          * Returns    : The flags that caused the task to be ready.
    860          *
    861          * Note(s)    : none
    862          ************************************************************************************************************************
    863          */
    864          

   \                                 In section .text, align 2, keep-with-next
    865          OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
    866          {
   \                     OSFlagPendGetFlagsRdy: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    867              OS_FLAGS  flags;
    868              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    869          
    870          
    871          #ifdef OS_SAFETY_CRITICAL
    872              if (p_err == (OS_ERR *)0) {
    873                  OS_SAFETY_CRITICAL_EXCEPTION();
    874                  return ((OS_FLAGS)0);
    875              }
    876          #endif
    877          
    878          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    879              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   00000006   0x....             LDR.N    R0,??DataTable7_2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD004             BEQ.N    ??OSFlagPendGetFlagsRdy_0
    880                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000000E   0xF645 0x6089      MOVW     R0,#+24201
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    881                  return (0u);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE013             B.N      ??OSFlagPendGetFlagsRdy_1
    882              }
    883          #endif
    884          
    885          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    886              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \                     ??OSFlagPendGetFlagsRdy_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable7
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ.N    ??OSFlagPendGetFlagsRdy_2
    887                 *p_err = OS_ERR_PEND_ISR;                                /* ... can't get from an ISR                            */
   \   00000020   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000024   0x8020             STRH     R0,[R4, #+0]
    888                  return (0u);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE00A             B.N      ??OSFlagPendGetFlagsRdy_1
    889              }
    890          #endif
    891          
    892              CPU_CRITICAL_ENTER();
   \                     ??OSFlagPendGetFlagsRdy_2: (+1)
   \   0000002A   0x2040             MOVS     R0,#+64
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
    893              flags = OSTCBCurPtr->FlagsRdy;
   \   00000030   0x....             LDR.N    R1,??DataTable7_3
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x6F8D             LDR      R5,[R1, #+120]
    894              CPU_CRITICAL_EXIT();
   \   00000036   0x.... 0x....      BL       CPU_SR_Restore
    895             *p_err = OS_ERR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x8020             STRH     R0,[R4, #+0]
    896              return (flags);
   \   0000003E   0x0028             MOVS     R0,R5
   \                     ??OSFlagPendGetFlagsRdy_1: (+1)
   \   00000040   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    897          }
    898          
    899          
    900          /*
    901          ************************************************************************************************************************
    902          *                                                POST EVENT FLAG BIT(S)
    903          *
    904          * Description: This function is called to set or clear some bits in an event flag group.  The bits to set or clear are
    905          *              specified by a 'bit mask'.
    906          *
    907          * Arguments  : p_grp         is a pointer to the desired event flag group.
    908          *
    909          *              flags         If 'opt' (see below) is OS_OPT_POST_FLAG_SET, each bit that is set in 'flags' will
    910          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    911          *                            and 5 you would set 'flags' to:
    912          *
    913          *                                0x31     (note, bit 0 is least significant bit)
    914          *
    915          *                            If 'opt' (see below) is OS_OPT_POST_FLAG_CLR, each bit that is set in 'flags' will
    916          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    917          *                            4 and 5 you would specify 'flags' as:
    918          *
    919          *                                0x31     (note, bit 0 is least significant bit)
    920          *
    921          *              opt           indicates whether the flags will be:
    922          *
    923          *                                OS_OPT_POST_FLAG_SET       set
    924          *                                OS_OPT_POST_FLAG_CLR       cleared
    925          *
    926          *                            you can also 'add' OS_OPT_POST_NO_SCHED to prevent the scheduler from being called.
    927          *
    928          *              p_err         is a pointer to an error code and can be:
    929          *
    930          *                                OS_ERR_NONE                The call was successful
    931          *                                OS_ERR_OBJ_PTR_NULL        You passed a NULL pointer
    932          *                                OS_ERR_OBJ_TYPE            You are not pointing to an event flag group
    933          *                                OS_ERR_OPT_INVALID         You specified an invalid option
    934          *                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
    935          *
    936          * Returns    : the new value of the event flags bits that are still set.
    937          *
    938          * Note(s)    : 1) The execution time of this function depends on the number of tasks waiting on the event flag group.
    939          ************************************************************************************************************************
    940          */
    941          

   \                                 In section .text, align 2, keep-with-next
    942          OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
    943                                OS_FLAGS      flags,
    944                                OS_OPT        opt,
    945                                OS_ERR       *p_err)
    946          {
   \                     OSFlagPost: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4691             MOV      R9,R2
   \   0000000A   0x001D             MOVS     R5,R3
    947          
    948              OS_FLAGS       flags_cur;
    949              OS_FLAGS       flags_rdy;
    950              OS_OPT         mode;
    951              OS_PEND_LIST  *p_pend_list;
    952              OS_TCB        *p_tcb;
    953              OS_TCB        *p_tcb_next;
    954              CPU_TS         ts;
    955              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
    956          
    957          
    958          #ifdef OS_SAFETY_CRITICAL
    959              if (p_err == (OS_ERR *)0) {
    960                  OS_SAFETY_CRITICAL_EXCEPTION();
    961                  return (0u);
    962              }
    963          #endif
    964          
    965              OS_TRACE_FLAG_POST_ENTER(p_grp, flags, opt);
    966          
    967          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    968              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   0000000E   0x....             LDR.N    R0,??DataTable7_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD004             BEQ.N    ??OSFlagPost_0
    969                  OS_TRACE_FLAG_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
    970                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000016   0xF645 0x6089      MOVW     R0,#+24201
   \   0000001A   0x8028             STRH     R0,[R5, #+0]
    971                  return (0u);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE097             B.N      ??OSFlagPost_1
    972              }
    973          #endif
    974          
    975          #if (OS_CFG_ARG_CHK_EN > 0u)
    976              if (p_grp == (OS_FLAG_GRP *)0) {                            /* Validate 'p_grp'                                     */
   \                     ??OSFlagPost_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD104             BNE.N    ??OSFlagPost_2
    977                  OS_TRACE_FLAG_POST_FAILED(p_grp);
    978                  OS_TRACE_FLAG_POST_EXIT(OS_ERR_OBJ_PTR_NULL);
    979                 *p_err  = OS_ERR_OBJ_PTR_NULL;
   \   00000024   0xF645 0x50C3      MOVW     R0,#+24003
   \   00000028   0x8028             STRH     R0,[R5, #+0]
    980                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE090             B.N      ??OSFlagPost_1
    981              }
    982          #endif
    983          
    984          #if (OS_CFG_OBJ_TYPE_CHK_EN > 0u)
    985              if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                      /* Make sure we are pointing to an event flag grp       */
   \                     ??OSFlagPost_2: (+1)
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x....             LDR.N    R1,??DataTable7_1  ;; 0x47414c46
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD004             BEQ.N    ??OSFlagPost_3
    986                  OS_TRACE_FLAG_POST_FAILED(p_grp);
    987                  OS_TRACE_FLAG_POST_EXIT(OS_ERR_OBJ_TYPE);
    988                 *p_err = OS_ERR_OBJ_TYPE;
   \   00000036   0xF645 0x50C4      MOVW     R0,#+24004
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    989                  return (0u);
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE087             B.N      ??OSFlagPost_1
    990              }
    991          #endif
    992          
    993          #if (OS_CFG_TS_EN > 0u)
    994              ts = OS_TS_GET();                                           /* Get timestamp                                        */
    995          #else
    996              ts = 0u;
   \                     ??OSFlagPost_3: (+1)
   \   00000040   0x2600             MOVS     R6,#+0
    997          #endif
    998          
    999              OS_TRACE_FLAG_POST(p_grp);
   1000          
   1001              switch (opt) {
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD009             BEQ.N    ??OSFlagPost_4
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD01B             BEQ.N    ??OSFlagPost_5
   \   0000004E   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000052   0xD004             BEQ.N    ??OSFlagPost_4
   \   00000054   0xF248 0x0101      MOVW     R1,#+32769
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD014             BEQ.N    ??OSFlagPost_5
   \   0000005C   0xE01D             B.N      ??OSFlagPost_6
   1002                  case OS_OPT_POST_FLAG_SET:
   1003                  case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
   1004                       CPU_CRITICAL_ENTER();
   \                     ??OSFlagPost_4: (+1)
   \   0000005E   0x2040             MOVS     R0,#+64
   \   00000060   0x.... 0x....      BL       CPU_SR_Save
   \   00000064   0x0007             MOVS     R7,R0
   1005                       p_grp->Flags |=  flags;                            /* Set   the flags specified in the group               */
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0xEA58 0x0800      ORRS     R8,R8,R0
   \   0000006C   0xF8C4 0x800C      STR      R8,[R4, #+12]
   1006                       break;
   1007          
   1008                  case OS_OPT_POST_FLAG_CLR:
   1009                  case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
   1010                       CPU_CRITICAL_ENTER();
   1011                       p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group               */
   1012                       break;
   1013          
   1014                  default:
   1015                      *p_err = OS_ERR_OPT_INVALID;                        /* INVALID option                                       */
   1016                       OS_TRACE_FLAG_POST_EXIT(*p_err);
   1017                       return (0u);
   1018              }
   1019          #if (OS_CFG_TS_EN > 0u)
   1020              p_grp->TS   = ts;
   1021          #endif
   1022              p_pend_list = &p_grp->PendList;
   \                     ??OSFlagPost_7: (+1)
   \   00000070   0x1D21             ADDS     R1,R4,#+4
   1023              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* Any task waiting on event flag group?                */
   \   00000072   0x6808             LDR      R0,[R1, #+0]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD115             BNE.N    ??OSFlagPost_8
   1024                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000078   0x0038             MOVS     R0,R7
   \   0000007A   0x.... 0x....      BL       CPU_SR_Restore
   1025                 *p_err = OS_ERR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x8028             STRH     R0,[R5, #+0]
   1026                  OS_TRACE_FLAG_POST_EXIT(*p_err);
   1027                  return (p_grp->Flags);
   \   00000082   0x68E0             LDR      R0,[R4, #+12]
   \   00000084   0xE064             B.N      ??OSFlagPost_1
   1028              }
   \                     ??OSFlagPost_5: (+1)
   \   00000086   0x2040             MOVS     R0,#+64
   \   00000088   0x.... 0x....      BL       CPU_SR_Save
   \   0000008C   0x0007             MOVS     R7,R0
   \   0000008E   0x68E0             LDR      R0,[R4, #+12]
   \   00000090   0xEA30 0x0808      BICS     R8,R0,R8
   \   00000094   0xF8C4 0x800C      STR      R8,[R4, #+12]
   \   00000098   0xE7EA             B.N      ??OSFlagPost_7
   \                     ??OSFlagPost_6: (+1)
   \   0000009A   0xF645 0x6025      MOVW     R0,#+24101
   \   0000009E   0x8028             STRH     R0,[R5, #+0]
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE055             B.N      ??OSFlagPost_1
   1029          
   1030              p_tcb = p_pend_list->HeadPtr;
   \                     ??OSFlagPost_8: (+1)
   \   000000A4   0x6808             LDR      R0,[R1, #+0]
   \   000000A6   0xE013             B.N      ??OSFlagPost_9
   1031              while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)        */
   1032                  p_tcb_next = p_tcb->PendNextPtr;
   1033                  mode       = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
   1034                  switch (mode) {
   1035                      case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node       */
   1036                           flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OSFlagPost_10: (+1)
   \   000000A8   0x68E1             LDR      R1,[R4, #+12]
   \   000000AA   0x6F42             LDR      R2,[R0, #+116]
   \   000000AC   0x4011             ANDS     R1,R2,R1
   1037                           if (flags_rdy == p_tcb->FlagsPend) {
   \   000000AE   0x6F42             LDR      R2,[R0, #+116]
   \   000000B0   0x4291             CMP      R1,R2
   \   000000B2   0xD102             BNE.N    ??OSFlagPost_11
   1038                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1039                                              flags_rdy,
   1040                                              ts);
   \   000000B4   0x0032             MOVS     R2,R6
   \   000000B6   0x.... 0x....      BL       OS_FlagTaskRdy
   1041                           }
   1042                           break;
   \                     ??OSFlagPost_11: (+1)
   \   000000BA   0xE008             B.N      ??OSFlagPost_12
   1043          
   1044                      case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                  */
   1045                           flags_rdy = (p_grp->Flags & p_tcb->FlagsPend);
   1046                           if (flags_rdy != 0u) {
   1047                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1048                                              flags_rdy,
   1049                                              ts);
   1050                           }
   1051                           break;
   1052          
   1053          #if (OS_CFG_FLAG_MODE_CLR_EN > 0u)
   1054                      case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node       */
   1055                           flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
   1056                           if (flags_rdy == p_tcb->FlagsPend) {
   1057                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1058                                              flags_rdy,
   1059                                              ts);
   1060                           }
   1061                           break;
   1062          
   1063                      case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                  */
   1064                           flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
   \                     ??OSFlagPost_13: (+1)
   \   000000BC   0x68E1             LDR      R1,[R4, #+12]
   \   000000BE   0x6F42             LDR      R2,[R0, #+116]
   \   000000C0   0xEA32 0x0101      BICS     R1,R2,R1
   1065                           if (flags_rdy != 0u) {
   \   000000C4   0x2900             CMP      R1,#+0
   \   000000C6   0xD002             BEQ.N    ??OSFlagPost_14
   1066                               OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                         */
   1067                                              flags_rdy,
   1068                                              ts);
   \   000000C8   0x0032             MOVS     R2,R6
   \   000000CA   0x.... 0x....      BL       OS_FlagTaskRdy
   1069                           }
   1070                           break;
   1071          #endif
   1072                      default:
   1073                           CPU_CRITICAL_EXIT();
   1074                          *p_err = OS_ERR_FLAG_PEND_OPT;
   1075                           OS_TRACE_FLAG_POST_EXIT(*p_err);
   1076                           return (0u);
   1077                  }
   1078                                                                          /* Point to next task waiting for event flag(s)         */
   1079                  p_tcb = p_tcb_next;
   \                     ??OSFlagPost_14: (+1)
   \                     ??OSFlagPost_12: (+1)
   \   000000CE   0x4640             MOV      R0,R8
   \                     ??OSFlagPost_9: (+1)
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD02A             BEQ.N    ??OSFlagPost_15
   \   000000D4   0xF8D0 0x8020      LDR      R8,[R0, #+32]
   \   000000D8   0xF890 0x107C      LDRB     R1,[R0, #+124]
   \   000000DC   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000000E0   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000E2   0x2901             CMP      R1,#+1
   \   000000E4   0xD00E             BEQ.N    ??OSFlagPost_16
   \   000000E6   0x2902             CMP      R1,#+2
   \   000000E8   0xD0E8             BEQ.N    ??OSFlagPost_13
   \   000000EA   0x2904             CMP      R1,#+4
   \   000000EC   0xD0DC             BEQ.N    ??OSFlagPost_10
   \   000000EE   0x2908             CMP      R1,#+8
   \   000000F0   0xD113             BNE.N    ??OSFlagPost_17
   \                     ??OSFlagPost_18: (+1)
   \   000000F2   0x68E1             LDR      R1,[R4, #+12]
   \   000000F4   0x6F42             LDR      R2,[R0, #+116]
   \   000000F6   0x4011             ANDS     R1,R2,R1
   \   000000F8   0x2900             CMP      R1,#+0
   \   000000FA   0xD002             BEQ.N    ??OSFlagPost_19
   \   000000FC   0x0032             MOVS     R2,R6
   \   000000FE   0x.... 0x....      BL       OS_FlagTaskRdy
   \                     ??OSFlagPost_19: (+1)
   \   00000102   0xE7E4             B.N      ??OSFlagPost_12
   \                     ??OSFlagPost_16: (+1)
   \   00000104   0x68E1             LDR      R1,[R4, #+12]
   \   00000106   0x6F42             LDR      R2,[R0, #+116]
   \   00000108   0xEA32 0x0101      BICS     R1,R2,R1
   \   0000010C   0x6F42             LDR      R2,[R0, #+116]
   \   0000010E   0x4291             CMP      R1,R2
   \   00000110   0xD102             BNE.N    ??OSFlagPost_20
   \   00000112   0x0032             MOVS     R2,R6
   \   00000114   0x.... 0x....      BL       OS_FlagTaskRdy
   \                     ??OSFlagPost_20: (+1)
   \   00000118   0xE7D9             B.N      ??OSFlagPost_12
   \                     ??OSFlagPost_17: (+1)
   \   0000011A   0x0038             MOVS     R0,R7
   \   0000011C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000120   0xF643 0x20FF      MOVW     R0,#+15103
   \   00000124   0x8028             STRH     R0,[R5, #+0]
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0xE012             B.N      ??OSFlagPost_1
   1080              }
   1081              CPU_CRITICAL_EXIT();
   \                     ??OSFlagPost_15: (+1)
   \   0000012A   0x0038             MOVS     R0,R7
   \   0000012C   0x.... 0x....      BL       CPU_SR_Restore
   1082          
   1083              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000130   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000134   0xEA5F 0x4009      LSLS     R0,R9,#+16
   \   00000138   0xD401             BMI.N    ??OSFlagPost_21
   1084                  OSSched();
   \   0000013A   0x.... 0x....      BL       OSSched
   1085              }
   1086          
   1087              CPU_CRITICAL_ENTER();
   \                     ??OSFlagPost_21: (+1)
   \   0000013E   0x2040             MOVS     R0,#+64
   \   00000140   0x.... 0x....      BL       CPU_SR_Save
   1088              flags_cur = p_grp->Flags;
   \   00000144   0x68E4             LDR      R4,[R4, #+12]
   1089              CPU_CRITICAL_EXIT();
   \   00000146   0x.... 0x....      BL       CPU_SR_Restore
   1090             *p_err     = OS_ERR_NONE;
   \   0000014A   0x2000             MOVS     R0,#+0
   \   0000014C   0x8028             STRH     R0,[R5, #+0]
   1091          
   1092              OS_TRACE_FLAG_POST_EXIT(*p_err);
   1093              return (flags_cur);
   \   0000014E   0x0020             MOVS     R0,R4
   \                     ??OSFlagPost_1: (+1)
   \   00000150   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1094          }
   1095          
   1096          
   1097          /*
   1098          ************************************************************************************************************************
   1099          *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
   1100          *
   1101          * Description: This function is internal to uC/OS-III and is used to put a task to sleep until the desired
   1102          *              event flag bit(s) are set.
   1103          *
   1104          * Arguments  : p_grp         is a pointer to the desired event flag group.
   1105          *              -----
   1106          *
   1107          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
   1108          *                            The bits you want are specified by setting the corresponding bits in
   1109          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
   1110          *                            'flags' would contain 0x03.
   1111          *
   1112          *              opt           specifies whether you want ALL bits to be set/cleared or ANY of the bits
   1113          *                            to be set/cleared.
   1114          *                            You can specify the following argument:
   1115          *
   1116          *                                OS_OPT_PEND_FLAG_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
   1117          *                                OS_OPT_PEND_FLAG_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
   1118          *                                OS_OPT_PEND_FLAG_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
   1119          *                                OS_OPT_PEND_FLAG_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
   1120          *
   1121          *              timeout       is the desired amount of time that the task will wait for the event flag
   1122          *                            bit(s) to be set.
   1123          *
   1124          * Returns    : none
   1125          *
   1126          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1127          ************************************************************************************************************************
   1128          */
   1129          

   \                                 In section .text, align 2, keep-with-next
   1130          void  OS_FlagBlock (OS_FLAG_GRP  *p_grp,
   1131                              OS_FLAGS      flags,
   1132                              OS_OPT        opt,
   1133                              OS_TICK       timeout)
   1134          {
   \                     OS_FlagBlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1135              OSTCBCurPtr->FlagsPend = flags;                             /* Save the flags that we need to wait for              */
   \   00000002   0x....             LDR.N    R4,??DataTable7_3
   \   00000004   0x6824             LDR      R4,[R4, #+0]
   \   00000006   0x6761             STR      R1,[R4, #+116]
   1136              OSTCBCurPtr->FlagsOpt  = opt;                               /* Save the type of wait we are doing                   */
   \   00000008   0x....             LDR.N    R1,??DataTable7_3
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xF8A1 0x207C      STRH     R2,[R1, #+124]
   1137              OSTCBCurPtr->FlagsRdy  = 0u;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R2,??DataTable7_3
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x6791             STR      R1,[R2, #+120]
   1138          
   1139              OS_Pend((OS_PEND_OBJ *)((void *)p_grp),
   1140                       OSTCBCurPtr,
   1141                       OS_TASK_PEND_ON_FLAG,
   1142                       timeout);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable7_3
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x.... 0x....      BL       OS_Pend
   1143          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   1144          
   1145          
   1146          /*
   1147          ************************************************************************************************************************
   1148          *                                      CLEAR THE CONTENTS OF AN EVENT FLAG GROUP
   1149          *
   1150          * Description: This function is called by OSFlagDel() to clear the contents of an event flag group
   1151          *
   1152          
   1153          * Argument(s): p_grp     is a pointer to the event flag group to clear
   1154          *              -----
   1155          *
   1156          * Returns    : none
   1157          *
   1158          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1159          ************************************************************************************************************************
   1160          */
   1161          

   \                                 In section .text, align 2, keep-with-next
   1162          void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
   1163          {
   \                     OS_FlagClr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1164              OS_PEND_LIST  *p_pend_list;
   1165          
   1166          
   1167          #if (OS_OBJ_TYPE_REQ > 0u)
   1168              p_grp->Type             = OS_OBJ_TYPE_NONE;
   \   00000002   0x....             LDR.N    R1,??DataTable7_5  ;; 0x454e4f4e
   \   00000004   0x6001             STR      R1,[R0, #+0]
   1169          #endif
   1170          #if (OS_CFG_DBG_EN > 0u)
   1171              p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                         */
   1172          #endif
   1173              p_grp->Flags            =  0u;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x60C1             STR      R1,[R0, #+12]
   1174              p_pend_list             = &p_grp->PendList;
   \   0000000A   0x1D00             ADDS     R0,R0,#+4
   1175              OS_PendListInit(p_pend_list);
   \   0000000C   0x.... 0x....      BL       OS_PendListInit
   1176          }
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
   1177          
   1178          
   1179          /*
   1180          ************************************************************************************************************************
   1181          *                                    ADD/REMOVE EVENT FLAG GROUP TO/FROM DEBUG LIST
   1182          *
   1183          * Description: These functions are called by uC/OS-III to add or remove an event flag group from the event flag debug
   1184          *              list.
   1185          *
   1186          * Arguments  : p_grp     is a pointer to the event flag group to add/remove
   1187          *
   1188          * Returns    : none
   1189          *
   1190          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   1191          ************************************************************************************************************************
   1192          */
   1193          
   1194          #if (OS_CFG_DBG_EN > 0u)
   1195          void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
   1196          {
   1197              p_grp->DbgNamePtr                = (CPU_CHAR *)((void *)" ");
   1198              p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
   1199              if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
   1200                  p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
   1201              } else {
   1202                  p_grp->DbgNextPtr            = OSFlagDbgListPtr;
   1203                  OSFlagDbgListPtr->DbgPrevPtr = p_grp;
   1204              }
   1205              OSFlagDbgListPtr                 = p_grp;
   1206          }
   1207          
   1208          
   1209          void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
   1210          {
   1211              OS_FLAG_GRP  *p_grp_next;
   1212              OS_FLAG_GRP  *p_grp_prev;
   1213          
   1214          
   1215              p_grp_prev = p_grp->DbgPrevPtr;
   1216              p_grp_next = p_grp->DbgNextPtr;
   1217          
   1218              if (p_grp_prev == (OS_FLAG_GRP *)0) {
   1219                  OSFlagDbgListPtr = p_grp_next;
   1220                  if (p_grp_next != (OS_FLAG_GRP *)0) {
   1221                      p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
   1222                  }
   1223                  p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;
   1224          
   1225              } else if (p_grp_next == (OS_FLAG_GRP *)0) {
   1226                  p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
   1227                  p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
   1228          
   1229              } else {
   1230                  p_grp_prev->DbgNextPtr =  p_grp_next;
   1231                  p_grp_next->DbgPrevPtr =  p_grp_prev;
   1232                  p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
   1233                  p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
   1234              }
   1235          }
   1236          #endif
   1237          
   1238          
   1239          /*
   1240          ************************************************************************************************************************
   1241          *                                        MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1242          *
   1243          * Description: This function is internal to uC/OS-III and is used to make a task ready-to-run because the desired event
   1244          *              flag bits have been set.
   1245          *
   1246          * Arguments  : p_tcb         is a pointer to the OS_TCB of the task to remove
   1247          *              -----
   1248          *
   1249          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become ready-to-run.
   1250          *
   1251          *              ts            is a timestamp associated with the post
   1252          *
   1253          * Returns    : none
   1254          *
   1255          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1256          ************************************************************************************************************************
   1257          */
   1258          

   \                                 In section .text, align 2, keep-with-next
   1259          void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
   1260                                 OS_FLAGS   flags_rdy,
   1261                                 CPU_TS     ts)
   1262          {
   \                     OS_FlagTaskRdy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1263          #if (OS_CFG_TS_EN == 0u)
   1264              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
   1265          #endif
   1266          
   1267              p_tcb->FlagsRdy   = flags_rdy;
   \   00000004   0x67A1             STR      R1,[R4, #+120]
   1268              p_tcb->PendStatus = OS_STATUS_PEND_OK;                      /* Clear pend status                                    */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF884 0x002D      STRB     R0,[R4, #+45]
   1269              p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;                /* Indicate no longer pending                           */
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF884 0x002C      STRB     R0,[R4, #+44]
   1270          #if (OS_CFG_TS_EN > 0u)
   1271              p_tcb->TS         = ts;
   1272          #endif
   1273              switch (p_tcb->TaskState) {
   \   00000012   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000016   0x1E80             SUBS     R0,R0,#+2
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD903             BLS.N    ??OS_FlagTaskRdy_0
   \   0000001C   0x1F00             SUBS     R0,R0,#+4
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD90E             BLS.N    ??OS_FlagTaskRdy_1
   \   00000022   0xE018             B.N      ??OS_FlagTaskRdy_2
   1274                  case OS_TASK_STATE_PEND:
   1275                  case OS_TASK_STATE_PEND_TIMEOUT:
   1276          #if (OS_CFG_TICK_EN > 0u)
   1277                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \                     ??OS_FlagTaskRdy_0: (+1)
   \   00000024   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000028   0x2803             CMP      R0,#+3
   \   0000002A   0xD102             BNE.N    ??OS_FlagTaskRdy_3
   1278                           OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       OS_TickListRemove
   1279                       }
   1280          #endif
   1281                       OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
   \                     ??OS_FlagTaskRdy_3: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       OS_RdyListInsert
   1282                       p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xF884 0x002E      STRB     R0,[R4, #+46]
   1283                       break;
   \   0000003E   0xE00A             B.N      ??OS_FlagTaskRdy_4
   1284          
   1285                  case OS_TASK_STATE_PEND_SUSPENDED:
   1286                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1287          #if (OS_CFG_TICK_EN > 0u)
   1288                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \                     ??OS_FlagTaskRdy_1: (+1)
   \   00000040   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000044   0x2807             CMP      R0,#+7
   \   00000046   0xD102             BNE.N    ??OS_FlagTaskRdy_5
   1289                           OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       OS_TickListRemove
   1290                       }
   1291          #endif
   1292                       p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_FlagTaskRdy_5: (+1)
   \   0000004E   0x2004             MOVS     R0,#+4
   \   00000050   0xF884 0x002E      STRB     R0,[R4, #+46]
   1293                       break;
   \   00000054   0xE7FF             B.N      ??OS_FlagTaskRdy_4
   1294          
   1295                  case OS_TASK_STATE_RDY:
   1296                  case OS_TASK_STATE_DLY:
   1297                  case OS_TASK_STATE_DLY_SUSPENDED:
   1298                  case OS_TASK_STATE_SUSPENDED:
   1299                  default:
   1300                                                                          /* Default case.                                        */
   1301                       break;
   1302              }
   1303              OS_PendListRemove(p_tcb);
   \                     ??OS_FlagTaskRdy_2: (+1)
   \                     ??OS_FlagTaskRdy_4: (+1)
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       OS_PendListRemove
   1304          }
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x47414C46         DC32     0x47414c46

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x454E4F4E         DC32     0x454e4f4e
   1305          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSFlagCreate
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_PendListInit
      32   OSFlagDel
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_FlagClr
        32   -> OS_PendAbort
      40   OSFlagPend
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_FlagBlock
      32   OSFlagPendAbort
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_PendAbort
      16   OSFlagPendGetFlagsRdy
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      32   OSFlagPost
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_FlagTaskRdy
       8   OS_FlagBlock
         8   -> OS_Pend
       8   OS_FlagClr
         8   -> OS_PendListInit
       8   OS_FlagTaskRdy
         8   -> OS_PendListRemove
         8   -> OS_RdyListInsert
         8   -> OS_TickListRemove


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
      98  OSFlagCreate
     228  OSFlagDel
    1000  OSFlagPend
     214  OSFlagPendAbort
      66  OSFlagPendGetFlagsRdy
     340  OSFlagPost
      36  OS_FlagBlock
      18  OS_FlagClr
      94  OS_FlagTaskRdy

 
 2 118 bytes in section .text
 
 2 118 bytes of CODE memory

Errors: none
Warnings: none
