###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_task.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3C29.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_task.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_task.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_task.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_task.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                            TASK MANAGEMENT
     20          *
     21          * File    : os_task.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          
     30          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     31          const  CPU_CHAR  *os_task__c = "$Id: $";
     32          #endif
     33          
     34          /*
     35          ************************************************************************************************************************
     36          *                                                CHANGE PRIORITY OF A TASK
     37          *
     38          * Description: This function allows you to change the priority of a task dynamically.  Note that the new
     39          *              priority MUST be available.
     40          *
     41          * Arguments  : p_tcb      is the TCB of the tack to change the priority for
     42          *
     43          *              prio_new   is the new priority
     44          *
     45          *              p_err      is a pointer to an error code returned by this function:
     46          *
     47          *                             OS_ERR_NONE                    Is the call was successful
     48          *                             OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
     49          *                             OS_ERR_PRIO_INVALID            If the priority you specify is higher that the maximum allowed
     50          *                                                              (i.e. >= (OS_CFG_PRIO_MAX-1)) or already in use by a kernel
     51          *                                                              task
     52          *                             OS_ERR_STATE_INVALID           If the task is in an invalid state
     53          *                             OS_ERR_TASK_CHANGE_PRIO_ISR    If you tried to change the task's priority from an ISR
     54          *
     55          * Returns    : none
     56          *
     57          * Note(s)    : none
     58          ************************************************************************************************************************
     59          */
     60          
     61          #if (OS_CFG_TASK_CHANGE_PRIO_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
     62          void  OSTaskChangePrio (OS_TCB   *p_tcb,
     63                                  OS_PRIO   prio_new,
     64                                  OS_ERR   *p_err)
     65          {
   \                     OSTaskChangePrio: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
     66          #if (OS_CFG_MUTEX_EN > 0u)
     67              OS_PRIO  prio_high;
     68          #endif
     69              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
     70          
     71          
     72          #ifdef OS_SAFETY_CRITICAL
     73              if (p_err == (OS_ERR *)0) {
     74                  OS_SAFETY_CRITICAL_EXCEPTION();
     75                  return;
     76              }
     77          #endif
     78          
     79          #if (OS_CFG_ARG_CHK_EN > 0u)
     80              if ((p_tcb != (OS_TCB *)0) && (p_tcb->TaskState == OS_TASK_STATE_DEL)) {
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD007             BEQ.N    ??OSTaskChangePrio_0
   \   0000000E   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xD103             BNE.N    ??OSTaskChangePrio_0
     81                 *p_err = OS_ERR_STATE_INVALID;
   \   00000016   0xF646 0x602D      MOVW     R0,#+28205
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
     82                  return;
   \   0000001C   0xE04B             B.N      ??OSTaskChangePrio_1
     83              }
     84          #endif
     85          
     86          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
     87              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \                     ??OSTaskChangePrio_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD003             BEQ.N    ??OSTaskChangePrio_2
     88                 *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
   \   00000028   0xF247 0x1049      MOVW     R0,#+29001
   \   0000002C   0x8030             STRH     R0,[R6, #+0]
     89                  return;
   \   0000002E   0xE042             B.N      ??OSTaskChangePrio_1
     90              }
     91          #endif
     92          
     93              if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {                   /* Cannot set to Idle Task priority                     */
   \                     ??OSTaskChangePrio_2: (+1)
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x283F             CMP      R0,#+63
   \   00000036   0xD303             BCC.N    ??OSTaskChangePrio_3
     94                 *p_err = OS_ERR_PRIO_INVALID;
   \   00000038   0xF246 0x2073      MOVW     R0,#+25203
   \   0000003C   0x8030             STRH     R0,[R6, #+0]
     95                  return;
   \   0000003E   0xE03A             B.N      ??OSTaskChangePrio_1
     96              }
     97          
     98              CPU_CRITICAL_ENTER();
   \                     ??OSTaskChangePrio_3: (+1)
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0007             MOVS     R7,R0
     99          
    100              if (p_tcb == (OS_TCB *)0) {                                 /* Are we changing the priority of 'self'?              */
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD10E             BNE.N    ??OSTaskChangePrio_4
    101                  if (OSRunning != OS_STATE_OS_RUNNING) {
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD006             BEQ.N    ??OSTaskChangePrio_5
    102                      CPU_CRITICAL_EXIT();
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    103                     *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000005C   0xF645 0x6089      MOVW     R0,#+24201
   \   00000060   0x8030             STRH     R0,[R6, #+0]
    104                      return;
   \   00000062   0xE028             B.N      ??OSTaskChangePrio_1
    105                  }
    106                  p_tcb = OSTCBCurPtr;
   \                     ??OSTaskChangePrio_5: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000068   0x6804             LDR      R4,[R0, #+0]
    107              }
    108          
    109          #if (OS_CFG_MUTEX_EN > 0u)
    110              p_tcb->BasePrio = prio_new;                                 /* Update base priority                                 */
   \                     ??OSTaskChangePrio_4: (+1)
   \   0000006A   0xF884 0x5030      STRB     R5,[R4, #+48]
    111          
    112              if (p_tcb->MutexGrpHeadPtr != (OS_MUTEX *)0) {              /* Owning a mutex?                                      */
   \   0000006E   0x6B60             LDR      R0,[R4, #+52]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD00F             BEQ.N    ??OSTaskChangePrio_6
    113                  if (prio_new > p_tcb->Prio) {
   \   00000074   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   00000078   0x0029             MOVS     R1,R5
   \   0000007A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD209             BCS.N    ??OSTaskChangePrio_6
    114                      prio_high = OS_MutexGrpPrioFindHighest(p_tcb);
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
    115                      if (prio_new > prio_high) {
   \   00000086   0x0001             MOVS     R1,R0
   \   00000088   0x002A             MOVS     R2,R5
   \   0000008A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000008E   0x4291             CMP      R1,R2
   \   00000090   0xD200             BCS.N    ??OSTaskChangePrio_6
    116                          prio_new = prio_high;
   \   00000092   0x0005             MOVS     R5,R0
    117                      }
    118                  }
    119              }
    120          #endif
    121          
    122              OS_TaskChangePrio(p_tcb, prio_new);
   \                     ??OSTaskChangePrio_6: (+1)
   \   00000094   0x0029             MOVS     R1,R5
   \   00000096   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       OS_TaskChangePrio
    123          
    124              OS_TRACE_TASK_PRIO_CHANGE(p_tcb, prio_new);
    125              CPU_CRITICAL_EXIT();
   \   0000009E   0x0038             MOVS     R0,R7
   \   000000A0   0x.... 0x....      BL       CPU_SR_Restore
    126          
    127              if (OSRunning == OS_STATE_OS_RUNNING) {
   \   000000A4   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD101             BNE.N    ??OSTaskChangePrio_7
    128                  OSSched();                                              /* Run highest priority task ready                      */
   \   000000AE   0x.... 0x....      BL       OSSched
    129              }
    130          
    131             *p_err = OS_ERR_NONE;
   \                     ??OSTaskChangePrio_7: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x8030             STRH     R0,[R6, #+0]
    132          }
   \                     ??OSTaskChangePrio_1: (+1)
   \   000000B6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    133          #endif
    134          
    135          
    136          /*
    137          ************************************************************************************************************************
    138          *                                                    CREATE A TASK
    139          *
    140          * Description: This function is used to have uC/OS-III manage the execution of a task.  Tasks can either be created
    141          *              prior to the start of multitasking or by a running task.  A task cannot be created by an ISR.
    142          *
    143          * Arguments  : p_tcb          is a pointer to the task's TCB
    144          *
    145          *              p_name         is a pointer to an ASCII string to provide a name to the task.
    146          *
    147          *              p_task         is a pointer to the task's code
    148          *
    149          *              p_arg          is a pointer to an optional data area which can be used to pass parameters to
    150          *                             the task when the task first executes.  Where the task is concerned it thinks
    151          *                             it was invoked and passed the argument 'p_arg' as follows:
    152          *
    153          *                                 void Task (void *p_arg)
    154          *                                 {
    155          *                                     for (;;) {
    156          *                                         Task code;
    157          *                                     }
    158          *                                 }
    159          *
    160          *              prio           is the task's priority.  A unique priority MUST be assigned to each task and the
    161          *                             lower the number, the higher the priority.
    162          *
    163          *              p_stk_base     is a pointer to the base address of the stack (i.e. low address).
    164          *
    165          *              stk_limit      is the number of stack elements to set as 'watermark' limit for the stack.  This value
    166          *                             represents the number of CPU_STK entries left before the stack is full.  For example,
    167          *                             specifying 10% of the 'stk_size' value indicates that the stack limit will be reached
    168          *                             when the stack reaches 90% full.
    169          *
    170          *              stk_size       is the size of the stack in number of elements.  If CPU_STK is set to CPU_INT08U,
    171          *                             'stk_size' corresponds to the number of bytes available.  If CPU_STK is set to
    172          *                             CPU_INT16U, 'stk_size' contains the number of 16-bit entries available.  Finally, if
    173          *                             CPU_STK is set to CPU_INT32U, 'stk_size' contains the number of 32-bit entries
    174          *                             available on the stack.
    175          *
    176          *              q_size         is the maximum number of messages that can be sent to the task
    177          *
    178          *              time_quanta    amount of time (in ticks) for time slice when round-robin between tasks.  Specify 0 to use
    179          *                             the default.
    180          *
    181          *              p_ext          is a pointer to a user supplied memory location which is used as a TCB extension.
    182          *                             For example, this user memory can hold the contents of floating-point registers
    183          *                             during a context switch, the time each task takes to execute, the number of times
    184          *                             the task has been switched-in, etc.
    185          *
    186          *              opt            contains additional information (or options) about the behavior of the task.
    187          *                             See OS_OPT_TASK_xxx in OS.H.  Current choices are:
    188          *
    189          *                                 OS_OPT_TASK_NONE            No option selected
    190          *                                 OS_OPT_TASK_STK_CHK         Stack checking to be allowed for the task
    191          *                                 OS_OPT_TASK_STK_CLR         Clear the stack when the task is created
    192          *                                 OS_OPT_TASK_SAVE_FP         If the CPU has floating-point registers, save them
    193          *                                                             during a context switch.
    194          *                                 OS_OPT_TASK_NO_TLS          If the caller doesn't want or need TLS (Thread Local
    195          *                                                             Storage) support for the task.  If you do not include this
    196          *                                                             option, TLS will be supported by default.
    197          *
    198          *              p_err          is a pointer to an error code that will be set during this call.  The value pointer
    199          *                             to by 'p_err' can be:
    200          *
    201          *                                 OS_ERR_NONE                    If the function was successful
    202          *                                 OS_ERR_ILLEGAL_CREATE_RUN_TIME If you are trying to create the task after you called
    203          *                                                                   OSSafetyCriticalStart()
    204          *                                 OS_ERR_PRIO_INVALID            If the priority you specify is higher that the maximum
    205          *                                                                   allowed (i.e. >= OS_CFG_PRIO_MAX-1) or,
    206          *                                 OS_ERR_STK_OVF                 If the stack was overflowed during stack init
    207          *                                 OS_ERR_STK_INVALID             If you specified a NULL pointer for 'p_stk_base'
    208          *                                 OS_ERR_STK_SIZE_INVALID        If you specified zero for the 'stk_size'
    209          *                                 OS_ERR_STK_LIMIT_INVALID       If you specified a 'stk_limit' greater than or equal
    210          *                                                                   to 'stk_size'
    211          *                                 OS_ERR_TASK_CREATE_ISR         If you tried to create a task from an ISR
    212          *                                 OS_ERR_TASK_INVALID            If you specified a NULL pointer for 'p_task'
    213          *                                 OS_ERR_TCB_INVALID             If you specified a NULL pointer for 'p_tcb'
    214          *
    215          * Returns    : none
    216          *
    217          * Note(s)    : 1) OSTaskCreate() will return with the error OS_ERR_STK_OVF when a stack overflow is detected
    218          *                 during stack initialization. In that specific case some memory may have been corrupted. It is
    219          *                 therefore recommended to treat OS_ERR_STK_OVF as a fatal error.
    220          ************************************************************************************************************************
    221          */
    222          

   \                                 In section .text, align 2, keep-with-next
    223          void  OSTaskCreate (OS_TCB        *p_tcb,
    224                              CPU_CHAR      *p_name,
    225                              OS_TASK_PTR    p_task,
    226                              void          *p_arg,
    227                              OS_PRIO        prio,
    228                              CPU_STK       *p_stk_base,
    229                              CPU_STK_SIZE   stk_limit,
    230                              CPU_STK_SIZE   stk_size,
    231                              OS_MSG_QTY     q_size,
    232                              OS_TICK        time_quanta,
    233                              void          *p_ext,
    234                              OS_OPT         opt,
    235                              OS_ERR        *p_err)
    236          {
   \                     OSTaskCreate: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x001E             MOVS     R6,R3
   \   00000006   0xF8DD 0x8050      LDR      R8,[SP, #+80]
    237              CPU_STK_SIZE   i;
    238          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    239              OS_REG_ID      reg_nbr;
    240          #endif
    241          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    242              OS_TLS_ID      id;
    243          #endif
    244          
    245              CPU_STK       *p_sp;
    246              CPU_STK       *p_stk_limit;
    247              CPU_SR_ALLOC();
   \   0000000A   0x2100             MOVS     R1,#+0
    248          
    249          
    250          
    251          #ifdef OS_SAFETY_CRITICAL
    252              if (p_err == (OS_ERR *)0) {
    253                  OS_SAFETY_CRITICAL_EXCEPTION();
    254                  return;
    255              }
    256          #endif
    257          
    258          #ifdef OS_SAFETY_CRITICAL_IEC61508
    259              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    260                 *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
    261                  return;
    262              }
    263          #endif
    264          
    265          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    266              if (OSIntNestingCtr > 0u) {                                 /* --------- CANNOT CREATE A TASK FROM AN ISR --------- */
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000010   0x7809             LDRB     R1,[R1, #+0]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD004             BEQ.N    ??OSTaskCreate_0
    267                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    268                 *p_err = OS_ERR_TASK_CREATE_ISR;
   \   00000016   0xF247 0x104A      MOVW     R0,#+29002
   \   0000001A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    269                  return;
   \   0000001E   0xE0C2             B.N      ??OSTaskCreate_1
    270              }
   \                     ??OSTaskCreate_0: (+1)
   \   00000020   0x0004             MOVS     R4,R0
    271          #endif
    272          
    273          #if (OS_CFG_ARG_CHK_EN > 0u)                                    /* ---------------- VALIDATE ARGUMENTS ---------------- */
    274              if (p_tcb == (OS_TCB *)0) {                                 /* User must supply a valid OS_TCB                      */
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??OSTaskCreate_2
    275                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    276                 *p_err = OS_ERR_TCB_INVALID;
   \   00000026   0xF247 0x10AD      MOVW     R0,#+29101
   \   0000002A   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    277                  return;
   \   0000002E   0xE0BA             B.N      ??OSTaskCreate_1
    278              }
   \                     ??OSTaskCreate_2: (+1)
   \   00000030   0x9202             STR      R2,[SP, #+8]
    279              if (p_task == (OS_TASK_PTR)0u) {                            /* User must supply a valid task                        */
   \   00000032   0x9802             LDR      R0,[SP, #+8]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD104             BNE.N    ??OSTaskCreate_3
    280                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    281                 *p_err = OS_ERR_TASK_INVALID;
   \   00000038   0xF247 0x104F      MOVW     R0,#+29007
   \   0000003C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    282                  return;
   \   00000040   0xE0B1             B.N      ??OSTaskCreate_1
    283              }
   \                     ??OSTaskCreate_3: (+1)
   \   00000042   0x9D0D             LDR      R5,[SP, #+52]
    284              if (p_stk_base == (CPU_STK *)0) {                           /* User must supply a valid stack base address          */
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD104             BNE.N    ??OSTaskCreate_4
    285                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    286                 *p_err = OS_ERR_STK_INVALID;
   \   00000048   0xF646 0x602F      MOVW     R0,#+28207
   \   0000004C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    287                  return;
   \   00000050   0xE0A9             B.N      ??OSTaskCreate_1
    288              }
   \                     ??OSTaskCreate_4: (+1)
   \   00000052   0xF8DD 0xA03C      LDR      R10,[SP, #+60]
    289              if (stk_size < OSCfg_StkSizeMin) {                          /* User must supply a valid minimum stack size          */
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable14
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x4582             CMP      R10,R0
   \   0000005E   0xD204             BCS.N    ??OSTaskCreate_5
    290                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    291                 *p_err = OS_ERR_STK_SIZE_INVALID;
   \   00000060   0xF646 0x6030      MOVW     R0,#+28208
   \   00000064   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    292                  return;
   \   00000068   0xE09D             B.N      ??OSTaskCreate_1
    293              }
   \                     ??OSTaskCreate_5: (+1)
   \   0000006A   0xF8DD 0xB038      LDR      R11,[SP, #+56]
    294              if (stk_limit >= stk_size) {                                /* User must supply a valid stack limit                 */
   \   0000006E   0x45D3             CMP      R11,R10
   \   00000070   0xD304             BCC.N    ??OSTaskCreate_6
    295                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    296                 *p_err = OS_ERR_STK_LIMIT_INVALID;
   \   00000072   0xF646 0x6031      MOVW     R0,#+28209
   \   00000076   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    297                  return;
   \   0000007A   0xE094             B.N      ??OSTaskCreate_1
    298              }
   \                     ??OSTaskCreate_6: (+1)
   \   0000007C   0x9F0C             LDR      R7,[SP, #+48]
    299              if ((prio  > (OS_CFG_PRIO_MAX - 2u)) &&                     /* Priority must be within 0 and OS_CFG_PRIO_MAX-1      */
    300                  (prio != (OS_CFG_PRIO_MAX - 1u))) {
   \   0000007E   0x0038             MOVS     R0,R7
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x283F             CMP      R0,#+63
   \   00000084   0xD308             BCC.N    ??OSTaskCreate_7
   \   00000086   0x0038             MOVS     R0,R7
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0x283F             CMP      R0,#+63
   \   0000008C   0xD004             BEQ.N    ??OSTaskCreate_7
    301                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    302                 *p_err = OS_ERR_PRIO_INVALID;
   \   0000008E   0xF246 0x2073      MOVW     R0,#+25203
   \   00000092   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    303                  return;
   \   00000096   0xE086             B.N      ??OSTaskCreate_1
    304              }
    305          #endif
    306          
    307              if (prio == (OS_CFG_PRIO_MAX - 1u)) {
   \                     ??OSTaskCreate_7: (+1)
   \   00000098   0x0038             MOVS     R0,R7
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x283F             CMP      R0,#+63
   \   0000009E   0xD108             BNE.N    ??OSTaskCreate_8
    308          #if (OS_CFG_TASK_IDLE_EN > 0u)
    309                  if (p_tcb != &OSIdleTaskTCB) {
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000A4   0x4284             CMP      R4,R0
   \   000000A6   0xD004             BEQ.N    ??OSTaskCreate_8
    310                      OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    311                     *p_err = OS_ERR_PRIO_INVALID;                        /* Not allowed to use same priority as idle task        */
   \   000000A8   0xF246 0x2073      MOVW     R0,#+25203
   \   000000AC   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    312                      return;
   \   000000B0   0xE079             B.N      ??OSTaskCreate_1
    313                  }
    314          #else
    315                  OS_TRACE_TASK_CREATE_FAILED(p_tcb);
    316                 *p_err = OS_ERR_PRIO_INVALID;                            /* Not allowed to use same priority as idle task        */
    317                  return;
    318          #endif
    319              }
   \                     ??OSTaskCreate_8: (+1)
   \   000000B2   0xF8DD 0x904C      LDR      R9,[SP, #+76]
    320          
    321              OS_TaskInitTCB(p_tcb);                                      /* Initialize the TCB to default values                 */
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       OS_TaskInitTCB
    322          
    323             *p_err = OS_ERR_NONE;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    324                                                                          /* -------------- CLEAR THE TASK'S STACK -------------- */
    325              if (((opt & OS_OPT_TASK_STK_CHK) != 0u) ||                  /* See if stack checking has been enabled               */
    326                  ((opt & OS_OPT_TASK_STK_CLR) != 0u)) {                  /* See if stack needs to be cleared                     */
   \   000000C2   0xF019 0x0F03      TST      R9,#0x3
   \   000000C6   0xD00C             BEQ.N    ??OSTaskCreate_9
    327                  if ((opt & OS_OPT_TASK_STK_CLR) != 0u) {
   \   000000C8   0x4648             MOV      R0,R9
   \   000000CA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CC   0x0780             LSLS     R0,R0,#+30
   \   000000CE   0xD508             BPL.N    ??OSTaskCreate_9
    328                      p_sp = p_stk_base;
   \   000000D0   0x0029             MOVS     R1,R5
    329                      for (i = 0u; i < stk_size; i++) {                   /* Stack grows from HIGH to LOW memory                  */
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xE003             B.N      ??OSTaskCreate_10
    330                         *p_sp = 0u;                                      /* Clear from bottom of stack and up!                   */
   \                     ??OSTaskCreate_11: (+1)
   \   000000D6   0x2200             MOVS     R2,#+0
   \   000000D8   0x600A             STR      R2,[R1, #+0]
    331                          p_sp++;
   \   000000DA   0x1D09             ADDS     R1,R1,#+4
    332                      }
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \                     ??OSTaskCreate_10: (+1)
   \   000000DE   0x4550             CMP      R0,R10
   \   000000E0   0xD3F9             BCC.N    ??OSTaskCreate_11
   \                     ??OSTaskCreate_9: (+1)
   \   000000E2   0x0031             MOVS     R1,R6
    333                  }
    334              }
    335                                                                          /* ------ INITIALIZE THE STACK FRAME OF THE TASK ------ */
    336          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    337              p_stk_limit = p_stk_base + stk_limit;
   \   000000E4   0xEB05 0x068B      ADD      R6,R5,R11, LSL #+2
    338          #else
    339              p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
    340          #endif
    341          
    342              p_sp = OSTaskStkInit(p_task,
    343                                   p_arg,
    344                                   p_stk_base,
    345                                   p_stk_limit,
    346                                   stk_size,
    347                                   opt);
   \   000000E8   0x4648             MOV      R0,R9
   \   000000EA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EC   0x9001             STR      R0,[SP, #+4]
   \   000000EE   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   000000F2   0x0033             MOVS     R3,R6
   \   000000F4   0x002A             MOVS     R2,R5
   \   000000F6   0x9802             LDR      R0,[SP, #+8]
   \   000000F8   0x.... 0x....      BL       OSTaskStkInit
   \   000000FC   0x0001             MOVS     R1,R0
    348          
    349          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)             /* Check if we overflown the stack during init          */
    350              if (p_sp < p_stk_base) {
   \   000000FE   0x42A9             CMP      R1,R5
   \   00000100   0xD204             BCS.N    ??OSTaskCreate_12
    351                 *p_err = OS_ERR_STK_OVF;
   \   00000102   0xF646 0x6032      MOVW     R0,#+28210
   \   00000106   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    352                  return;
   \   0000010A   0xE04C             B.N      ??OSTaskCreate_1
    353              }
   \                     ??OSTaskCreate_12: (+1)
   \   0000010C   0x9811             LDR      R0,[SP, #+68]
    354          #else
    355              if (p_sp > (p_stk_base + stk_size)) {
    356                 *p_err = OS_ERR_STK_OVF;
    357                  return;
    358              }
    359          #endif
    360          
    361          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)                           /* Initialize Redzoned stack                            */
    362              OS_TaskStkRedzoneInit(p_stk_base, stk_size);
    363          #endif
    364          
    365                                                                          /* ------------ INITIALIZE THE TCB FIELDS ------------- */
    366          #if (OS_CFG_DBG_EN > 0u)
    367              p_tcb->TaskEntryAddr = p_task;                              /* Save task entry point address                        */
    368              p_tcb->TaskEntryArg  = p_arg;                               /* Save task entry argument                             */
    369          #endif
    370          
    371          #if (OS_CFG_DBG_EN > 0u)
    372              p_tcb->NamePtr       = p_name;                              /* Save task name                                       */
    373          #else
    374              (void)p_name;
    375          #endif
    376          
    377              p_tcb->Prio          = prio;                                /* Save the task's priority                             */
   \   0000010E   0xF884 0x702F      STRB     R7,[R4, #+47]
    378          
    379          #if (OS_CFG_MUTEX_EN > 0u)
    380              p_tcb->BasePrio      = prio;                                /* Set the base priority                                */
   \   00000112   0xF884 0x7030      STRB     R7,[R4, #+48]
    381          #endif
    382          
    383              p_tcb->StkPtr        = p_sp;                                /* Save the new top-of-stack pointer                    */
   \   00000116   0x6021             STR      R1,[R4, #+0]
    384              p_tcb->StkLimitPtr   = p_stk_limit;                         /* Save the stack limit pointer                         */
   \   00000118   0x60A6             STR      R6,[R4, #+8]
    385          
    386          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)
    387              p_tcb->TimeQuanta    = time_quanta;                         /* Save the #ticks for time slice (0 means not sliced)  */
   \   0000011A   0x64E0             STR      R0,[R4, #+76]
    388              if (time_quanta == 0u) {
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD104             BNE.N    ??OSTaskCreate_13
    389                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x6520             STR      R0,[R4, #+80]
   \   00000128   0xE000             B.N      ??OSTaskCreate_14
    390              } else {
    391                  p_tcb->TimeQuantaCtr = time_quanta;
   \                     ??OSTaskCreate_13: (+1)
   \   0000012A   0x6520             STR      R0,[R4, #+80]
   \                     ??OSTaskCreate_14: (+1)
   \   0000012C   0x9812             LDR      R0,[SP, #+72]
    392              }
    393          #else
    394              (void)time_quanta;
    395          #endif
    396          
    397              p_tcb->ExtPtr        = p_ext;                               /* Save pointer to TCB extension                        */
   \   0000012E   0x6060             STR      R0,[R4, #+4]
    398          #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u) || (OS_CFG_TASK_STK_REDZONE_EN > 0u))
    399              p_tcb->StkBasePtr    = p_stk_base;                          /* Save pointer to the base address of the stack        */
   \   00000130   0x61E5             STR      R5,[R4, #+28]
    400              p_tcb->StkSize       = stk_size;                            /* Save the stack size (in number of CPU_STK elements)  */
   \   00000132   0xF8C4 0xA038      STR      R10,[R4, #+56]
    401          #endif
    402              p_tcb->Opt           = opt;                                 /* Save task options                                    */
   \   00000136   0xF8A4 0x903C      STRH     R9,[R4, #+60]
    403          
    404          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    405              for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
   \   0000013A   0x2100             MOVS     R1,#+0
   \   0000013C   0xE006             B.N      ??OSTaskCreate_15
    406                  p_tcb->RegTbl[reg_nbr] = 0u;
   \                     ??OSTaskCreate_16: (+1)
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x000A             MOVS     R2,R1
   \   00000142   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000144   0xEB04 0x0282      ADD      R2,R4,R2, LSL #+2
   \   00000148   0x6710             STR      R0,[R2, #+112]
    407              }
   \   0000014A   0x1C49             ADDS     R1,R1,#+1
   \                     ??OSTaskCreate_15: (+1)
   \   0000014C   0x0008             MOVS     R0,R1
   \   0000014E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000150   0x2800             CMP      R0,#+0
   \   00000152   0xD0F4             BEQ.N    ??OSTaskCreate_16
   \   00000154   0x9910             LDR      R1,[SP, #+64]
    408          #endif
    409          
    410          #if (OS_CFG_TASK_Q_EN > 0u)
    411              OS_MsgQInit(&p_tcb->MsgQ,                                   /* Initialize the task's message queue                  */
    412                          q_size);
   \   00000156   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000158   0xF114 0x005C      ADDS     R0,R4,#+92
   \   0000015C   0x.... 0x....      BL       OS_MsgQInit
    413          #else
    414              (void)q_size;
    415          #endif
    416          
    417              OSTaskCreateHook(p_tcb);                                    /* Call user defined hook                               */
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x.... 0x....      BL       OSTaskCreateHook
    418          
    419              OS_TRACE_TASK_CREATE(p_tcb);
    420              OS_TRACE_TASK_SEM_CREATE(p_tcb, p_name);
    421          #if (OS_CFG_TASK_Q_EN > 0u)
    422              OS_TRACE_TASK_MSG_Q_CREATE(&p_tcb->MsgQ, p_name);
    423          #endif
    424          
    425          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    426              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
    427                  p_tcb->TLS_Tbl[id] = 0u;
    428              }
    429              OS_TLS_TaskCreate(p_tcb);                                   /* Call TLS hook                                        */
    430          #endif
    431                                                                          /* -------------- ADD TASK TO READY LIST -------------- */
    432              CPU_CRITICAL_ENTER();
   \   00000166   0x2040             MOVS     R0,#+64
   \   00000168   0x.... 0x....      BL       CPU_SR_Save
   \   0000016C   0x0005             MOVS     R5,R0
    433              OS_PrioInsert(p_tcb->Prio);
   \   0000016E   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   00000172   0x.... 0x....      BL       OS_PrioInsert
    434              OS_RdyListInsertTail(p_tcb);
   \   00000176   0x0020             MOVS     R0,R4
   \   00000178   0x.... 0x....      BL       OS_RdyListInsertTail
    435          
    436          #if (OS_CFG_DBG_EN > 0u)
    437              OS_TaskDbgListAdd(p_tcb);
    438          #endif
    439          
    440              OSTaskQty++;                                                /* Increment the #tasks counter                         */
   \   0000017C   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000180   0x8800             LDRH     R0,[R0, #+0]
   \   00000182   0x1C40             ADDS     R0,R0,#+1
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   00000188   0x8008             STRH     R0,[R1, #+0]
    441          
    442              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Return if multitasking has not started               */
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000018E   0x7800             LDRB     R0,[R0, #+0]
   \   00000190   0x2801             CMP      R0,#+1
   \   00000192   0xD003             BEQ.N    ??OSTaskCreate_17
    443                  CPU_CRITICAL_EXIT();
   \   00000194   0x0028             MOVS     R0,R5
   \   00000196   0x.... 0x....      BL       CPU_SR_Restore
    444                  return;
   \   0000019A   0xE004             B.N      ??OSTaskCreate_1
    445              }
    446          
    447              CPU_CRITICAL_EXIT();
   \                     ??OSTaskCreate_17: (+1)
   \   0000019C   0x0028             MOVS     R0,R5
   \   0000019E   0x.... 0x....      BL       CPU_SR_Restore
    448          
    449              OSSched();
   \   000001A2   0x.... 0x....      BL       OSSched
    450          }
   \                     ??OSTaskCreate_1: (+1)
   \   000001A6   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    451          
    452          
    453          /*
    454          ************************************************************************************************************************
    455          *                                                     DELETE A TASK
    456          *
    457          * Description: This function allows you to delete a task.  The calling task can delete itself by specifying a NULL
    458          *              pointer for 'p_tcb'.  The deleted task is returned to the dormant state and can be re-activated by
    459          *              creating the deleted task again.
    460          *
    461          * Arguments  : p_tcb      is the TCB of the tack to delete
    462          *
    463          *              p_err      is a pointer to an error code returned by this function:
    464          *
    465          *                             OS_ERR_NONE                    If the call is successful
    466          *                             OS_ERR_ILLEGAL_DEL_RUN_TIME    If you are trying to delete the task after you called
    467          *                                                              OSStart()
    468          *                             OS_ERR_OS_NOT_RUNNING          If uC/OS-III is not running yet
    469          *                             OS_ERR_STATE_INVALID           If the state of the task is invalid
    470          *                             OS_ERR_TASK_DEL_IDLE           If you attempted to delete uC/OS-III's idle task
    471          *                             OS_ERR_TASK_DEL_INVALID        If you attempted to delete uC/OS-III's ISR handler task
    472          *                             OS_ERR_TASK_DEL_ISR            If you tried to delete a task from an ISR
    473          *
    474          * Returns    : none
    475          *
    476          * Note(s)    : 1) 'p_err' gets set to OS_ERR_NONE before OSSched() to allow the returned err or code to be monitored even
    477          *                 for a task that is deleting itself. In this case, 'p_err' MUST point to a global variable that can be
    478          *                 accessed by another task.
    479          ************************************************************************************************************************
    480          */
    481          
    482          #if (OS_CFG_TASK_DEL_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    483          void  OSTaskDel (OS_TCB  *p_tcb,
    484                           OS_ERR  *p_err)
    485          {
   \                     OSTaskDel: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    486          #if (OS_CFG_MUTEX_EN > 0u)
    487              OS_TCB   *p_tcb_owner;
    488              OS_PRIO   prio_new;
    489          #endif
    490              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
    491          
    492          
    493          #ifdef OS_SAFETY_CRITICAL
    494              if (p_err == (OS_ERR *)0) {
    495                  OS_SAFETY_CRITICAL_EXCEPTION();
    496                  return;
    497              }
    498          #endif
    499          
    500          #ifdef OS_SAFETY_CRITICAL_IEC61508
    501              if (OSSafetyCriticalStartFlag == OS_TRUE) {
    502                 *p_err = OS_ERR_ILLEGAL_DEL_RUN_TIME;
    503                  return;
    504              }
    505          #endif
    506          
    507          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    508              if (OSIntNestingCtr > 0u) {                                 /* See if trying to delete from ISR                     */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSTaskDel_0
    509                 *p_err = OS_ERR_TASK_DEL_ISR;
   \   00000014   0xF247 0x104E      MOVW     R0,#+29006
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    510                  return;
   \   0000001A   0xE052             B.N      ??OSTaskDel_1
    511              }
    512          #endif
    513          
    514          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    515              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskDel_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD003             BEQ.N    ??OSTaskDel_2
    516                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    517                  return;
   \   0000002C   0xE049             B.N      ??OSTaskDel_1
    518              }
    519          #endif
    520          
    521          #if (OS_CFG_TASK_IDLE_EN > 0u)
    522              if (p_tcb == &OSIdleTaskTCB) {                              /* Not allowed to delete the idle task                  */
   \                     ??OSTaskDel_2: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000032   0x4284             CMP      R4,R0
   \   00000034   0xD103             BNE.N    ??OSTaskDel_3
    523                 *p_err = OS_ERR_TASK_DEL_IDLE;
   \   00000036   0xF247 0x104C      MOVW     R0,#+29004
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
    524                  return;
   \   0000003C   0xE041             B.N      ??OSTaskDel_1
    525              }
    526          #endif
    527          
    528              if (p_tcb == (OS_TCB *)0) {                                 /* Delete 'Self'?                                       */
   \                     ??OSTaskDel_3: (+1)
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD107             BNE.N    ??OSTaskDel_4
    529                  CPU_CRITICAL_ENTER();
   \   00000042   0x2040             MOVS     R0,#+64
   \   00000044   0x.... 0x....      BL       CPU_SR_Save
    530                  p_tcb  = OSTCBCurPtr;                                   /* Yes.                                                 */
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000004C   0x680C             LDR      R4,[R1, #+0]
    531                  CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Restore
    532              }
    533          
    534              CPU_CRITICAL_ENTER();
   \                     ??OSTaskDel_4: (+1)
   \   00000052   0x2040             MOVS     R0,#+64
   \   00000054   0x.... 0x....      BL       CPU_SR_Save
   \   00000058   0x0006             MOVS     R6,R0
    535              switch (p_tcb->TaskState) {
   \   0000005A   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD00B             BEQ.N    ??OSTaskDel_5
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD034             BEQ.N    ??OSTaskDel_6
   \   00000066   0xD32F             BCC.N    ??OSTaskDel_7
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xD02C             BEQ.N    ??OSTaskDel_8
   \   0000006C   0xD330             BCC.N    ??OSTaskDel_6
   \   0000006E   0x2806             CMP      R0,#+6
   \   00000070   0xD02E             BEQ.N    ??OSTaskDel_6
   \   00000072   0xD329             BCC.N    ??OSTaskDel_7
   \   00000074   0x2807             CMP      R0,#+7
   \   00000076   0xD02B             BEQ.N    ??OSTaskDel_6
   \   00000078   0xE07A             B.N      ??OSTaskDel_9
    536                  case OS_TASK_STATE_RDY:
    537                       OS_RdyListRemove(p_tcb);
   \                     ??OSTaskDel_5: (+1)
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       OS_RdyListRemove
    538                       break;
    539          
    540                  case OS_TASK_STATE_SUSPENDED:
    541                       break;
    542          
    543                  case OS_TASK_STATE_DLY:                                 /* Task is only delayed, not on any wait list           */
    544                  case OS_TASK_STATE_DLY_SUSPENDED:
    545          #if (OS_CFG_TICK_EN > 0u)
    546                       OS_TickListRemove(p_tcb);
    547          #endif
    548                       break;
    549          
    550                  case OS_TASK_STATE_PEND:
    551                  case OS_TASK_STATE_PEND_SUSPENDED:
    552                  case OS_TASK_STATE_PEND_TIMEOUT:
    553                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
    554                       switch (p_tcb->PendOn) {                           /* See what we are pending on                           */
    555                           case OS_TASK_PEND_ON_NOTHING:
    556                           case OS_TASK_PEND_ON_TASK_Q:                   /* There is no wait list for these two                  */
    557                           case OS_TASK_PEND_ON_TASK_SEM:
    558                                break;
    559          
    560                           case OS_TASK_PEND_ON_FLAG:                     /* Remove from pend list                                */
    561                           case OS_TASK_PEND_ON_Q:
    562                           case OS_TASK_PEND_ON_SEM:
    563                                OS_PendListRemove(p_tcb);
    564                                break;
    565          
    566          #if (OS_CFG_MUTEX_EN > 0u)
    567                           case OS_TASK_PEND_ON_MUTEX:
    568                                p_tcb_owner = ((OS_MUTEX *)((void *)p_tcb->PendObjPtr))->OwnerTCBPtr;
    569                                prio_new = p_tcb_owner->Prio;
    570                                OS_PendListRemove(p_tcb);
    571                                if ((p_tcb_owner->Prio != p_tcb_owner->BasePrio) &&
    572                                    (p_tcb_owner->Prio == p_tcb->Prio)) { /* Has the owner inherited a priority?                  */
    573                                    prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
    574                                    prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
    575                                }
    576                                p_tcb->PendOn = OS_TASK_PEND_ON_NOTHING;
    577          
    578                                if (prio_new != p_tcb_owner->Prio) {
    579                                    OS_TaskChangePrio(p_tcb_owner, prio_new);
    580                                    OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, p_tcb_owner->Prio);
    581                                }
    582                                break;
    583          #endif
    584          
    585                           default:
    586                                                                          /* Default case.                                        */
    587                                break;
    588                       }
    589          #if (OS_CFG_TICK_EN > 0u)
    590                       if ((p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) ||
    591                           (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED)) {
    592                           OS_TickListRemove(p_tcb);
    593                       }
    594          #endif
    595                       break;
    596          
    597                  default:
    598                      CPU_CRITICAL_EXIT();
    599                     *p_err = OS_ERR_STATE_INVALID;
    600                      return;
    601              }
    602          
    603          #if (OS_CFG_MUTEX_EN > 0u)
    604              if(p_tcb->MutexGrpHeadPtr != (OS_MUTEX *)0) {
   \                     ??OSTaskDel_10: (+1)
   \   00000080   0x6B60             LDR      R0,[R4, #+52]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD002             BEQ.N    ??OSTaskDel_11
    605                  OS_MutexGrpPostAll(p_tcb);
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       OS_MutexGrpPostAll
    606              }
    607          #endif
    608          
    609          #if (OS_CFG_TASK_Q_EN > 0u)
    610              (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                         /* Free task's message queue messages                   */
   \                     ??OSTaskDel_11: (+1)
   \   0000008C   0xF114 0x005C      ADDS     R0,R4,#+92
   \   00000090   0x.... 0x....      BL       OS_MsgQFreeAll
    611          #endif
    612          
    613              OSTaskDelHook(p_tcb);                                       /* Call user defined hook                               */
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x.... 0x....      BL       OSTaskDelHook
    614          
    615          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    616              OS_TLS_TaskDel(p_tcb);                                      /* Call TLS hook                                        */
    617          #endif
    618          
    619          #if (OS_CFG_DBG_EN > 0u)
    620              OS_TaskDbgListRemove(p_tcb);
    621          #endif
    622          
    623              OSTaskQty--;                                                /* One less task being managed                          */
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000009E   0x8800             LDRH     R0,[R0, #+0]
   \   000000A0   0x1E40             SUBS     R0,R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   000000A6   0x8008             STRH     R0,[R1, #+0]
    624          
    625              OS_TRACE_TASK_DEL(p_tcb);
    626          
    627          #if (OS_CFG_TASK_STK_REDZONE_EN == 0u)                          /* Don't clear the TCB before checking the red-zone     */
    628              OS_TaskInitTCB(p_tcb);                                      /* Initialize the TCB to default values                 */
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       OS_TaskInitTCB
    629          #endif
    630              p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;             /* Indicate that the task was deleted                   */
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0xF884 0x002E      STRB     R0,[R4, #+46]
    631          
    632             *p_err = OS_ERR_NONE;                                        /* See Note #1.                                         */
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x8028             STRH     R0,[R5, #+0]
    633              CPU_CRITICAL_EXIT();
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    634          
    635              OSSched();                                                  /* Find new highest priority task                       */
   \   000000BE   0x.... 0x....      BL       OSSched
    636          }
   \                     ??OSTaskDel_1: (+1)
   \   000000C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??OSTaskDel_8: (+1)
   \   000000C6   0xE7DB             B.N      ??OSTaskDel_10
   \                     ??OSTaskDel_7: (+1)
   \   000000C8   0x0020             MOVS     R0,R4
   \   000000CA   0x.... 0x....      BL       OS_TickListRemove
   \   000000CE   0xE7D7             B.N      ??OSTaskDel_10
   \                     ??OSTaskDel_6: (+1)
   \   000000D0   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD00B             BEQ.N    ??OSTaskDel_12
   \   000000D8   0x2801             CMP      R0,#+1
   \   000000DA   0xD00A             BEQ.N    ??OSTaskDel_13
   \   000000DC   0x2802             CMP      R0,#+2
   \   000000DE   0xD007             BEQ.N    ??OSTaskDel_12
   \   000000E0   0x2804             CMP      R0,#+4
   \   000000E2   0xD00A             BEQ.N    ??OSTaskDel_14
   \   000000E4   0x2805             CMP      R0,#+5
   \   000000E6   0xD004             BEQ.N    ??OSTaskDel_13
   \   000000E8   0x2806             CMP      R0,#+6
   \   000000EA   0xD002             BEQ.N    ??OSTaskDel_13
   \   000000EC   0x2807             CMP      R0,#+7
   \   000000EE   0xD133             BNE.N    ??OSTaskDel_15
   \                     ??OSTaskDel_12: (+1)
   \   000000F0   0xE032             B.N      ??OSTaskDel_16
   \                     ??OSTaskDel_13: (+1)
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       OS_PendListRemove
   \   000000F8   0xE02E             B.N      ??OSTaskDel_16
   \                     ??OSTaskDel_14: (+1)
   \   000000FA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000FC   0x6907             LDR      R7,[R0, #+16]
   \   000000FE   0xF897 0x802F      LDRB     R8,[R7, #+47]
   \   00000102   0x0020             MOVS     R0,R4
   \   00000104   0x.... 0x....      BL       OS_PendListRemove
   \   00000108   0xF897 0x002F      LDRB     R0,[R7, #+47]
   \   0000010C   0xF897 0x1030      LDRB     R1,[R7, #+48]
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xD012             BEQ.N    ??OSTaskDel_17
   \   00000114   0xF897 0x002F      LDRB     R0,[R7, #+47]
   \   00000118   0xF894 0x102F      LDRB     R1,[R4, #+47]
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD10C             BNE.N    ??OSTaskDel_17
   \   00000120   0x0038             MOVS     R0,R7
   \   00000122   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   00000126   0x4680             MOV      R8,R0
   \   00000128   0xF897 0x0030      LDRB     R0,[R7, #+48]
   \   0000012C   0x4641             MOV      R1,R8
   \   0000012E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000130   0x4288             CMP      R0,R1
   \   00000132   0xD202             BCS.N    ??OSTaskDel_18
   \   00000134   0xF897 0x8030      LDRB     R8,[R7, #+48]
   \   00000138   0xE7FF             B.N      ??OSTaskDel_17
   \                     ??OSTaskDel_18: (+1)
   \                     ??OSTaskDel_17: (+1)
   \   0000013A   0x2000             MOVS     R0,#+0
   \   0000013C   0xF884 0x002C      STRB     R0,[R4, #+44]
   \   00000140   0x4640             MOV      R0,R8
   \   00000142   0xF897 0x102F      LDRB     R1,[R7, #+47]
   \   00000146   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000148   0x4288             CMP      R0,R1
   \   0000014A   0xD004             BEQ.N    ??OSTaskDel_19
   \   0000014C   0x4641             MOV      R1,R8
   \   0000014E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000150   0x0038             MOVS     R0,R7
   \   00000152   0x.... 0x....      BL       OS_TaskChangePrio
   \                     ??OSTaskDel_19: (+1)
   \   00000156   0xE7FF             B.N      ??OSTaskDel_16
   \                     ??OSTaskDel_15: (+1)
   \                     ??OSTaskDel_16: (+1)
   \   00000158   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000015C   0x2803             CMP      R0,#+3
   \   0000015E   0xD003             BEQ.N    ??OSTaskDel_20
   \   00000160   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000164   0x2807             CMP      R0,#+7
   \   00000166   0xD102             BNE.N    ??OSTaskDel_21
   \                     ??OSTaskDel_20: (+1)
   \   00000168   0x0020             MOVS     R0,R4
   \   0000016A   0x.... 0x....      BL       OS_TickListRemove
   \                     ??OSTaskDel_21: (+1)
   \   0000016E   0xE787             B.N      ??OSTaskDel_10
   \                     ??OSTaskDel_9: (+1)
   \   00000170   0x0030             MOVS     R0,R6
   \   00000172   0x.... 0x....      BL       CPU_SR_Restore
   \   00000176   0xF646 0x602D      MOVW     R0,#+28205
   \   0000017A   0x8028             STRH     R0,[R5, #+0]
   \   0000017C   0xE7A1             B.N      ??OSTaskDel_1
    637          #endif
    638          
    639          
    640          /*
    641          ************************************************************************************************************************
    642          *                                                    FLUSH TASK's QUEUE
    643          *
    644          * Description: This function is used to flush the task's internal message queue.
    645          *
    646          * Arguments  : p_tcb       is a pointer to the task's OS_TCB.  Specifying a NULL pointer indicates that you wish to
    647          *                          flush the message queue of the calling task.
    648          *
    649          *              p_err       is a pointer to a variable that will contain an error code returned by this function.
    650          *
    651          *                              OS_ERR_NONE              Upon success
    652          *                              OS_ERR_FLUSH_ISR         If you called this function from an ISR
    653          *                              OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
    654          *
    655          * Returns     : The number of entries freed from the queue
    656          *
    657          * Note(s)     : 1) You should use this function with great care because, when to flush the queue, you LOOSE the
    658          *                  references to what the queue entries are pointing to and thus, you could cause 'memory leaks'.  In
    659          *                  other words, the data you are pointing to that's being referenced by the queue entries should, most
    660          *                  likely, need to be de-allocated (i.e. freed).
    661          ************************************************************************************************************************
    662          */
    663          
    664          #if (OS_CFG_TASK_Q_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    665          OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
    666                                    OS_ERR  *p_err)
    667          {
   \                     OSTaskQFlush: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    668              OS_MSG_QTY  entries;
    669              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
    670          
    671          
    672          #ifdef OS_SAFETY_CRITICAL
    673              if (p_err == (OS_ERR *)0) {
    674                  OS_SAFETY_CRITICAL_EXCEPTION();
    675                  return (0u);
    676              }
    677          #endif
    678          
    679          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    680              if (OSIntNestingCtr > 0u) {                                 /* Can't flush a message queue from an ISR              */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskQFlush_0
    681                 *p_err = OS_ERR_FLUSH_ISR;
   \   00000012   0xF44F 0x506C      MOV      R0,#+15104
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    682                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE023             B.N      ??OSTaskQFlush_1
    683              }
    684          #endif
    685          
    686          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    687              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskQFlush_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD004             BEQ.N    ??OSTaskQFlush_2
    688                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000026   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002A   0x8028             STRH     R0,[R5, #+0]
    689                  return (0u);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE019             B.N      ??OSTaskQFlush_1
    690              }
    691          #endif
    692          
    693              if (p_tcb == (OS_TCB *)0) {                                 /* Flush message queue of calling task?                 */
   \                     ??OSTaskQFlush_2: (+1)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD107             BNE.N    ??OSTaskQFlush_3
    694                  CPU_CRITICAL_ENTER();
   \   00000034   0x2040             MOVS     R0,#+64
   \   00000036   0x.... 0x....      BL       CPU_SR_Save
    695                  p_tcb = OSTCBCurPtr;
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable13_1
   \   0000003E   0x680C             LDR      R4,[R1, #+0]
    696                  CPU_CRITICAL_EXIT();
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    697              }
    698          
    699              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQFlush_3: (+1)
   \   00000044   0x2040             MOVS     R0,#+64
   \   00000046   0x.... 0x....      BL       CPU_SR_Save
   \   0000004A   0x0006             MOVS     R6,R0
    700              entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Return all OS_MSGs to the OS_MSG pool                */
   \   0000004C   0xF114 0x005C      ADDS     R0,R4,#+92
   \   00000050   0x.... 0x....      BL       OS_MsgQFreeAll
   \   00000054   0x0004             MOVS     R4,R0
    701              CPU_CRITICAL_EXIT();
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    702             *p_err   = OS_ERR_NONE;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x8028             STRH     R0,[R5, #+0]
    703              return (entries);
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??OSTaskQFlush_1: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    704          }
    705          #endif
    706          
    707          
    708          /*
    709          ************************************************************************************************************************
    710          *                                                  WAIT FOR A MESSAGE
    711          *
    712          * Description: This function causes the current task to wait for a message to be posted to it.
    713          *
    714          * Arguments  : timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will wait for a
    715          *                            message to arrive up to the amount of time specified by this argument.
    716          *                            If you specify 0, however, your task will wait forever or, until a message arrives.
    717          *
    718          *              opt           determines whether the user wants to block if the task's queue is empty or not:
    719          *
    720          *                                OS_OPT_PEND_BLOCKING
    721          *                                OS_OPT_PEND_NON_BLOCKING
    722          *
    723          *              p_msg_size    is a pointer to a variable that will receive the size of the message
    724          *
    725          *              p_ts          is a pointer to a variable that will receive the timestamp of when the message was
    726          *                            received.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
    727          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
    728          *                            need the timestamp.
    729          *
    730          *              p_err         is a pointer to where an error message will be deposited.  Possible error
    731          *                            messages are:
    732          *
    733          *                                OS_ERR_NONE               The call was successful and your task received a message.
    734          *                                OS_ERR_OPT_INVALID        If you specified an invalid option
    735          *                                OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    736          *                                OS_ERR_PEND_ABORT         If the pend was aborted
    737          *                                OS_ERR_PEND_ISR           If you called this function from an ISR and the result
    738          *                                OS_ERR_PEND_WOULD_BLOCK   If you specified non-blocking but the queue was not empty
    739          *                                OS_ERR_PTR_INVALID        If 'p_msg_size' is NULL
    740          *                                OS_ERR_SCHED_LOCKED       If the scheduler is locked
    741          *                                OS_ERR_TIMEOUT            A message was not received within the specified timeout
    742          *                                                          would lead to a suspension
    743          *                                OS_ERR_TICK_DISABLED      If kernel ticks are disabled and a timeout is specified
    744          *
    745          * Returns    : A pointer to the message received or a NULL pointer upon error.
    746          *
    747          * Note(s)    : 1) It is possible to receive NULL pointers when there are no errors.
    748          *
    749          *            : 2) This API 'MUST NOT' be called from a timer callback function.
    750          ************************************************************************************************************************
    751          */
    752          
    753          #if (OS_CFG_TASK_Q_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    754          void  *OSTaskQPend (OS_TICK       timeout,
    755                              OS_OPT        opt,
    756                              OS_MSG_SIZE  *p_msg_size,
    757                              CPU_TS       *p_ts,
    758                              OS_ERR       *p_err)
    759          {
   \                     OSTaskQPend: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0xF8DD 0x8020      LDR      R8,[SP, #+32]
    760              OS_MSG_Q  *p_msg_q;
    761              void      *p_void;
    762              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
    763          
    764          
    765          #ifdef OS_SAFETY_CRITICAL
    766              if (p_err == (OS_ERR *)0) {
    767                  OS_SAFETY_CRITICAL_EXCEPTION();
    768                  return ((void *)0);
    769              }
    770          #endif
    771          
    772              OS_TRACE_TASK_MSG_Q_PEND_ENTER(&OSTCBCurPtr->MsgQ, timeout, opt, p_msg_size, p_ts);
    773          
    774          #if (OS_CFG_TICK_EN == 0u)
    775              if (timeout != 0u) {
    776                 *p_err = OS_ERR_TICK_DISABLED;
    777                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_TICK_DISABLED);
    778                  return ((void *)0);
    779              }
    780          #endif
    781          
    782          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    783              if (OSIntNestingCtr > 0u) {                                 /* Can't Pend from an ISR                               */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD005             BEQ.N    ??OSTaskQPend_0
    784                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_PEND_ISR);
    785                 *p_err = OS_ERR_PEND_ISR;
   \   00000018   0xF246 0x10AE      MOVW     R0,#+25006
   \   0000001C   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    786                  return ((void *)0);
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE094             B.N      ??OSTaskQPend_1
    787              }
    788          #endif
    789          
    790          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    791              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskQPend_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD005             BEQ.N    ??OSTaskQPend_2
    792                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
    793                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000002E   0xF645 0x6089      MOVW     R0,#+24201
   \   00000032   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    794                  return ((void *)0);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE089             B.N      ??OSTaskQPend_1
    795              }
   \                     ??OSTaskQPend_2: (+1)
   \   0000003A   0x0015             MOVS     R5,R2
    796          #endif
    797          
    798          
    799          #if (OS_CFG_ARG_CHK_EN > 0u)                                    /* ---------------- VALIDATE ARGUMENTS ---------------- */
    800              if (p_msg_size == (OS_MSG_SIZE *)0) {                       /* User must supply a valid destination for msg size    */
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD105             BNE.N    ??OSTaskQPend_3
    801                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_PTR_INVALID);
    802                 *p_err = OS_ERR_PTR_INVALID;
   \   00000040   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000044   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    803                  return ((void *)0);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE080             B.N      ??OSTaskQPend_1
    804              }
    805              switch (opt) {                                              /* User must supply a valid option                      */
   \                     ??OSTaskQPend_3: (+1)
   \   0000004C   0x0038             MOVS     R0,R7
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD002             BEQ.N    ??OSTaskQPend_4
   \   00000054   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000058   0xD11B             BNE.N    ??OSTaskQPend_5
   \                     ??OSTaskQPend_4: (+1)
   \   0000005A   0x001C             MOVS     R4,R3
    806                  case OS_OPT_PEND_BLOCKING:
    807                  case OS_OPT_PEND_NON_BLOCKING:
    808                       break;
    809          
    810                  default:
    811                       OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_OPT_INVALID);
    812                      *p_err = OS_ERR_OPT_INVALID;
    813                       return ((void *)0);
    814              }
    815          #endif
    816          
    817              if (p_ts != (CPU_TS *)0) {
   \   0000005C   0x2C00             CMP      R4,#+0
   \   0000005E   0xD001             BEQ.N    ??OSTaskQPend_6
    818                 *p_ts = 0u;                                              /* Initialize the returned timestamp                    */
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6020             STR      R0,[R4, #+0]
    819              }
    820          
    821              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPend_6: (+1)
   \   00000064   0x2040             MOVS     R0,#+64
   \   00000066   0x.... 0x....      BL       CPU_SR_Save
   \   0000006A   0x4681             MOV      R9,R0
    822              p_msg_q = &OSTCBCurPtr->MsgQ;                               /* Any message waiting in the message queue?            */
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x305C             ADDS     R0,R0,#+92
    823              p_void  = OS_MsgQGet(p_msg_q,
    824                                   p_msg_size,
    825                                   p_ts,
    826                                   p_err);
   \   00000074   0x4643             MOV      R3,R8
   \   00000076   0x0022             MOVS     R2,R4
   \   00000078   0x0029             MOVS     R1,R5
   \   0000007A   0x.... 0x....      BL       OS_MsgQGet
   \   0000007E   0x4682             MOV      R10,R0
    827              if (*p_err == OS_ERR_NONE) {
   \   00000080   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD10A             BNE.N    ??OSTaskQPend_7
    828          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    829          #if (OS_CFG_TS_EN > 0u)
    830                  if (p_ts != (CPU_TS *)0) {
    831                      OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
    832                      if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
    833                          OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    834                      }
    835                  }
    836          #endif
    837          #endif
    838                  OS_TRACE_TASK_MSG_Q_PEND(p_msg_q);
    839                  CPU_CRITICAL_EXIT();
   \   00000088   0x4648             MOV      R0,R9
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
    840                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_NONE);
    841                  return (p_void);                                        /* Yes, Return oldest message received                  */
   \   0000008E   0x4650             MOV      R0,R10
   \   00000090   0xE05D             B.N      ??OSTaskQPend_1
    842              }
   \                     ??OSTaskQPend_5: (+1)
   \   00000092   0xF645 0x6025      MOVW     R0,#+24101
   \   00000096   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xE057             B.N      ??OSTaskQPend_1
    843          
    844              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \                     ??OSTaskQPend_7: (+1)
   \   0000009E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000A0   0x0438             LSLS     R0,R7,#+16
   \   000000A2   0xD508             BPL.N    ??OSTaskQPend_8
    845                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \   000000A4   0xF246 0x10B0      MOVW     R0,#+25008
   \   000000A8   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    846                  CPU_CRITICAL_EXIT();
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0x.... 0x....      BL       CPU_SR_Restore
    847                  OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    848                  OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
    849                  return ((void *)0);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE04B             B.N      ??OSTaskQPend_1
    850              } else {                                                    /* Yes                                                  */
    851                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't block when the scheduler is locked             */
   \                     ??OSTaskQPend_8: (+1)
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD008             BEQ.N    ??OSTaskQPend_9
    852                      CPU_CRITICAL_EXIT();
   \   000000C0   0x4648             MOV      R0,R9
   \   000000C2   0x.... 0x....      BL       CPU_SR_Restore
    853                      OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    854                      OS_TRACE_TASK_MSG_Q_PEND_EXIT(OS_ERR_SCHED_LOCKED);
    855                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000C6   0xF646 0x5063      MOVW     R0,#+28003
   \   000000CA   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    856                      return ((void *)0);
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0xE03D             B.N      ??OSTaskQPend_1
    857                  }
    858              }
    859          
    860              OS_Pend((OS_PEND_OBJ *)0,                                   /* Block task pending on Message                        */
    861                       OSTCBCurPtr,
    862                       OS_TASK_PEND_ON_TASK_Q,
    863                       timeout);
   \                     ??OSTaskQPend_9: (+1)
   \   000000D2   0x0033             MOVS     R3,R6
   \   000000D4   0x2202             MOVS     R2,#+2
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000DA   0x6801             LDR      R1,[R0, #+0]
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x.... 0x....      BL       OS_Pend
    864              CPU_CRITICAL_EXIT();
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       CPU_SR_Restore
    865              OS_TRACE_TASK_MSG_Q_PEND_BLOCK(p_msg_q);
    866              OSSched();                                                  /* Find the next highest priority task ready to run     */
   \   000000E8   0x.... 0x....      BL       OSSched
    867          
    868              CPU_CRITICAL_ENTER();
   \   000000EC   0x2040             MOVS     R0,#+64
   \   000000EE   0x.... 0x....      BL       CPU_SR_Save
    869              switch (OSTCBCurPtr->PendStatus) {
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000F6   0x6809             LDR      R1,[R1, #+0]
   \   000000F8   0xF891 0x102D      LDRB     R1,[R1, #+45]
   \   000000FC   0x2900             CMP      R1,#+0
   \   000000FE   0xD002             BEQ.N    ??OSTaskQPend_10
   \   00000100   0x2901             CMP      R1,#+1
   \   00000102   0xD00E             BEQ.N    ??OSTaskQPend_11
   \   00000104   0xE019             B.N      ??OSTaskQPend_12
    870                  case OS_STATUS_PEND_OK:                                 /* Extract message from TCB (Put there by Post)         */
    871                       p_void      = OSTCBCurPtr->MsgPtr;
   \                     ??OSTaskQPend_10: (+1)
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000010A   0x6809             LDR      R1,[R1, #+0]
   \   0000010C   0x6D4E             LDR      R6,[R1, #+84]
    872                      *p_msg_size  = OSTCBCurPtr->MsgSize;
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000112   0x6809             LDR      R1,[R1, #+0]
   \   00000114   0xF8B1 0x1058      LDRH     R1,[R1, #+88]
   \   00000118   0x8029             STRH     R1,[R5, #+0]
    873          #if (OS_CFG_TS_EN > 0u)
    874                       if (p_ts != (CPU_TS *)0) {
    875                          *p_ts = OSTCBCurPtr->TS;
    876          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    877                          OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
    878                          if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
    879                              OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
    880                          }
    881          #endif
    882                       }
    883          #endif
    884                       OS_TRACE_TASK_MSG_Q_PEND(p_msg_q);
    885                      *p_err = OS_ERR_NONE;
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0xF8A8 0x1000      STRH     R1,[R8, #+0]
    886                       break;
   \   00000120   0xE012             B.N      ??OSTaskQPend_13
    887          
    888                  case OS_STATUS_PEND_ABORT:                              /* Indicate that we aborted                             */
    889                       p_void     = (void *)0;
   \                     ??OSTaskQPend_11: (+1)
   \   00000122   0x2600             MOVS     R6,#+0
    890                      *p_msg_size = 0u;
   \   00000124   0x2100             MOVS     R1,#+0
   \   00000126   0x8029             STRH     R1,[R5, #+0]
    891                       if (p_ts != (CPU_TS *)0) {
   \   00000128   0x2C00             CMP      R4,#+0
   \   0000012A   0xD001             BEQ.N    ??OSTaskQPend_14
    892                          *p_ts = 0u;
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0x6021             STR      R1,[R4, #+0]
    893                       }
    894                       OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    895                      *p_err      =  OS_ERR_PEND_ABORT;
   \                     ??OSTaskQPend_14: (+1)
   \   00000130   0xF246 0x11A9      MOVW     R1,#+25001
   \   00000134   0xF8A8 0x1000      STRH     R1,[R8, #+0]
    896                       break;
   \   00000138   0xE006             B.N      ??OSTaskQPend_13
    897          
    898                  case OS_STATUS_PEND_TIMEOUT:                            /* Indicate that we didn't get event within TO          */
    899                  default:
    900                       p_void     = (void *)0;
   \                     ??OSTaskQPend_12: (+1)
   \   0000013A   0x2600             MOVS     R6,#+0
    901                      *p_msg_size = 0u;
   \   0000013C   0x2100             MOVS     R1,#+0
   \   0000013E   0x8029             STRH     R1,[R5, #+0]
    902          #if (OS_CFG_TS_EN > 0u)
    903                       if (p_ts  != (CPU_TS *)0) {
    904                          *p_ts = OSTCBCurPtr->TS;
    905                       }
    906          #endif
    907                       OS_TRACE_TASK_MSG_Q_PEND_FAILED(p_msg_q);
    908                      *p_err      =  OS_ERR_TIMEOUT;
   \   00000140   0xF247 0x21D9      MOVW     R1,#+29401
   \   00000144   0xF8A8 0x1000      STRH     R1,[R8, #+0]
    909                       break;
    910              }
    911              CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPend_13: (+1)
   \   00000148   0x.... 0x....      BL       CPU_SR_Restore
    912              OS_TRACE_TASK_MSG_Q_PEND_EXIT(*p_err);
    913              return (p_void);                                            /* Return received message                              */
   \   0000014C   0x0030             MOVS     R0,R6
   \                     ??OSTaskQPend_1: (+1)
   \   0000014E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    914          }
    915          #endif
    916          
    917          
    918          /*
    919          ************************************************************************************************************************
    920          *                                              ABORT WAITING FOR A MESSAGE
    921          *
    922          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
    923          *              for a message, rather than to normally post the message to the task via OSTaskQPost().
    924          *
    925          * Arguments  : p_tcb     is a pointer to the task to pend abort
    926          *
    927          *              opt       provides options for this function:
    928          *
    929          *                            OS_OPT_POST_NONE         No option specified
    930          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
    931          *
    932          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
    933          *
    934          *                            OS_ERR_NONE               If the task was readied and informed of the aborted wait
    935          *                            OS_ERR_OPT_INVALID        If you specified an invalid option
    936          *                            OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
    937          *                            OS_ERR_PEND_ABORT_ISR     If you called this function from an ISR
    938          *                            OS_ERR_PEND_ABORT_NONE    If task was not pending on a message and thus there is nothing to
    939          *                                                      abort
    940          *                            OS_ERR_PEND_ABORT_SELF    If you passed a NULL pointer for 'p_tcb'
    941          *
    942          * Returns    : == OS_FALSE   if task was not waiting for a message, or upon error.
    943          *              == OS_TRUE    if task was waiting for a message and was readied and informed.
    944          *
    945          * Note(s)    : none
    946          ************************************************************************************************************************
    947          */
    948          
    949          #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    950          CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
    951                                         OS_OPT   opt,
    952                                         OS_ERR  *p_err)
    953          {
   \                     OSTaskQPendAbort: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
    954              CPU_TS  ts;
    955              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
    956          
    957          
    958          #ifdef OS_SAFETY_CRITICAL
    959              if (p_err == (OS_ERR *)0) {
    960                  OS_SAFETY_CRITICAL_EXCEPTION();
    961                  return (OS_FALSE);
    962              }
    963          #endif
    964          
    965          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    966              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSTaskQPendAbort_0
    967                 *p_err = OS_ERR_PEND_ABORT_ISR;                          /* ... can't Pend Abort from an ISR                     */
   \   00000014   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000018   0x8028             STRH     R0,[R5, #+0]
    968                  return (OS_FALSE);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE044             B.N      ??OSTaskQPendAbort_1
    969              }
    970          #endif
    971          
    972          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
    973              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskQPendAbort_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD004             BEQ.N    ??OSTaskQPendAbort_2
    974                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000028   0xF645 0x6089      MOVW     R0,#+24201
   \   0000002C   0x8028             STRH     R0,[R5, #+0]
    975                  return (OS_FALSE);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE03A             B.N      ??OSTaskQPendAbort_1
    976              }
    977          #endif
    978          
    979          #if (OS_CFG_ARG_CHK_EN > 0u)                                    /* ---------------- VALIDATE ARGUMENTS ---------------- */
    980              switch (opt) {                                              /* User must supply a valid option                      */
   \                     ??OSTaskQPendAbort_2: (+1)
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??OSTaskQPendAbort_3
   \   0000003A   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003E   0xD112             BNE.N    ??OSTaskQPendAbort_4
    981                  case OS_OPT_POST_NONE:
    982                  case OS_OPT_POST_NO_SCHED:
    983                       break;
    984          
    985                  default:
    986                      *p_err = OS_ERR_OPT_INVALID;
    987                       return (OS_FALSE);
    988              }
    989          #endif
    990          
    991              CPU_CRITICAL_ENTER();
   \                     ??OSTaskQPendAbort_3: (+1)
   \   00000040   0x2040             MOVS     R0,#+64
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x0007             MOVS     R7,R0
    992          #if (OS_CFG_ARG_CHK_EN > 0u)
    993              if ((p_tcb == (OS_TCB *)0) ||                               /* Pend abort self?                                     */
    994                  (p_tcb == OSTCBCurPtr)) {
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD004             BEQ.N    ??OSTaskQPendAbort_5
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x4284             CMP      R4,R0
   \   00000054   0xD10C             BNE.N    ??OSTaskQPendAbort_6
    995                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPendAbort_5: (+1)
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
    996                 *p_err = OS_ERR_PEND_ABORT_SELF;                         /* ... doesn't make sense                               */
   \   0000005C   0xF246 0x10AC      MOVW     R0,#+25004
   \   00000060   0x8028             STRH     R0,[R5, #+0]
    997                  return (OS_FALSE);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE020             B.N      ??OSTaskQPendAbort_1
    998              }
   \                     ??OSTaskQPendAbort_4: (+1)
   \   00000066   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006A   0x8028             STRH     R0,[R5, #+0]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE01B             B.N      ??OSTaskQPendAbort_1
    999          #endif
   1000          
   1001              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {              /* Is task waiting for a message?                       */
   \                     ??OSTaskQPendAbort_6: (+1)
   \   00000070   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD007             BEQ.N    ??OSTaskQPendAbort_7
   1002                  CPU_CRITICAL_EXIT();                                    /* No                                                   */
   \   00000078   0x0038             MOVS     R0,R7
   \   0000007A   0x.... 0x....      BL       CPU_SR_Restore
   1003                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   0000007E   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000082   0x8028             STRH     R0,[R5, #+0]
   1004                  return (OS_FALSE);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE00F             B.N      ??OSTaskQPendAbort_1
   1005              }
   1006          
   1007          #if (OS_CFG_TS_EN > 0u)
   1008              ts = OS_TS_GET();                                           /* Get timestamp of when the abort occurred             */
   1009          #else
   1010              ts = 0u;
   \                     ??OSTaskQPendAbort_7: (+1)
   \   00000088   0x2100             MOVS     R1,#+0
   1011          #endif
   1012              OS_PendAbort(p_tcb,                                         /* Abort the pend                                       */
   1013                           ts,
   1014                           OS_STATUS_PEND_ABORT);
   \   0000008A   0x2201             MOVS     R2,#+1
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x.... 0x....      BL       OS_PendAbort
   1015              CPU_CRITICAL_EXIT();
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       CPU_SR_Restore
   1016              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   00000098   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009A   0x0430             LSLS     R0,R6,#+16
   \   0000009C   0xD401             BMI.N    ??OSTaskQPendAbort_8
   1017                  OSSched();                                              /* Run the scheduler                                    */
   \   0000009E   0x.... 0x....      BL       OSSched
   1018              }
   1019             *p_err = OS_ERR_NONE;
   \                     ??OSTaskQPendAbort_8: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x8028             STRH     R0,[R5, #+0]
   1020              return (OS_TRUE);
   \   000000A6   0x2001             MOVS     R0,#+1
   \                     ??OSTaskQPendAbort_1: (+1)
   \   000000A8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1021          }
   1022          #endif
   1023          
   1024          
   1025          /*
   1026          ************************************************************************************************************************
   1027          *                                               POST MESSAGE TO A TASK
   1028          *
   1029          * Description: This function sends a message to a task.
   1030          *
   1031          * Arguments  : p_tcb      is a pointer to the TCB of the task receiving a message.  If you specify a NULL pointer then
   1032          *                         the message will be posted to the task's queue of the calling task.  In other words, you'd be
   1033          *                         posting a message to yourself.
   1034          *
   1035          *              p_void     is a pointer to the message to send.
   1036          *
   1037          *              msg_size   is the size of the message sent (in bytes)
   1038          *
   1039          *              opt        specifies whether the post will be FIFO or LIFO:
   1040          *
   1041          *                             OS_OPT_POST_FIFO       Post at the end   of the queue
   1042          *                             OS_OPT_POST_LIFO       Post at the front of the queue
   1043          *
   1044          *                             OS_OPT_POST_NO_SCHED   Do not run the scheduler after the post
   1045          *
   1046          *                          Note(s): 1) OS_OPT_POST_NO_SCHED can be added with one of the other options.
   1047          *
   1048          *
   1049          *              p_err      is a pointer to a variable that will hold the error code associated
   1050          *                         with the outcome of this call.  Errors can be:
   1051          *
   1052          *                             OS_ERR_NONE              The call was successful and the message was sent
   1053          *                             OS_ERR_MSG_POOL_EMPTY    If there are no more OS_MSGs available from the pool
   1054          *                             OS_ERR_OPT_INVALID       If you specified an invalid option
   1055          *                             OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
   1056          *                             OS_ERR_Q_MAX             If the queue is full
   1057          *                             OS_ERR_STATE_INVALID     If the task is in an invalid state.  This should never happen
   1058          *                                                      and if it does, would be considered a system failure
   1059          *
   1060          * Returns    : none
   1061          *
   1062          * Note(s)    : none
   1063          ************************************************************************************************************************
   1064          */
   1065          
   1066          #if (OS_CFG_TASK_Q_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1067          void  OSTaskQPost (OS_TCB       *p_tcb,
   1068                             void         *p_void,
   1069                             OS_MSG_SIZE   msg_size,
   1070                             OS_OPT        opt,
   1071                             OS_ERR       *p_err)
   1072          {
   \                     OSTaskQPost: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1073              CPU_TS  ts;
   1074              CPU_SR_ALLOC();
   \   00000010   0x2000             MOVS     R0,#+0
   1075          
   1076          
   1077          #ifdef OS_SAFETY_CRITICAL
   1078              if (p_err == (OS_ERR *)0) {
   1079                  OS_SAFETY_CRITICAL_EXCEPTION();
   1080                  return;
   1081              }
   1082          #endif
   1083          
   1084              OS_TRACE_TASK_MSG_Q_POST_ENTER(&p_tcb->MsgQ, p_void, msg_size, opt);
   1085          
   1086          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
   1087              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD004             BEQ.N    ??OSTaskQPost_0
   1088                  OS_TRACE_TASK_MSG_Q_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
   1089                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   0000001C   0xF645 0x6089      MOVW     R0,#+24201
   \   00000020   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1090                  return;
   \   00000024   0xE06E             B.N      ??OSTaskQPost_1
   1091              }
   1092          #endif
   1093          
   1094          #if (OS_CFG_ARG_CHK_EN > 0u)                                    /* ---------------- VALIDATE ARGUMENTS ---------------- */
   1095              switch (opt) {                                              /* User must supply a valid option                      */
   \                     ??OSTaskQPost_0: (+1)
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD008             BEQ.N    ??OSTaskQPost_2
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD006             BEQ.N    ??OSTaskQPost_2
   \   00000032   0xF5B0 0x4F00      CMP      R0,#+32768
   \   00000036   0xD003             BEQ.N    ??OSTaskQPost_2
   \   00000038   0xF248 0x0110      MOVW     R1,#+32784
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD12E             BNE.N    ??OSTaskQPost_3
   1096                  case OS_OPT_POST_FIFO:
   1097                  case OS_OPT_POST_LIFO:
   1098                  case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
   1099                  case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
   1100                       break;
   1101          
   1102                  default:
   1103                       OS_TRACE_TASK_MSG_Q_POST_FAILED(&p_tcb->MsgQ);
   1104                       OS_TRACE_TASK_MSG_Q_POST_EXIT(OS_ERR_OPT_INVALID);
   1105                      *p_err = OS_ERR_OPT_INVALID;
   1106                       return;
   1107              }
   1108          #endif
   1109          
   1110          #if (OS_CFG_TS_EN > 0u)
   1111              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   1112          #else
   1113              ts = 0u;
   \                     ??OSTaskQPost_2: (+1)
   \   00000040   0xF05F 0x0900      MOVS     R9,#+0
   1114          #endif
   1115          
   1116              OS_TRACE_TASK_MSG_Q_POST(&p_tcb->MsgQ);
   1117          
   1118             *p_err = OS_ERR_NONE;                                        /* Assume we won't have any errors                      */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1119              CPU_CRITICAL_ENTER();
   \   0000004A   0x2040             MOVS     R0,#+64
   \   0000004C   0x.... 0x....      BL       CPU_SR_Save
   \   00000050   0x4682             MOV      R10,R0
   1120              if (p_tcb == (OS_TCB *)0) {                                 /* Post msg to 'self'?                                  */
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD102             BNE.N    ??OSTaskQPost_4
   1121                  p_tcb = OSTCBCurPtr;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000005A   0x6804             LDR      R4,[R0, #+0]
   1122              }
   1123              switch (p_tcb->TaskState) {
   \                     ??OSTaskQPost_4: (+1)
   \   0000005C   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD00B             BEQ.N    ??OSTaskQPost_5
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD01F             BEQ.N    ??OSTaskQPost_6
   \   00000068   0xD308             BCC.N    ??OSTaskQPost_5
   \   0000006A   0x2804             CMP      R0,#+4
   \   0000006C   0xD006             BEQ.N    ??OSTaskQPost_5
   \   0000006E   0xD31B             BCC.N    ??OSTaskQPost_6
   \   00000070   0x2806             CMP      R0,#+6
   \   00000072   0xD019             BEQ.N    ??OSTaskQPost_6
   \   00000074   0xD302             BCC.N    ??OSTaskQPost_5
   \   00000076   0x2807             CMP      R0,#+7
   \   00000078   0xD016             BEQ.N    ??OSTaskQPost_6
   \   0000007A   0xE03C             B.N      ??OSTaskQPost_7
   1124                  case OS_TASK_STATE_RDY:
   1125                  case OS_TASK_STATE_DLY:
   1126                  case OS_TASK_STATE_SUSPENDED:
   1127                  case OS_TASK_STATE_DLY_SUSPENDED:
   1128                       OS_MsgQPut(&p_tcb->MsgQ,                           /* Deposit the message in the queue                     */
   1129                                  p_void,
   1130                                  msg_size,
   1131                                  opt,
   1132                                  ts,
   1133                                  p_err);
   \                     ??OSTaskQPost_5: (+1)
   \   0000007C   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   00000080   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   00000084   0x003B             MOVS     R3,R7
   \   00000086   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000088   0x0032             MOVS     R2,R6
   \   0000008A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000008C   0x0029             MOVS     R1,R5
   \   0000008E   0xF114 0x005C      ADDS     R0,R4,#+92
   \   00000092   0x.... 0x....      BL       OS_MsgQPut
   1134                       CPU_CRITICAL_EXIT();
   \   00000096   0x4650             MOV      R0,R10
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
   1135                       break;
   \   0000009C   0xE032             B.N      ??OSTaskQPost_8
   \                     ??OSTaskQPost_3: (+1)
   \   0000009E   0xF645 0x6025      MOVW     R0,#+24101
   \   000000A2   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   \   000000A6   0xE02D             B.N      ??OSTaskQPost_1
   1136          
   1137                  case OS_TASK_STATE_PEND:
   1138                  case OS_TASK_STATE_PEND_TIMEOUT:
   1139                  case OS_TASK_STATE_PEND_SUSPENDED:
   1140                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1141                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) {     /* Is task waiting for a message to be sent to it?      */
   \                     ??OSTaskQPost_6: (+1)
   \   000000A8   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   000000AC   0x2802             CMP      R0,#+2
   \   000000AE   0xD111             BNE.N    ??OSTaskQPost_9
   1142                           OS_Post((OS_PEND_OBJ *)0,
   1143                                    p_tcb,
   1144                                    p_void,
   1145                                    msg_size,
   1146                                    ts);
   \   000000B0   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000B4   0x0033             MOVS     R3,R6
   \   000000B6   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000B8   0x002A             MOVS     R2,R5
   \   000000BA   0x0021             MOVS     R1,R4
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       OS_Post
   1147                           CPU_CRITICAL_EXIT();
   \   000000C2   0x4650             MOV      R0,R10
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
   1148                           if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000C8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000CA   0x0438             LSLS     R0,R7,#+16
   \   000000CC   0xD412             BMI.N    ??OSTaskQPost_10
   1149                               OSSched();                                 /* Run the scheduler                                    */
   \   000000CE   0x.... 0x....      BL       OSSched
   \   000000D2   0xE00F             B.N      ??OSTaskQPost_10
   1150                           }
   1151                       } else {
   1152                           OS_MsgQPut(&p_tcb->MsgQ,                       /* No,  Task is pending on something else ...           */
   1153                                      p_void,                             /* ... Deposit the message in the task's queue          */
   1154                                      msg_size,
   1155                                      opt,
   1156                                      ts,
   1157                                      p_err);
   \                     ??OSTaskQPost_9: (+1)
   \   000000D4   0xF8CD 0x8004      STR      R8,[SP, #+4]
   \   000000D8   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   000000DC   0x003B             MOVS     R3,R7
   \   000000DE   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000E0   0x0032             MOVS     R2,R6
   \   000000E2   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000E4   0x0029             MOVS     R1,R5
   \   000000E6   0xF114 0x005C      ADDS     R0,R4,#+92
   \   000000EA   0x.... 0x....      BL       OS_MsgQPut
   1158                           CPU_CRITICAL_EXIT();
   \   000000EE   0x4650             MOV      R0,R10
   \   000000F0   0x.... 0x....      BL       CPU_SR_Restore
   1159                       }
   1160                       break;
   \                     ??OSTaskQPost_10: (+1)
   \   000000F4   0xE006             B.N      ??OSTaskQPost_8
   1161          
   1162                  default:
   1163                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskQPost_7: (+1)
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0x.... 0x....      BL       CPU_SR_Restore
   1164                      *p_err = OS_ERR_STATE_INVALID;
   \   000000FC   0xF646 0x602D      MOVW     R0,#+28205
   \   00000100   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1165                       break;
   1166              }
   1167          
   1168              OS_TRACE_TASK_MSG_Q_POST_EXIT(*p_err);
   1169          }
   \                     ??OSTaskQPost_8: (+1)
   \                     ??OSTaskQPost_1: (+1)
   \   00000104   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   1170          #endif
   1171          
   1172          
   1173          /*
   1174          ************************************************************************************************************************
   1175          *                                       GET THE CURRENT VALUE OF A TASK REGISTER
   1176          *
   1177          * Description: This function is called to obtain the current value of a task register.  Task registers are application
   1178          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
   1179          *              etc.
   1180          *
   1181          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to read the register from.  If 'p_tcb' is a
   1182          *                        NULL pointer then you will get the register of the current task.
   1183          *
   1184          *              id        is the 'id' of the desired task variable.  Note that the 'id' must be less than
   1185          *                        OS_CFG_TASK_REG_TBL_SIZE
   1186          *
   1187          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1188          *
   1189          *                            OS_ERR_NONE               If the call was successful
   1190          *                            OS_ERR_REG_ID_INVALID     If the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1191          *
   1192          * Returns    : The current value of the task's register or 0 if an error is detected.
   1193          *
   1194          * Note(s)    : none
   1195          ************************************************************************************************************************
   1196          */
   1197          
   1198          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1199          OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
   1200                                OS_REG_ID   id,
   1201                                OS_ERR     *p_err)
   1202          {
   \                     OSTaskRegGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   1203              OS_REG     value;
   1204              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   1205          
   1206          
   1207          
   1208          #ifdef OS_SAFETY_CRITICAL
   1209              if (p_err == (OS_ERR *)0) {
   1210                  OS_SAFETY_CRITICAL_EXCEPTION();
   1211                  return (0u);
   1212              }
   1213          #endif
   1214          
   1215          #if (OS_CFG_ARG_CHK_EN > 0u)
   1216              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskRegGet_0
   1217                 *p_err = OS_ERR_REG_ID_INVALID;
   \   00000012   0xF646 0x1079      MOVW     R0,#+27001
   \   00000016   0x8028             STRH     R0,[R5, #+0]
   1218                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE010             B.N      ??OSTaskRegGet_1
   1219              }
   1220          #endif
   1221          
   1222              CPU_CRITICAL_ENTER();
   \                     ??OSTaskRegGet_0: (+1)
   \   0000001C   0x2040             MOVS     R0,#+64
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   1223              if (p_tcb == (OS_TCB *)0) {
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD102             BNE.N    ??OSTaskRegGet_2
   1224                  p_tcb = OSTCBCurPtr;
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000002A   0x680C             LDR      R4,[R1, #+0]
   1225              }
   1226              value = p_tcb->RegTbl[id];
   \                     ??OSTaskRegGet_2: (+1)
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0xEB04 0x0186      ADD      R1,R4,R6, LSL #+2
   \   00000032   0x6F0C             LDR      R4,[R1, #+112]
   1227              CPU_CRITICAL_EXIT();
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
   1228             *p_err = OS_ERR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
   1229              return (value);
   \   0000003C   0x0020             MOVS     R0,R4
   \                     ??OSTaskRegGet_1: (+1)
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   1230          }
   1231          #endif
   1232          
   1233          
   1234          /*
   1235          ************************************************************************************************************************
   1236          *                                    ALLOCATE THE NEXT AVAILABLE TASK REGISTER ID
   1237          *
   1238          * Description: This function is called to obtain a task register ID.  This function thus allows task registers IDs to be
   1239          *              allocated dynamically instead of statically.
   1240          *
   1241          * Arguments  : p_err       is a pointer to a variable that will hold an error code related to this call.
   1242          *
   1243          *                            OS_ERR_NONE               If the call was successful
   1244          *                            OS_ERR_NO_MORE_ID_AVAIL   If you are attempting to assign more task register IDs than you
   1245          *                                                          have available through OS_CFG_TASK_REG_TBL_SIZE
   1246          *
   1247          * Returns    : The next available task register 'id' or OS_CFG_TASK_REG_TBL_SIZE if an error is detected.
   1248          *
   1249          * Note(s)    : none
   1250          ************************************************************************************************************************
   1251          */
   1252          
   1253          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1254          OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
   1255          {
   \                     OSTaskRegGetID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1256              OS_REG_ID  id;
   1257              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
   1258          
   1259          
   1260          
   1261          #ifdef OS_SAFETY_CRITICAL
   1262              if (p_err == (OS_ERR *)0) {
   1263                  OS_SAFETY_CRITICAL_EXCEPTION();
   1264                  return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
   1265              }
   1266          #endif
   1267          
   1268              CPU_CRITICAL_ENTER();
   \   00000006   0x2040             MOVS     R0,#+64
   \   00000008   0x.... 0x....      BL       CPU_SR_Save
   1269              if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {     /* See if we exceeded the number of IDs available       */
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000010   0x7809             LDRB     R1,[R1, #+0]
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD006             BEQ.N    ??OSTaskRegGetID_0
   1270                 *p_err = OS_ERR_NO_MORE_ID_AVAIL;                        /* Yes, cannot allocate more task register IDs          */
   \   00000016   0xF645 0x11DA      MOVW     R1,#+23002
   \   0000001A   0x8021             STRH     R1,[R4, #+0]
   1271                  CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
   1272                  return (OS_CFG_TASK_REG_TBL_SIZE);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE00F             B.N      ??OSTaskRegGetID_1
   1273              }
   1274          
   1275              id = OSTaskRegNextAvailID;                                  /* Assign the next available ID                         */
   \                     ??OSTaskRegGetID_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000028   0x780D             LDRB     R5,[R1, #+0]
   1276              OSTaskRegNextAvailID++;                                     /* Increment available ID for next request              */
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000036   0x7011             STRB     R1,[R2, #+0]
   1277              CPU_CRITICAL_EXIT();
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
   1278             *p_err = OS_ERR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x8020             STRH     R0,[R4, #+0]
   1279              return (id);
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??OSTaskRegGetID_1: (+1)
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1280          }
   1281          #endif
   1282          
   1283          
   1284          /*
   1285          ************************************************************************************************************************
   1286          *                                       SET THE CURRENT VALUE OF A TASK REGISTER
   1287          *
   1288          * Description: This function is called to change the current value of a task register.  Task registers are application
   1289          *              specific and can be used to store task specific values such as 'error numbers' (i.e. errno), statistics,
   1290          *              etc.
   1291          *
   1292          * Arguments  : p_tcb     is a pointer to the OS_TCB of the task you want to set the register for.  If 'p_tcb' is a NULL
   1293          *                        pointer then you will change the register of the current task.
   1294          *
   1295          *              id        is the 'id' of the desired task register.  Note that the 'id' must be less than
   1296          *                        OS_CFG_TASK_REG_TBL_SIZE
   1297          *
   1298          *              value     is the desired value for the task register.
   1299          *
   1300          *              p_err     is a pointer to a variable that will hold an error code related to this call.
   1301          *
   1302          *                            OS_ERR_NONE               If the call was successful
   1303          *                            OS_ERR_REG_ID_INVALID     If the 'id' is not between 0 and OS_CFG_TASK_REG_TBL_SIZE-1
   1304          *
   1305          * Returns    : none
   1306          *
   1307          * Note(s)    : none
   1308          ************************************************************************************************************************
   1309          */
   1310          
   1311          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)

   \                                 In section .text, align 2, keep-with-next
   1312          void  OSTaskRegSet (OS_TCB     *p_tcb,
   1313                              OS_REG_ID   id,
   1314                              OS_REG      value,
   1315                              OS_ERR     *p_err)
   1316          {
   \                     OSTaskRegSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001D             MOVS     R5,R3
   1317              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
   1318          
   1319          
   1320          
   1321          #ifdef OS_SAFETY_CRITICAL
   1322              if (p_err == (OS_ERR *)0) {
   1323                  OS_SAFETY_CRITICAL_EXCEPTION();
   1324                  return;
   1325              }
   1326          #endif
   1327          
   1328          #if (OS_CFG_ARG_CHK_EN > 0u)
   1329              if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
   \   0000000C   0x0038             MOVS     R0,R7
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ.N    ??OSTaskRegSet_0
   1330                 *p_err = OS_ERR_REG_ID_INVALID;
   \   00000014   0xF646 0x1079      MOVW     R0,#+27001
   \   00000018   0x8028             STRH     R0,[R5, #+0]
   1331                  return;
   \   0000001A   0xE00F             B.N      ??OSTaskRegSet_1
   1332              }
   1333          #endif
   1334          
   1335              CPU_CRITICAL_ENTER();
   \                     ??OSTaskRegSet_0: (+1)
   \   0000001C   0x2040             MOVS     R0,#+64
   \   0000001E   0x.... 0x....      BL       CPU_SR_Save
   1336              if (p_tcb == (OS_TCB *)0) {
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD102             BNE.N    ??OSTaskRegSet_2
   1337                  p_tcb = OSTCBCurPtr;
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000002A   0x680C             LDR      R4,[R1, #+0]
   1338              }
   1339              p_tcb->RegTbl[id] = value;
   \                     ??OSTaskRegSet_2: (+1)
   \   0000002C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002E   0xEB04 0x0187      ADD      R1,R4,R7, LSL #+2
   \   00000032   0x670E             STR      R6,[R1, #+112]
   1340              CPU_CRITICAL_EXIT();
   \   00000034   0x.... 0x....      BL       CPU_SR_Restore
   1341             *p_err             = OS_ERR_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x8028             STRH     R0,[R5, #+0]
   1342          }
   \                     ??OSTaskRegSet_1: (+1)
   \   0000003C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1343          #endif
   1344          
   1345          
   1346          /*
   1347          ************************************************************************************************************************
   1348          *                                               RESUME A SUSPENDED TASK
   1349          *
   1350          * Description: This function is called to resume a previously suspended task.  This is the only call that will remove an
   1351          *              explicit task suspension.
   1352          *
   1353          * Arguments  : p_tcb      Is a pointer to the task's OS_TCB to resume
   1354          *
   1355          *              p_err      Is a pointer to a variable that will contain an error code returned by this function
   1356          *
   1357          *                             OS_ERR_NONE                  If the requested task is resumed
   1358          *                             OS_ERR_OS_NOT_RUNNING        If uC/OS-III is not running yet
   1359          *                             OS_ERR_STATE_INVALID         If the task is in an invalid state
   1360          *                             OS_ERR_TASK_NOT_SUSPENDED    If the task to resume has not been suspended
   1361          *                             OS_ERR_TASK_RESUME_ISR       If you called this function from an ISR
   1362          *                             OS_ERR_TASK_RESUME_SELF      You cannot resume 'self'
   1363          *
   1364          * Returns    : none
   1365          *
   1366          * Note(s)    : none
   1367          ************************************************************************************************************************
   1368          */
   1369          
   1370          #if (OS_CFG_TASK_SUSPEND_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1371          void  OSTaskResume (OS_TCB  *p_tcb,
   1372                              OS_ERR  *p_err)
   1373          {
   \                     OSTaskResume: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1374              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
   1375          
   1376          
   1377              OS_TRACE_TASK_RESUME_ENTER(p_tcb);
   1378          
   1379          #ifdef OS_SAFETY_CRITICAL
   1380              if (p_err == (OS_ERR *)0) {
   1381                  OS_SAFETY_CRITICAL_EXCEPTION();
   1382                  return;
   1383              }
   1384          #endif
   1385          
   1386          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   1387              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x....             LDR.N    R0,??DataTable12
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSTaskResume_0
   1388                 *p_err = OS_ERR_TASK_RESUME_ISR;
   \   00000010   0xF247 0x1055      MOVW     R0,#+29013
   \   00000014   0x8028             STRH     R0,[R5, #+0]
   1389                  OS_TRACE_TASK_RESUME_EXIT(OS_ERR_TASK_RESUME_ISR);
   1390                  return;
   \   00000016   0xE083             B.N      ??OSTaskResume_1
   1391              }
   1392          #endif
   1393          
   1394          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
   1395              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskResume_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSTaskResume_2
   1396                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8028             STRH     R0,[R5, #+0]
   1397                  OS_TRACE_TASK_RESUME_EXIT(OS_ERR_OS_NOT_RUNNING);
   1398                  return;
   \   00000028   0xE07A             B.N      ??OSTaskResume_1
   1399              }
   1400          #endif
   1401          
   1402          
   1403          #if (OS_CFG_ARG_CHK_EN > 0u)
   1404              CPU_CRITICAL_ENTER();
   \                     ??OSTaskResume_2: (+1)
   \   0000002A   0x2040             MOVS     R0,#+64
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
   1405              if ((p_tcb == (OS_TCB *)0) ||                               /* We cannot resume 'self'                              */
   1406                  (p_tcb == OSTCBCurPtr)) {
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD004             BEQ.N    ??OSTaskResume_3
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x428C             CMP      R4,R1
   \   0000003C   0xD105             BNE.N    ??OSTaskResume_4
   1407                  CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_3: (+1)
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
   1408                 *p_err = OS_ERR_TASK_RESUME_SELF;
   \   00000042   0xF247 0x1057      MOVW     R0,#+29015
   \   00000046   0x8028             STRH     R0,[R5, #+0]
   1409                  OS_TRACE_TASK_RESUME_EXIT(OS_ERR_TASK_RESUME_SELF);
   1410                  return;
   \   00000048   0xE06A             B.N      ??OSTaskResume_1
   1411              }
   1412              CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_4: (+1)
   \   0000004A   0x.... 0x....      BL       CPU_SR_Restore
   1413          #endif
   1414          
   1415              CPU_CRITICAL_ENTER();
   \   0000004E   0x2040             MOVS     R0,#+64
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x0006             MOVS     R6,R0
   1416             *p_err = OS_ERR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x8028             STRH     R0,[R5, #+0]
   1417              switch (p_tcb->TaskState) {
   \   0000005A   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0x2803             CMP      R0,#+3
   \   00000062   0xD908             BLS.N    ??OSTaskResume_5
   \   00000064   0x1F00             SUBS     R0,R0,#+4
   \   00000066   0xD00D             BEQ.N    ??OSTaskResume_6
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0xD01E             BEQ.N    ??OSTaskResume_7
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0xD02C             BEQ.N    ??OSTaskResume_8
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0xD03A             BEQ.N    ??OSTaskResume_9
   \   00000074   0xE049             B.N      ??OSTaskResume_10
   1418                  case OS_TASK_STATE_RDY:
   1419                  case OS_TASK_STATE_DLY:
   1420                  case OS_TASK_STATE_PEND:
   1421                  case OS_TASK_STATE_PEND_TIMEOUT:
   1422                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_5: (+1)
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
   1423                      *p_err = OS_ERR_TASK_NOT_SUSPENDED;
   \   0000007C   0xF247 0x1053      MOVW     R0,#+29011
   \   00000080   0x8028             STRH     R0,[R5, #+0]
   1424                       OS_TRACE_TASK_RESUME_EXIT(OS_ERR_TASK_NOT_SUSPENDED);
   1425                       break;
   \   00000082   0xE048             B.N      ??OSTaskResume_11
   1426          
   1427                  case OS_TASK_STATE_SUSPENDED:
   1428                       p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_6: (+1)
   \   00000084   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0xF884 0x007E      STRB     R0,[R4, #+126]
   1429                       if (p_tcb->SuspendCtr == 0u) {
   \   0000008E   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD105             BNE.N    ??OSTaskResume_12
   1430                           p_tcb->TaskState = OS_TASK_STATE_RDY;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xF884 0x002E      STRB     R0,[R4, #+46]
   1431                           OS_RdyListInsert(p_tcb);                       /* Insert the task in the ready list                    */
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       OS_RdyListInsert
   1432                           OS_TRACE_TASK_RESUME(p_tcb);
   1433                       }
   1434                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_12: (+1)
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
   1435                       break;
   \   000000A8   0xE035             B.N      ??OSTaskResume_11
   1436          
   1437                  case OS_TASK_STATE_DLY_SUSPENDED:
   1438                       p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_7: (+1)
   \   000000AA   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000AE   0x1E40             SUBS     R0,R0,#+1
   \   000000B0   0xF884 0x007E      STRB     R0,[R4, #+126]
   1439                       if (p_tcb->SuspendCtr == 0u) {
   \   000000B4   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD102             BNE.N    ??OSTaskResume_13
   1440                           p_tcb->TaskState = OS_TASK_STATE_DLY;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xF884 0x002E      STRB     R0,[R4, #+46]
   1441                       }
   1442                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_13: (+1)
   \   000000C2   0x0030             MOVS     R0,R6
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
   1443                       break;
   \   000000C8   0xE025             B.N      ??OSTaskResume_11
   1444          
   1445                  case OS_TASK_STATE_PEND_SUSPENDED:
   1446                       p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_8: (+1)
   \   000000CA   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000CE   0x1E40             SUBS     R0,R0,#+1
   \   000000D0   0xF884 0x007E      STRB     R0,[R4, #+126]
   1447                       if (p_tcb->SuspendCtr == 0u) {
   \   000000D4   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD102             BNE.N    ??OSTaskResume_14
   1448                           p_tcb->TaskState = OS_TASK_STATE_PEND;
   \   000000DC   0x2002             MOVS     R0,#+2
   \   000000DE   0xF884 0x002E      STRB     R0,[R4, #+46]
   1449                       }
   1450                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_14: (+1)
   \   000000E2   0x0030             MOVS     R0,R6
   \   000000E4   0x.... 0x....      BL       CPU_SR_Restore
   1451                       break;
   \   000000E8   0xE015             B.N      ??OSTaskResume_11
   1452          
   1453                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1454                       p_tcb->SuspendCtr--;
   \                     ??OSTaskResume_9: (+1)
   \   000000EA   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000EE   0x1E40             SUBS     R0,R0,#+1
   \   000000F0   0xF884 0x007E      STRB     R0,[R4, #+126]
   1455                       if (p_tcb->SuspendCtr == 0u) {
   \   000000F4   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD102             BNE.N    ??OSTaskResume_15
   1456                           p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   000000FC   0x2003             MOVS     R0,#+3
   \   000000FE   0xF884 0x002E      STRB     R0,[R4, #+46]
   1457                       }
   1458                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_15: (+1)
   \   00000102   0x0030             MOVS     R0,R6
   \   00000104   0x.... 0x....      BL       CPU_SR_Restore
   1459                       break;
   \   00000108   0xE005             B.N      ??OSTaskResume_11
   1460          
   1461                  default:
   1462                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskResume_10: (+1)
   \   0000010A   0x0030             MOVS     R0,R6
   \   0000010C   0x.... 0x....      BL       CPU_SR_Restore
   1463                      *p_err = OS_ERR_STATE_INVALID;
   \   00000110   0xF646 0x602D      MOVW     R0,#+28205
   \   00000114   0x8028             STRH     R0,[R5, #+0]
   1464                       OS_TRACE_TASK_RESUME_EXIT(OS_ERR_STATE_INVALID);
   1465                       break;
   1466              }
   1467          
   1468              if (*p_err != OS_ERR_NONE) {                                /* Don't schedule if task wasn't in a suspend state.    */
   \                     ??OSTaskResume_11: (+1)
   \   00000116   0x8828             LDRH     R0,[R5, #+0]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD101             BNE.N    ??OSTaskResume_1
   1469                  return;
   1470              }
   1471          
   1472              OSSched();
   \                     ??OSTaskResume_16: (+1)
   \   0000011C   0x.... 0x....      BL       OSSched
   1473              OS_TRACE_TASK_RESUME_EXIT(OS_ERR_NONE);
   1474          }
   \                     ??OSTaskResume_1: (+1)
   \   00000120   0xBD70             POP      {R4-R6,PC}       ;; return
   1475          #endif
   1476          
   1477          
   1478          /*
   1479          ************************************************************************************************************************
   1480          *                                              WAIT FOR A TASK SEMAPHORE
   1481          *
   1482          * Description: This function is called to block the current task until a signal is sent by another task or ISR.
   1483          *
   1484          * Arguments  : timeout       is the amount of time you are will to wait for the signal
   1485          *
   1486          *              opt           determines whether the user wants to block if a semaphore post was not received:
   1487          *
   1488          *                                OS_OPT_PEND_BLOCKING
   1489          *                                OS_OPT_PEND_NON_BLOCKING
   1490          *
   1491          *              p_ts          is a pointer to a variable that will receive the timestamp of when the semaphore was posted
   1492          *                            or pend aborted.  If you pass a NULL pointer (i.e. (CPU_TS *)0) then you will not get the
   1493          *                            timestamp.  In other words, passing a NULL pointer is valid and indicates that you don't
   1494          *                            need the timestamp.
   1495          *
   1496          *              p_err         is a pointer to an error code that will be set by this function
   1497          *
   1498          *                                OS_ERR_NONE                The call was successful and your task received a message
   1499          *                                OS_ERR_OPT_INVALID         You specified an invalid option
   1500          *                                OS_ERR_OS_NOT_RUNNING      If uC/OS-III is not running yet
   1501          *                                OS_ERR_PEND_ABORT          If the pend was aborted
   1502          *                                OS_ERR_PEND_ISR            If you called this function from an ISR
   1503          *                                OS_ERR_PEND_WOULD_BLOCK    If you specified non-blocking but no signal was received
   1504          *                                OS_ERR_SCHED_LOCKED        If the scheduler is locked
   1505          *                                OS_ERR_STATUS_INVALID      If the pend status is invalid
   1506          *                                OS_ERR_TIMEOUT             A message was not received within the specified timeout
   1507          *
   1508          * Returns    : The current count of signals the task received, 0 if none.
   1509          *
   1510          * Note(s)    : This API 'MUST NOT' be called from a timer callback function.
   1511          ************************************************************************************************************************
   1512          */
   1513          

   \                                 In section .text, align 2, keep-with-next
   1514          OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
   1515                                     OS_OPT    opt,
   1516                                     CPU_TS   *p_ts,
   1517                                     OS_ERR   *p_err)
   1518          {
   \                     OSTaskSemPend: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x001C             MOVS     R4,R3
   1519              OS_SEM_CTR    ctr;
   1520              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   1521          
   1522          
   1523          #if (OS_CFG_TS_EN == 0u)
   1524              (void)p_ts;                                                 /* Prevent compiler warning for not using 'ts'          */
   1525          #endif
   1526          
   1527          #ifdef OS_SAFETY_CRITICAL
   1528              if (p_err == (OS_ERR *)0) {
   1529                  OS_SAFETY_CRITICAL_EXCEPTION();
   1530                  return (0u);
   1531              }
   1532          #endif
   1533          
   1534              OS_TRACE_TASK_SEM_PEND_ENTER(OSTCBCurPtr, timeout, opt, p_ts);
   1535          
   1536          #if (OS_CFG_TICK_EN == 0u)
   1537              if (timeout != 0u) {
   1538                  OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1539                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_TICK_DISABLED);
   1540                 *p_err = OS_ERR_TICK_DISABLED;
   1541                  return (0u);
   1542              }
   1543          #endif
   1544          
   1545          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   1546              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000A   0x....             LDR.N    R0,??DataTable12
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskSemPend_0
   1547                  OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1548                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_PEND_ISR);
   1549                 *p_err = OS_ERR_PEND_ISR;
   \   00000012   0xF246 0x10AE      MOVW     R0,#+25006
   \   00000016   0x8020             STRH     R0,[R4, #+0]
   1550                  return (0u);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE07B             B.N      ??OSTaskSemPend_1
   1551              }
   1552          #endif
   1553          
   1554          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
   1555              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskSemPend_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable13
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD004             BEQ.N    ??OSTaskSemPend_2
   1556                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_OS_NOT_RUNNING);
   1557                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000024   0xF645 0x6089      MOVW     R0,#+24201
   \   00000028   0x8020             STRH     R0,[R4, #+0]
   1558                  return (0u);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE072             B.N      ??OSTaskSemPend_1
   1559              }
   1560          #endif
   1561          
   1562          #if (OS_CFG_ARG_CHK_EN > 0u)
   1563              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSTaskSemPend_2: (+1)
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD002             BEQ.N    ??OSTaskSemPend_3
   \   00000036   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003A   0xD114             BNE.N    ??OSTaskSemPend_4
   1564                  case OS_OPT_PEND_BLOCKING:
   1565                  case OS_OPT_PEND_NON_BLOCKING:
   1566                       break;
   1567          
   1568                  default:
   1569                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1570                       OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_OPT_INVALID);
   1571                      *p_err = OS_ERR_OPT_INVALID;
   1572                       return (0u);
   1573              }
   1574          #endif
   1575          
   1576              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPend_3: (+1)
   \   0000003C   0x2040             MOVS     R0,#+64
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0007             MOVS     R7,R0
   1577              if (OSTCBCurPtr->SemCtr > 0u) {                             /* See if task already been signaled                    */
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6C00             LDR      R0,[R0, #+64]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD10F             BNE.N    ??OSTaskSemPend_5
   1578                  OSTCBCurPtr->SemCtr--;
   1579                  ctr = OSTCBCurPtr->SemCtr;
   1580          #if (OS_CFG_TS_EN > 0u)
   1581                  if (p_ts != (CPU_TS *)0) {
   1582                     *p_ts  = OSTCBCurPtr->TS;
   1583                  }
   1584          #if (OS_CFG_TASK_PROFILE_EN > 0u)
   1585          #if (OS_CFG_TS_EN > 0u)
   1586                  OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1587                  if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   1588                      OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1589                  }
   1590          #endif
   1591          #endif
   1592          #endif
   1593                  OS_TRACE_TASK_SEM_PEND(OSTCBCurPtr);
   1594                  CPU_CRITICAL_EXIT();
   1595                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_NONE);
   1596                 *p_err = OS_ERR_NONE;
   1597                  return (ctr);
   1598              }
   1599          
   1600              if ((opt & OS_OPT_PEND_NON_BLOCKING) != 0u) {               /* Caller wants to block if not available?              */
   \   00000050   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000052   0x0430             LSLS     R0,R6,#+16
   \   00000054   0xD520             BPL.N    ??OSTaskSemPend_6
   1601                  CPU_CRITICAL_EXIT();
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       CPU_SR_Restore
   1602          #if (OS_CFG_TS_EN > 0u)
   1603                  if (p_ts != (CPU_TS *)0) {
   1604                      *p_ts  = 0u;
   1605                  }
   1606          #endif
   1607                  OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1608                  OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_PEND_WOULD_BLOCK);
   1609                 *p_err = OS_ERR_PEND_WOULD_BLOCK;                        /* No                                                   */
   \   0000005C   0xF246 0x10B0      MOVW     R0,#+25008
   \   00000060   0x8020             STRH     R0,[R4, #+0]
   1610                  return (0u);
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE056             B.N      ??OSTaskSemPend_1
   1611              } else {                                                    /* Yes                                                  */
   \                     ??OSTaskSemPend_4: (+1)
   \   00000066   0xF645 0x6025      MOVW     R0,#+24101
   \   0000006A   0x8020             STRH     R0,[R4, #+0]
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE051             B.N      ??OSTaskSemPend_1
   \                     ??OSTaskSemPend_5: (+1)
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x6C00             LDR      R0,[R0, #+64]
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0x6408             STR      R0,[R1, #+64]
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x6C05             LDR      R5,[R0, #+64]
   \   0000008A   0x0038             MOVS     R0,R7
   \   0000008C   0x.... 0x....      BL       CPU_SR_Restore
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x8020             STRH     R0,[R4, #+0]
   \   00000094   0x0028             MOVS     R0,R5
   \   00000096   0xE03D             B.N      ??OSTaskSemPend_1
   1612                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't pend when the scheduler is locked              */
   \                     ??OSTaskSemPend_6: (+1)
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD007             BEQ.N    ??OSTaskSemPend_7
   1613          #if (OS_CFG_TS_EN > 0u)
   1614                      if (p_ts != (CPU_TS *)0) {
   1615                         *p_ts  = 0u;
   1616                      }
   1617          #endif
   1618                      CPU_CRITICAL_EXIT();
   \   000000A2   0x0038             MOVS     R0,R7
   \   000000A4   0x.... 0x....      BL       CPU_SR_Restore
   1619                      OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1620                      OS_TRACE_TASK_SEM_PEND_EXIT(OS_ERR_SCHED_LOCKED);
   1621                     *p_err = OS_ERR_SCHED_LOCKED;
   \   000000A8   0xF646 0x5063      MOVW     R0,#+28003
   \   000000AC   0x8020             STRH     R0,[R4, #+0]
   1622                      return (0u);
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xE030             B.N      ??OSTaskSemPend_1
   1623                  }
   1624              }
   1625          
   1626              OS_Pend((OS_PEND_OBJ *)0,                                   /* Block task pending on Signal                         */
   1627                       OSTCBCurPtr,
   1628                       OS_TASK_PEND_ON_TASK_SEM,
   1629                       timeout);
   \                     ??OSTaskSemPend_7: (+1)
   \   000000B2   0x002B             MOVS     R3,R5
   \   000000B4   0x2207             MOVS     R2,#+7
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000BA   0x6801             LDR      R1,[R0, #+0]
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      BL       OS_Pend
   1630              CPU_CRITICAL_EXIT();
   \   000000C2   0x0038             MOVS     R0,R7
   \   000000C4   0x.... 0x....      BL       CPU_SR_Restore
   1631              OS_TRACE_TASK_SEM_PEND_BLOCK(OSTCBCurPtr);
   1632              OSSched();                                                  /* Find next highest priority task ready to run         */
   \   000000C8   0x.... 0x....      BL       OSSched
   1633          
   1634              CPU_CRITICAL_ENTER();
   \   000000CC   0x2040             MOVS     R0,#+64
   \   000000CE   0x.... 0x....      BL       CPU_SR_Save
   1635              switch (OSTCBCurPtr->PendStatus) {                          /* See if we timed-out or aborted                       */
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000D6   0x6809             LDR      R1,[R1, #+0]
   \   000000D8   0xF891 0x102D      LDRB     R1,[R1, #+45]
   \   000000DC   0x2900             CMP      R1,#+0
   \   000000DE   0xD004             BEQ.N    ??OSTaskSemPend_8
   \   000000E0   0x2901             CMP      R1,#+1
   \   000000E2   0xD005             BEQ.N    ??OSTaskSemPend_9
   \   000000E4   0x2903             CMP      R1,#+3
   \   000000E6   0xD007             BEQ.N    ??OSTaskSemPend_10
   \   000000E8   0xE00A             B.N      ??OSTaskSemPend_11
   1636                  case OS_STATUS_PEND_OK:
   1637          #if (OS_CFG_TS_EN > 0u)
   1638                       if (p_ts != (CPU_TS *)0) {
   1639                          *p_ts                    =  OSTCBCurPtr->TS;
   1640          #if (OS_CFG_TASK_PROFILE_EN > 0u)
   1641          #if (OS_CFG_TS_EN > 0u)
   1642                          OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
   1643                          if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
   1644                              OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
   1645                          }
   1646          #endif
   1647          #endif
   1648                       }
   1649          #endif
   1650                       OS_TRACE_TASK_SEM_PEND(OSTCBCurPtr);
   1651                      *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPend_8: (+1)
   \   000000EA   0x2100             MOVS     R1,#+0
   \   000000EC   0x8021             STRH     R1,[R4, #+0]
   1652                       break;
   \   000000EE   0xE00A             B.N      ??OSTaskSemPend_12
   1653          
   1654                  case OS_STATUS_PEND_ABORT:
   1655          #if (OS_CFG_TS_EN > 0u)
   1656                       if (p_ts != (CPU_TS *)0) {
   1657                          *p_ts = OSTCBCurPtr->TS;
   1658                       }
   1659          #endif
   1660                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1661                      *p_err = OS_ERR_PEND_ABORT;                         /* Indicate that we aborted                             */
   \                     ??OSTaskSemPend_9: (+1)
   \   000000F0   0xF246 0x11A9      MOVW     R1,#+25001
   \   000000F4   0x8021             STRH     R1,[R4, #+0]
   1662                       break;
   \   000000F6   0xE006             B.N      ??OSTaskSemPend_12
   1663          
   1664                  case OS_STATUS_PEND_TIMEOUT:
   1665          #if (OS_CFG_TS_EN > 0u)
   1666                       if (p_ts != (CPU_TS *)0) {
   1667                          *p_ts = 0u;
   1668                       }
   1669          #endif
   1670                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1671                      *p_err = OS_ERR_TIMEOUT;                            /* Indicate that we didn't get event within TO          */
   \                     ??OSTaskSemPend_10: (+1)
   \   000000F8   0xF247 0x21D9      MOVW     R1,#+29401
   \   000000FC   0x8021             STRH     R1,[R4, #+0]
   1672                       break;
   \   000000FE   0xE002             B.N      ??OSTaskSemPend_12
   1673          
   1674                  default:
   1675                       OS_TRACE_TASK_SEM_PEND_FAILED(OSTCBCurPtr);
   1676                      *p_err = OS_ERR_STATUS_INVALID;
   \                     ??OSTaskSemPend_11: (+1)
   \   00000100   0xF646 0x612E      MOVW     R1,#+28206
   \   00000104   0x8021             STRH     R1,[R4, #+0]
   1677                       break;
   1678              }
   1679              ctr = OSTCBCurPtr->SemCtr;
   \                     ??OSTaskSemPend_12: (+1)
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000010A   0x6809             LDR      R1,[R1, #+0]
   \   0000010C   0x6C0C             LDR      R4,[R1, #+64]
   1680              CPU_CRITICAL_EXIT();
   \   0000010E   0x.... 0x....      BL       CPU_SR_Restore
   1681              OS_TRACE_TASK_SEM_PEND_EXIT(*p_err);
   1682              return (ctr);
   \   00000112   0x0020             MOVS     R0,R4
   \                     ??OSTaskSemPend_1: (+1)
   \   00000114   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1683          }
   1684          
   1685          
   1686          /*
   1687          ************************************************************************************************************************
   1688          *                                               ABORT WAITING FOR A SIGNAL
   1689          *
   1690          * Description: This function aborts & readies the task specified.  This function should be used to fault-abort the wait
   1691          *              for a signal, rather than to normally post the signal to the task via OSTaskSemPost().
   1692          *
   1693          * Arguments  : p_tcb     is a pointer to the task to pend abort
   1694          *
   1695          *              opt       provides options for this function:
   1696          *
   1697          *                            OS_OPT_POST_NONE         No option selected
   1698          *                            OS_OPT_POST_NO_SCHED     Indicates that the scheduler will not be called.
   1699          *
   1700          *              p_err     is a pointer to a variable that will contain an error code returned by this function.
   1701          *
   1702          *                            OS_ERR_NONE               If the task was readied and informed of the aborted wait
   1703          *                            OS_ERR_OPT_INVALID        You specified an invalid option
   1704          *                            OS_ERR_OS_NOT_RUNNING     If uC/OS-III is not running yet
   1705          *                            OS_ERR_PEND_ABORT_ISR     If you tried calling this function from an ISR
   1706          *                            OS_ERR_PEND_ABORT_NONE    If the task was not waiting for a signal
   1707          *                            OS_ERR_PEND_ABORT_SELF    If you attempted to pend abort the calling task.  This is not
   1708          *                                                      possible since the calling task cannot be pending because it's
   1709          *                                                      running
   1710          *
   1711          * Returns    : == OS_FALSE   if task was not waiting for a message, or upon error.
   1712          *              == OS_TRUE    if task was waiting for a message and was readied and informed.
   1713          *
   1714          * Note(s)    : none
   1715          ************************************************************************************************************************
   1716          */
   1717          
   1718          #if (OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   1719          CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
   1720                                           OS_OPT   opt,
   1721                                           OS_ERR  *p_err)
   1722          {
   \                     OSTaskSemPendAbort: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1723              CPU_TS  ts;
   1724              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   1725          
   1726          
   1727          
   1728          #ifdef OS_SAFETY_CRITICAL
   1729              if (p_err == (OS_ERR *)0) {
   1730                  OS_SAFETY_CRITICAL_EXCEPTION();
   1731                  return (OS_FALSE);
   1732              }
   1733          #endif
   1734          
   1735          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   1736              if (OSIntNestingCtr > 0u) {                                 /* See if called from ISR ...                           */
   \   0000000A   0x....             LDR.N    R0,??DataTable12
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??OSTaskSemPendAbort_0
   1737                 *p_err = OS_ERR_PEND_ABORT_ISR;                          /* ... can't Pend Abort from an ISR                     */
   \   00000012   0xF246 0x10AA      MOVW     R0,#+25002
   \   00000016   0x8030             STRH     R0,[R6, #+0]
   1738                  return (OS_FALSE);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE046             B.N      ??OSTaskSemPendAbort_1
   1739              }
   1740          #endif
   1741          
   1742          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
   1743              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \                     ??OSTaskSemPendAbort_0: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable13
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD004             BEQ.N    ??OSTaskSemPendAbort_2
   1744                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000024   0xF645 0x6089      MOVW     R0,#+24201
   \   00000028   0x8030             STRH     R0,[R6, #+0]
   1745                  return (OS_FALSE);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE03D             B.N      ??OSTaskSemPendAbort_1
   1746              }
   1747          #endif
   1748          
   1749          #if (OS_CFG_ARG_CHK_EN > 0u)
   1750              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSTaskSemPendAbort_2: (+1)
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD002             BEQ.N    ??OSTaskSemPendAbort_3
   \   00000036   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000003A   0xD110             BNE.N    ??OSTaskSemPendAbort_4
   1751                  case OS_OPT_POST_NONE:
   1752                  case OS_OPT_POST_NO_SCHED:
   1753                       break;
   1754          
   1755                  default:
   1756                      *p_err = OS_ERR_OPT_INVALID;
   1757                       return (OS_FALSE);
   1758              }
   1759          #endif
   1760          
   1761              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemPendAbort_3: (+1)
   \   0000003C   0x2040             MOVS     R0,#+64
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   1762              if ((p_tcb == (OS_TCB *)0) ||                               /* Pend abort self?                                     */
   1763                  (p_tcb == OSTCBCurPtr)) {
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD004             BEQ.N    ??OSTaskSemPendAbort_5
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x428C             CMP      R4,R1
   \   0000004E   0xD10B             BNE.N    ??OSTaskSemPendAbort_6
   1764                  CPU_CRITICAL_EXIT();                                    /* ... doesn't make sense!                              */
   \                     ??OSTaskSemPendAbort_5: (+1)
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
   1765                 *p_err = OS_ERR_PEND_ABORT_SELF;
   \   00000054   0xF246 0x10AC      MOVW     R0,#+25004
   \   00000058   0x8030             STRH     R0,[R6, #+0]
   1766                  return (OS_FALSE);
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xE025             B.N      ??OSTaskSemPendAbort_1
   1767              }
   \                     ??OSTaskSemPendAbort_4: (+1)
   \   0000005E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000062   0x8030             STRH     R0,[R6, #+0]
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE020             B.N      ??OSTaskSemPendAbort_1
   1768          
   1769              if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {            /* Is task waiting for a signal?                        */
   \                     ??OSTaskSemPendAbort_6: (+1)
   \   00000068   0xF894 0x102C      LDRB     R1,[R4, #+44]
   \   0000006C   0x2907             CMP      R1,#+7
   \   0000006E   0xD006             BEQ.N    ??OSTaskSemPendAbort_7
   1770                  CPU_CRITICAL_EXIT();
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
   1771                 *p_err = OS_ERR_PEND_ABORT_NONE;
   \   00000074   0xF246 0x10AB      MOVW     R0,#+25003
   \   00000078   0x8030             STRH     R0,[R6, #+0]
   1772                  return (OS_FALSE);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE015             B.N      ??OSTaskSemPendAbort_1
   1773              }
   1774              CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPendAbort_7: (+1)
   \   0000007E   0x.... 0x....      BL       CPU_SR_Restore
   1775          
   1776              CPU_CRITICAL_ENTER();
   \   00000082   0x2040             MOVS     R0,#+64
   \   00000084   0x.... 0x....      BL       CPU_SR_Save
   \   00000088   0x0007             MOVS     R7,R0
   1777          #if (OS_CFG_TS_EN > 0u)
   1778              ts = OS_TS_GET();
   1779          #else
   1780              ts = 0u;
   \   0000008A   0x2100             MOVS     R1,#+0
   1781          #endif
   1782              OS_PendAbort(p_tcb,                                         /* Abort the pend                                       */
   1783                           ts,
   1784                           OS_STATUS_PEND_ABORT);
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       OS_PendAbort
   1785              CPU_CRITICAL_EXIT();
   \   00000094   0x0038             MOVS     R0,R7
   \   00000096   0x.... 0x....      BL       CPU_SR_Restore
   1786              if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   0000009A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000009C   0x0428             LSLS     R0,R5,#+16
   \   0000009E   0xD401             BMI.N    ??OSTaskSemPendAbort_8
   1787                  OSSched();                                              /* Run the scheduler                                    */
   \   000000A0   0x.... 0x....      BL       OSSched
   1788              }
   1789             *p_err = OS_ERR_NONE;
   \                     ??OSTaskSemPendAbort_8: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x8030             STRH     R0,[R6, #+0]
   1790              return (OS_TRUE);
   \   000000A8   0x2001             MOVS     R0,#+1
   \                     ??OSTaskSemPendAbort_1: (+1)
   \   000000AA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1791          }
   1792          #endif
   1793          
   1794          
   1795          /*
   1796          ************************************************************************************************************************
   1797          *                                                    SIGNAL A TASK
   1798          *
   1799          * Description: This function is called to signal a task waiting for a signal.
   1800          *
   1801          * Arguments  : p_tcb     is the pointer to the TCB of the task to signal.  A NULL pointer indicates that you are sending
   1802          *                        a signal to yourself.
   1803          *
   1804          *              opt       determines the type of POST performed:
   1805          *
   1806          *                             OS_OPT_POST_NONE         No option
   1807          *                             OS_OPT_POST_NO_SCHED     Do not call the scheduler
   1808          *
   1809          *              p_err     is a pointer to an error code returned by this function:
   1810          *
   1811          *                            OS_ERR_NONE              If the requested task is signaled
   1812          *                            OS_ERR_OPT_INVALID       If you specified an invalid option
   1813          *                            OS_ERR_OS_NOT_RUNNING    If uC/OS-III is not running yet
   1814          *                            OS_ERR_SEM_OVF           If the post would cause the semaphore count to overflow
   1815          *                            OS_ERR_STATE_INVALID     If the task is in an invalid state.  This should never happen
   1816          *                                                     and if it does, would be considered a system failure
   1817          *
   1818          * Returns    : The current value of the task's signal counter or 0 if called from an ISR
   1819          *
   1820          * Note(s)    : none
   1821          ************************************************************************************************************************
   1822          */
   1823          

   \                                 In section .text, align 2, keep-with-next
   1824          OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
   1825                                     OS_OPT   opt,
   1826                                     OS_ERR  *p_err)
   1827          {
   \                     OSTaskSemPost: (+1)
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1828              OS_SEM_CTR  ctr;
   1829              CPU_TS      ts;
   1830              CPU_SR_ALLOC();
   \   0000000A   0x2000             MOVS     R0,#+0
   1831          
   1832          
   1833          #ifdef OS_SAFETY_CRITICAL
   1834              if (p_err == (OS_ERR *)0) {
   1835                  OS_SAFETY_CRITICAL_EXCEPTION();
   1836                  return (0u);
   1837              }
   1838          #endif
   1839          
   1840              OS_TRACE_TASK_SEM_POST_ENTER(p_tcb, opt);
   1841          
   1842          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)
   1843              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is the kernel running?                               */
   \   0000000C   0x....             LDR.N    R0,??DataTable13
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ.N    ??OSTaskSemPost_0
   1844                  OS_TRACE_TASK_SEM_POST_EXIT(OS_ERR_OS_NOT_RUNNING);
   1845                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000014   0xF645 0x6089      MOVW     R0,#+24201
   \   00000018   0x8030             STRH     R0,[R6, #+0]
   1846                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE06E             B.N      ??OSTaskSemPost_1
   1847              }
   1848          #endif
   1849          
   1850          #if (OS_CFG_ARG_CHK_EN > 0u)
   1851              switch (opt) {                                              /* Validate 'opt'                                       */
   \                     ??OSTaskSemPost_0: (+1)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD002             BEQ.N    ??OSTaskSemPost_2
   \   00000026   0xF5B0 0x4F00      CMP      R0,#+32768
   \   0000002A   0xD128             BNE.N    ??OSTaskSemPost_3
   1852                  case OS_OPT_POST_NONE:
   1853                  case OS_OPT_POST_NO_SCHED:
   1854                       break;
   1855          
   1856                  default:
   1857                       OS_TRACE_TASK_SEM_POST_FAILED(p_tcb);
   1858                       OS_TRACE_TASK_SEM_POST_EXIT(OS_ERR_OPT_INVALID);
   1859                      *p_err =  OS_ERR_OPT_INVALID;
   1860                       return (0u);
   1861              }
   1862          #endif
   1863          
   1864          #if (OS_CFG_TS_EN > 0u)
   1865              ts = OS_TS_GET();                                           /* Get timestamp                                        */
   1866          #else
   1867              ts = 0u;
   \                     ??OSTaskSemPost_2: (+1)
   \   0000002C   0xF05F 0x0800      MOVS     R8,#+0
   1868          #endif
   1869          
   1870              OS_TRACE_TASK_SEM_POST(p_tcb);
   1871          
   1872              CPU_CRITICAL_ENTER();
   \   00000030   0x2040             MOVS     R0,#+64
   \   00000032   0x.... 0x....      BL       CPU_SR_Save
   \   00000036   0x0007             MOVS     R7,R0
   1873              if (p_tcb == (OS_TCB *)0) {                                 /* Post signal to 'self'?                               */
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD102             BNE.N    ??OSTaskSemPost_4
   1874                  p_tcb = OSTCBCurPtr;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000040   0x6804             LDR      R4,[R0, #+0]
   1875              }
   1876          #if (OS_CFG_TS_EN > 0u)
   1877              p_tcb->TS = ts;
   1878          #endif
   1879             *p_err     = OS_ERR_NONE;                                    /* Assume we won't have any errors                      */
   \                     ??OSTaskSemPost_4: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x8030             STRH     R0,[R6, #+0]
   1880              switch (p_tcb->TaskState) {
   \   00000046   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00B             BEQ.N    ??OSTaskSemPost_5
   \   0000004E   0x2802             CMP      R0,#+2
   \   00000050   0xD022             BEQ.N    ??OSTaskSemPost_6
   \   00000052   0xD308             BCC.N    ??OSTaskSemPost_5
   \   00000054   0x2804             CMP      R0,#+4
   \   00000056   0xD006             BEQ.N    ??OSTaskSemPost_5
   \   00000058   0xD31E             BCC.N    ??OSTaskSemPost_6
   \   0000005A   0x2806             CMP      R0,#+6
   \   0000005C   0xD01C             BEQ.N    ??OSTaskSemPost_6
   \   0000005E   0xD302             BCC.N    ??OSTaskSemPost_5
   \   00000060   0x2807             CMP      R0,#+7
   \   00000062   0xD019             BEQ.N    ??OSTaskSemPost_6
   \   00000064   0xE042             B.N      ??OSTaskSemPost_7
   1881                  case OS_TASK_STATE_RDY:
   1882                  case OS_TASK_STATE_DLY:
   1883                  case OS_TASK_STATE_SUSPENDED:
   1884                  case OS_TASK_STATE_DLY_SUSPENDED:
   1885                       if (p_tcb->SemCtr == (OS_SEM_CTR)-1) {
   \                     ??OSTaskSemPost_5: (+1)
   \   00000066   0x6C20             LDR      R0,[R4, #+64]
   \   00000068   0xF110 0x0F01      CMN      R0,#+1
   \   0000006C   0xD10C             BNE.N    ??OSTaskSemPost_8
   1886                           CPU_CRITICAL_EXIT();
   \   0000006E   0x0038             MOVS     R0,R7
   \   00000070   0x.... 0x....      BL       CPU_SR_Restore
   1887                          *p_err = OS_ERR_SEM_OVF;
   \   00000074   0xF646 0x50C5      MOVW     R0,#+28101
   \   00000078   0x8030             STRH     R0,[R6, #+0]
   1888                           OS_TRACE_SEM_POST_EXIT(*p_err);
   1889                           return (0u);
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE03E             B.N      ??OSTaskSemPost_1
   1890                       }
   \                     ??OSTaskSemPost_3: (+1)
   \   0000007E   0xF645 0x6025      MOVW     R0,#+24101
   \   00000082   0x8030             STRH     R0,[R6, #+0]
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0xE039             B.N      ??OSTaskSemPost_1
   1891                       p_tcb->SemCtr++;                                   /* Task signaled is not pending on anything             */
   \                     ??OSTaskSemPost_8: (+1)
   \   00000088   0x6C20             LDR      R0,[R4, #+64]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x6420             STR      R0,[R4, #+64]
   1892                       ctr = p_tcb->SemCtr;
   \   0000008E   0x6C24             LDR      R4,[R4, #+64]
   1893                       CPU_CRITICAL_EXIT();
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x.... 0x....      BL       CPU_SR_Restore
   1894                       break;
   \   00000096   0xE030             B.N      ??OSTaskSemPost_9
   1895          
   1896                  case OS_TASK_STATE_PEND:
   1897                  case OS_TASK_STATE_PEND_TIMEOUT:
   1898                  case OS_TASK_STATE_PEND_SUSPENDED:
   1899                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1900                       if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?               */
   \                     ??OSTaskSemPost_6: (+1)
   \   00000098   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   0000009C   0x2807             CMP      R0,#+7
   \   0000009E   0xD111             BNE.N    ??OSTaskSemPost_10
   1901                           OS_Post((OS_PEND_OBJ *)0,                      /* Task is pending on signal                            */
   1902                                    p_tcb,
   1903                                    (void *)0,
   1904                                    0u,
   1905                                    ts);
   \   000000A0   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000A4   0x2300             MOVS     R3,#+0
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x0021             MOVS     R1,R4
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      BL       OS_Post
   1906                           ctr = p_tcb->SemCtr;
   \   000000B0   0x6C24             LDR      R4,[R4, #+64]
   1907                           CPU_CRITICAL_EXIT();
   \   000000B2   0x0038             MOVS     R0,R7
   \   000000B4   0x.... 0x....      BL       CPU_SR_Restore
   1908                           if ((opt & OS_OPT_POST_NO_SCHED) == 0u) {
   \   000000B8   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000BA   0x0428             LSLS     R0,R5,#+16
   \   000000BC   0xD415             BMI.N    ??OSTaskSemPost_11
   1909                               OSSched();                                 /* Run the scheduler                                    */
   \   000000BE   0x.... 0x....      BL       OSSched
   \   000000C2   0xE012             B.N      ??OSTaskSemPost_11
   1910                           }
   1911                       } else {
   1912                           if (p_tcb->SemCtr == (OS_SEM_CTR)-1) {
   \                     ??OSTaskSemPost_10: (+1)
   \   000000C4   0x6C20             LDR      R0,[R4, #+64]
   \   000000C6   0xF110 0x0F01      CMN      R0,#+1
   \   000000CA   0xD107             BNE.N    ??OSTaskSemPost_12
   1913                               CPU_CRITICAL_EXIT();
   \   000000CC   0x0038             MOVS     R0,R7
   \   000000CE   0x.... 0x....      BL       CPU_SR_Restore
   1914                              *p_err = OS_ERR_SEM_OVF;
   \   000000D2   0xF646 0x50C5      MOVW     R0,#+28101
   \   000000D6   0x8030             STRH     R0,[R6, #+0]
   1915                               OS_TRACE_SEM_POST_EXIT(*p_err);
   1916                               return (0u);
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xE00F             B.N      ??OSTaskSemPost_1
   1917                           }
   1918                           p_tcb->SemCtr++;                               /* No,  Task signaled is NOT pending on semaphore ...   */
   \                     ??OSTaskSemPost_12: (+1)
   \   000000DC   0x6C20             LDR      R0,[R4, #+64]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x6420             STR      R0,[R4, #+64]
   1919                           ctr = p_tcb->SemCtr;                           /* ... it must be waiting on something else             */
   \   000000E2   0x6C24             LDR      R4,[R4, #+64]
   1920                           CPU_CRITICAL_EXIT();
   \   000000E4   0x0038             MOVS     R0,R7
   \   000000E6   0x.... 0x....      BL       CPU_SR_Restore
   1921                       }
   1922                       break;
   \                     ??OSTaskSemPost_11: (+1)
   \   000000EA   0xE006             B.N      ??OSTaskSemPost_9
   1923          
   1924                  default:
   1925                       CPU_CRITICAL_EXIT();
   \                     ??OSTaskSemPost_7: (+1)
   \   000000EC   0x0038             MOVS     R0,R7
   \   000000EE   0x.... 0x....      BL       CPU_SR_Restore
   1926                      *p_err = OS_ERR_STATE_INVALID;
   \   000000F2   0xF646 0x602D      MOVW     R0,#+28205
   \   000000F6   0x8030             STRH     R0,[R6, #+0]
   1927                       ctr   = 0u;
   \   000000F8   0x2400             MOVS     R4,#+0
   1928                       break;
   1929              }
   1930          
   1931              OS_TRACE_TASK_SEM_POST_EXIT(*p_err);
   1932          
   1933              return (ctr);
   \                     ??OSTaskSemPost_9: (+1)
   \   000000FA   0x0020             MOVS     R0,R4
   \                     ??OSTaskSemPost_1: (+1)
   \   000000FC   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   1934          }
   1935          
   1936          
   1937          /*
   1938          ************************************************************************************************************************
   1939          *                                            SET THE SIGNAL COUNTER OF A TASK
   1940          *
   1941          * Description: This function is called to clear the signal counter
   1942          *
   1943          * Arguments  : p_tcb      is the pointer to the TCB of the task to clear the counter.  If you specify a NULL pointer
   1944          *                         then the signal counter of the current task will be cleared.
   1945          *
   1946          *              cnt        is the desired value of the semaphore counter
   1947          *
   1948          *              p_err      is a pointer to an error code returned by this function
   1949          *
   1950          *                             OS_ERR_NONE             If the signal counter of the requested task is set
   1951          *                             OS_ERR_SET_ISR          If the function was called from an ISR
   1952          *                             OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
   1953          *
   1954          * Returns    : none
   1955          *
   1956          * Note(s)    : none
   1957          ************************************************************************************************************************
   1958          */
   1959          

   \                                 In section .text, align 2, keep-with-next
   1960          OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
   1961                                    OS_SEM_CTR   cnt,
   1962                                    OS_ERR      *p_err)
   1963          {
   \                     OSTaskSemSet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   1964              OS_SEM_CTR  ctr;
   1965              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   1966          
   1967          
   1968          
   1969          #ifdef OS_SAFETY_CRITICAL
   1970              if (p_err == (OS_ERR *)0) {
   1971                  OS_SAFETY_CRITICAL_EXCEPTION();
   1972                  return (0u);
   1973              }
   1974          #endif
   1975          
   1976          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   1977              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??OSTaskSemSet_0
   1978                 *p_err = OS_ERR_SET_ISR;
   \   00000014   0xF646 0x50C6      MOVW     R0,#+28102
   \   00000018   0x8028             STRH     R0,[R5, #+0]
   1979                  return (0u);
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE01D             B.N      ??OSTaskSemSet_1
   1980              }
   1981          #endif
   1982          
   1983              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSemSet_0: (+1)
   \   0000001E   0x2040             MOVS     R0,#+64
   \   00000020   0x.... 0x....      BL       CPU_SR_Save
   1984              if (p_tcb == (OS_TCB *)0) {
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD102             BNE.N    ??OSTaskSemSet_2
   1985                  p_tcb = OSTCBCurPtr;
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000002C   0x680C             LDR      R4,[R1, #+0]
   1986              }
   1987          
   1988              if (((p_tcb->TaskState   & OS_TASK_STATE_PEND) != 0u) &&    /* Not allowed when a task is waiting.                  */
   1989                   (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM)) {
   \                     ??OSTaskSemSet_2: (+1)
   \   0000002E   0xF894 0x102E      LDRB     R1,[R4, #+46]
   \   00000032   0x0789             LSLS     R1,R1,#+30
   \   00000034   0xD50A             BPL.N    ??OSTaskSemSet_3
   \   00000036   0xF894 0x102C      LDRB     R1,[R4, #+44]
   \   0000003A   0x2907             CMP      R1,#+7
   \   0000003C   0xD106             BNE.N    ??OSTaskSemSet_3
   1990                  CPU_CRITICAL_EXIT();
   \   0000003E   0x.... 0x....      BL       CPU_SR_Restore
   1991                 *p_err = OS_ERR_TASK_WAITING;
   \   00000042   0xF247 0x105F      MOVW     R0,#+29023
   \   00000046   0x8028             STRH     R0,[R5, #+0]
   1992                  return (0u);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE006             B.N      ??OSTaskSemSet_1
   1993              }
   1994          
   1995              ctr           =  p_tcb->SemCtr;
   \                     ??OSTaskSemSet_3: (+1)
   \   0000004C   0x6C27             LDR      R7,[R4, #+64]
   1996              p_tcb->SemCtr = (OS_SEM_CTR)cnt;
   \   0000004E   0x6426             STR      R6,[R4, #+64]
   1997              CPU_CRITICAL_EXIT();
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
   1998             *p_err         =  OS_ERR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x8028             STRH     R0,[R5, #+0]
   1999              return (ctr);
   \   00000058   0x0038             MOVS     R0,R7
   \                     ??OSTaskSemSet_1: (+1)
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2000          }
   2001          
   2002          
   2003          /*
   2004          ************************************************************************************************************************
   2005          *                                                    STACK CHECKING
   2006          *
   2007          * Description: This function is called to calculate the amount of free memory left on the specified task's stack.
   2008          *
   2009          * Arguments  : p_tcb       is a pointer to the TCB of the task to check.  If you specify a NULL pointer then
   2010          *                          you are specifying that you want to check the stack of the current task.
   2011          *
   2012          *              p_free      is a pointer to a variable that will receive the number of free 'entries' on the task's stack.
   2013          *
   2014          *              p_used      is a pointer to a variable that will receive the number of used 'entries' on the task's stack.
   2015          *
   2016          *              p_err       is a pointer to a variable that will contain an error code.
   2017          *
   2018          *                              OS_ERR_NONE               Upon success
   2019          *                              OS_ERR_PTR_INVALID        If either 'p_free' or 'p_used' are NULL pointers
   2020          *                              OS_ERR_TASK_NOT_EXIST     If the stack pointer of the task is a NULL pointer
   2021          *                              OS_ERR_TASK_OPT           If you did NOT specified OS_OPT_TASK_STK_CHK when the task
   2022          *                                                        was created
   2023          *                              OS_ERR_TASK_STK_CHK_ISR   You called this function from an ISR
   2024          *
   2025          * Returns    : none
   2026          *
   2027          * Note(s)    : none
   2028          ************************************************************************************************************************
   2029          */
   2030          
   2031          #if (OS_CFG_STAT_TASK_STK_CHK_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   2032          void  OSTaskStkChk (OS_TCB        *p_tcb,
   2033                              CPU_STK_SIZE  *p_free,
   2034                              CPU_STK_SIZE  *p_used,
   2035                              OS_ERR        *p_err)
   2036          {
   \                     OSTaskStkChk: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001F             MOVS     R7,R3
   2037              CPU_STK_SIZE  free_stk;
   2038              CPU_STK_SIZE  stk_size;
   2039              CPU_STK      *p_stk;
   2040              CPU_SR_ALLOC();
   \   0000000C   0x2000             MOVS     R0,#+0
   2041          
   2042          
   2043          #ifdef OS_SAFETY_CRITICAL
   2044              if (p_err == (OS_ERR *)0) {
   2045                  OS_SAFETY_CRITICAL_EXCEPTION();
   2046                  return;
   2047              }
   2048          #endif
   2049          
   2050          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   2051              if (OSIntNestingCtr > 0u) {                                 /* See if trying to check stack from ISR                */
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??OSTaskStkChk_0
   2052                 *p_err = OS_ERR_TASK_STK_CHK_ISR;
   \   00000018   0xF247 0x1059      MOVW     R0,#+29017
   \   0000001C   0x8038             STRH     R0,[R7, #+0]
   2053                  return;
   \   0000001E   0xE043             B.N      ??OSTaskStkChk_1
   2054              }
   2055          #endif
   2056          
   2057          #if (OS_CFG_ARG_CHK_EN > 0u)
   2058              if (p_free == (CPU_STK_SIZE *)0) {                          /* User must specify valid destinations for the sizes   */
   \                     ??OSTaskStkChk_0: (+1)
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD103             BNE.N    ??OSTaskStkChk_2
   2059                 *p_err = OS_ERR_PTR_INVALID;
   \   00000024   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000028   0x8038             STRH     R0,[R7, #+0]
   2060                  return;
   \   0000002A   0xE03D             B.N      ??OSTaskStkChk_1
   2061              }
   2062          
   2063              if (p_used == (CPU_STK_SIZE *)0) {
   \                     ??OSTaskStkChk_2: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD103             BNE.N    ??OSTaskStkChk_3
   2064                 *p_err = OS_ERR_PTR_INVALID;
   \   00000030   0xF246 0x20D5      MOVW     R0,#+25301
   \   00000034   0x8038             STRH     R0,[R7, #+0]
   2065                  return;
   \   00000036   0xE037             B.N      ??OSTaskStkChk_1
   2066              }
   2067          #endif
   2068          
   2069              CPU_CRITICAL_ENTER();
   \                     ??OSTaskStkChk_3: (+1)
   \   00000038   0x2040             MOVS     R0,#+64
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   2070              if (p_tcb == (OS_TCB *)0) {                                 /* Check the stack of the current task?                 */
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD102             BNE.N    ??OSTaskStkChk_4
   2071                  p_tcb = OSTCBCurPtr;                                    /* Yes                                                  */
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000046   0x680E             LDR      R6,[R1, #+0]
   2072              }
   2073          
   2074              if (p_tcb->StkPtr == (CPU_STK *)0) {                        /* Make sure task exist                                 */
   \                     ??OSTaskStkChk_4: (+1)
   \   00000048   0x6831             LDR      R1,[R6, #+0]
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD109             BNE.N    ??OSTaskStkChk_5
   2075                  CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_SR_Restore
   2076                 *p_free = 0u;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6020             STR      R0,[R4, #+0]
   2077                 *p_used = 0u;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6028             STR      R0,[R5, #+0]
   2078                 *p_err  = OS_ERR_TASK_NOT_EXIST;
   \   0000005A   0xF247 0x1052      MOVW     R0,#+29010
   \   0000005E   0x8038             STRH     R0,[R7, #+0]
   2079                  return;
   \   00000060   0xE022             B.N      ??OSTaskStkChk_1
   2080              }
   2081          
   2082              if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == 0u) {             /* Make sure stack checking option is set               */
   \                     ??OSTaskStkChk_5: (+1)
   \   00000062   0xF896 0x103C      LDRB     R1,[R6, #+60]
   \   00000066   0x07C9             LSLS     R1,R1,#+31
   \   00000068   0xD409             BMI.N    ??OSTaskStkChk_6
   2083                  CPU_CRITICAL_EXIT();
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
   2084                 *p_free = 0u;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x6020             STR      R0,[R4, #+0]
   2085                 *p_used = 0u;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6028             STR      R0,[R5, #+0]
   2086                 *p_err  = OS_ERR_TASK_OPT;
   \   00000076   0xF247 0x1054      MOVW     R0,#+29012
   \   0000007A   0x8038             STRH     R0,[R7, #+0]
   2087                  return;
   \   0000007C   0xE014             B.N      ??OSTaskStkChk_1
   2088              }
   2089          
   2090          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2091              p_stk = p_tcb->StkBasePtr;                                  /* Start at the lowest memory and go up                 */
   \                     ??OSTaskStkChk_6: (+1)
   \   0000007E   0xF8D6 0x801C      LDR      R8,[R6, #+28]
   2092          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
   2093              p_stk += OS_CFG_TASK_STK_REDZONE_DEPTH;
   2094          #endif
   2095          #else
   2096              p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;            /* Start at the highest memory and go down              */
   2097          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
   2098              p_stk -= OS_CFG_TASK_STK_REDZONE_DEPTH;
   2099          #endif
   2100          #endif
   2101          
   2102              stk_size = p_tcb->StkSize;
   \   00000082   0x6BB6             LDR      R6,[R6, #+56]
   2103              CPU_CRITICAL_EXIT();
   \   00000084   0x.... 0x....      BL       CPU_SR_Restore
   2104          
   2105              free_stk = 0u;
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0xE002             B.N      ??OSTaskStkChk_7
   2106                                                                          /* Compute the number of zero entries on the stk        */
   2107          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2108              while ((free_stk  < stk_size) &&
   2109                     (*p_stk   ==       0u)) {
   2110                  p_stk++;
   \                     ??OSTaskStkChk_8: (+1)
   \   0000008C   0xF118 0x0804      ADDS     R8,R8,#+4
   2111                  free_stk++;
   \   00000090   0x1C49             ADDS     R1,R1,#+1
   2112              }
   \                     ??OSTaskStkChk_7: (+1)
   \   00000092   0x42B1             CMP      R1,R6
   \   00000094   0xD203             BCS.N    ??OSTaskStkChk_9
   \   00000096   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD0F6             BEQ.N    ??OSTaskStkChk_8
   2113          #else
   2114              while ((free_stk  < stk_size) &&
   2115                     (*p_stk   ==       0u)) {
   2116                  free_stk++;
   2117                  p_stk--;
   2118              }
   2119          #endif
   2120             *p_free = free_stk;
   \                     ??OSTaskStkChk_9: (+1)
   \   0000009E   0x6021             STR      R1,[R4, #+0]
   2121             *p_used = (stk_size - free_stk);                             /* Compute number of entries used on the stack          */
   \   000000A0   0x1A71             SUBS     R1,R6,R1
   \   000000A2   0x6029             STR      R1,[R5, #+0]
   2122             *p_err  = OS_ERR_NONE;
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x8038             STRH     R0,[R7, #+0]
   2123          }
   \                     ??OSTaskStkChk_1: (+1)
   \   000000A8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2124          #endif
   2125          
   2126          
   2127          /*
   2128          ************************************************************************************************************************
   2129          *                                            CHECK THE STACK REDZONE OF A TASK
   2130          *
   2131          * Description: Verify a task's stack redzone.
   2132          *
   2133          * Arguments  : p_tcb     is a pointer to the TCB of the task to check or null for the current task.
   2134          *
   2135          * Returns    : If the stack is corrupted (OS_FALSE) or not (OS_TRUE).
   2136          *
   2137          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   2138          ************************************************************************************************************************
   2139          */
   2140          
   2141          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
   2142          CPU_BOOLEAN  OSTaskStkRedzoneChk (OS_TCB  *p_tcb)
   2143          {
   2144              CPU_BOOLEAN  stk_status;
   2145          
   2146          
   2147              if (p_tcb == (OS_TCB *)0) {
   2148                  p_tcb = OSTCBCurPtr;
   2149              }
   2150                                                                          /* Check if SP is valid:                                */
   2151                                                                          /*   StkBase <= SP < (StkBase + StkSize)                */
   2152              if ((p_tcb->StkPtr <   p_tcb->StkBasePtr) ||
   2153                  (p_tcb->StkPtr >= (p_tcb->StkBasePtr + p_tcb->StkSize))) {
   2154                  return (OS_FALSE);
   2155              }
   2156          
   2157              stk_status = OS_TaskStkRedzoneChk(p_tcb->StkBasePtr, p_tcb->StkSize);
   2158          
   2159              return (stk_status);
   2160          }
   2161          #endif
   2162          
   2163          
   2164          /*
   2165          ************************************************************************************************************************
   2166          *                                                   SUSPEND A TASK
   2167          *
   2168          * Description: This function is called to suspend a task.  The task can be the calling task if 'p_tcb' is a NULL pointer
   2169          *              or the pointer to the TCB of the calling task.
   2170          *
   2171          * Arguments  : p_tcb    is a pointer to the TCB to suspend.
   2172          *                       If p_tcb is a NULL pointer then, suspend the current task.
   2173          *
   2174          *              p_err    is a pointer to a variable that will receive an error code from this function.
   2175          *
   2176          *                           OS_ERR_NONE                        If the requested task is suspended
   2177          *                           OS_ERR_OS_NOT_RUNNING              If uC/OS-III is not running yet
   2178          *                           OS_ERR_SCHED_LOCKED                You can't suspend the current task is the scheduler is
   2179          *                                                                  locked
   2180          *                           OS_ERR_STATE_INVALID               If the task is in an invalid state
   2181          *                           OS_ERR_TASK_SUSPEND_CTR_OVF        If the nesting counter overflowed.
   2182          *                           OS_ERR_TASK_SUSPEND_ISR            If you called this function from an ISR
   2183          *                           OS_ERR_TASK_SUSPEND_IDLE           If you attempted to suspend the idle task which is not
   2184          *                                                                  allowed
   2185          *                           OS_ERR_TASK_SUSPEND_INT_HANDLER    If you attempted to suspend the idle task which is not
   2186          *                                                                  allowed
   2187          *
   2188          * Returns    : none
   2189          *
   2190          * Note(s)    : 1) You should use this function with great care.  If you suspend a task that is waiting for an event
   2191          *                 (i.e. a message, a semaphore, a queue ...) you will prevent this task from running when the event
   2192          *                 arrives.
   2193          ************************************************************************************************************************
   2194          */
   2195          
   2196          #if (OS_CFG_TASK_SUSPEND_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   2197          void   OSTaskSuspend (OS_TCB  *p_tcb,
   2198                                OS_ERR  *p_err)
   2199          {
   \                     OSTaskSuspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2200              CPU_SR_ALLOC();
   \   00000006   0x2000             MOVS     R0,#+0
   2201          
   2202          
   2203              OS_TRACE_TASK_SUSPEND_ENTER(p_tcb);
   2204          
   2205          #ifdef OS_SAFETY_CRITICAL
   2206              if (p_err == (OS_ERR *)0) {
   2207                  OS_SAFETY_CRITICAL_EXCEPTION();
   2208                  return;
   2209              }
   2210          #endif
   2211          
   2212          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   2213              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTaskSuspend_0
   2214                 *p_err = OS_ERR_TASK_SUSPEND_ISR;
   \   00000012   0xF247 0x105D      MOVW     R0,#+29021
   \   00000016   0x8028             STRH     R0,[R5, #+0]
   2215                  OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_TASK_SUSPEND_ISR);
   2216                  return;
   \   00000018   0xE04E             B.N      ??OSTaskSuspend_1
   2217              }
   2218          #endif
   2219          
   2220          #if (OS_CFG_TASK_IDLE_EN > 0u)
   2221              if (p_tcb == &OSIdleTaskTCB) {                              /* Make sure not suspending the idle task               */
   \                     ??OSTaskSuspend_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD103             BNE.N    ??OSTaskSuspend_2
   2222                 *p_err = OS_ERR_TASK_SUSPEND_IDLE;
   \   00000022   0xF247 0x105B      MOVW     R0,#+29019
   \   00000026   0x8028             STRH     R0,[R5, #+0]
   2223                  OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_TASK_SUSPEND_IDLE);
   2224                  return;
   \   00000028   0xE046             B.N      ??OSTaskSuspend_1
   2225              }
   2226          #endif
   2227          
   2228              CPU_CRITICAL_ENTER();
   \                     ??OSTaskSuspend_2: (+1)
   \   0000002A   0x2040             MOVS     R0,#+64
   \   0000002C   0x.... 0x....      BL       CPU_SR_Save
   \   00000030   0x0006             MOVS     R6,R0
   2229              if (p_tcb == (OS_TCB *)0) {                                 /* See if specified to suspend self                     */
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD10E             BNE.N    ??OSTaskSuspend_3
   2230                  if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Can't suspend self when the kernel isn't running     */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD006             BEQ.N    ??OSTaskSuspend_4
   2231                      CPU_CRITICAL_EXIT();
   \   00000040   0x0030             MOVS     R0,R6
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
   2232                     *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000046   0xF645 0x6089      MOVW     R0,#+24201
   \   0000004A   0x8028             STRH     R0,[R5, #+0]
   2233                      OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_OS_NOT_RUNNING);
   2234                      return;
   \   0000004C   0xE034             B.N      ??OSTaskSuspend_1
   2235                  }
   2236                  p_tcb = OSTCBCurPtr;
   \                     ??OSTaskSuspend_4: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000052   0x6804             LDR      R4,[R0, #+0]
   2237              }
   2238          
   2239              if (p_tcb == OSTCBCurPtr) {
   \                     ??OSTaskSuspend_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x4284             CMP      R4,R0
   \   0000005C   0xD10A             BNE.N    ??OSTaskSuspend_5
   2240                  if (OSSchedLockNestingCtr > 0u) {                       /* Can't suspend when the scheduler is locked           */
   \   0000005E   0x....             LDR.N    R0,??DataTable20_1
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD006             BEQ.N    ??OSTaskSuspend_5
   2241                      CPU_CRITICAL_EXIT();
   \   00000066   0x0030             MOVS     R0,R6
   \   00000068   0x.... 0x....      BL       CPU_SR_Restore
   2242                     *p_err = OS_ERR_SCHED_LOCKED;
   \   0000006C   0xF646 0x5063      MOVW     R0,#+28003
   \   00000070   0x8028             STRH     R0,[R5, #+0]
   2243                      OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_SCHED_LOCKED);
   2244                      return;
   \   00000072   0xE021             B.N      ??OSTaskSuspend_1
   2245                  }
   2246              }
   2247          
   2248             *p_err = OS_ERR_NONE;
   \                     ??OSTaskSuspend_5: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x8028             STRH     R0,[R5, #+0]
   2249              switch (p_tcb->TaskState) {
   \   00000078   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD009             BEQ.N    ??OSTaskSuspend_6
   \   00000080   0x1E40             SUBS     R0,R0,#+1
   \   00000082   0xD01A             BEQ.N    ??OSTaskSuspend_7
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0xD022             BEQ.N    ??OSTaskSuspend_8
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0xD02A             BEQ.N    ??OSTaskSuspend_9
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x2803             CMP      R0,#+3
   \   00000090   0xD931             BLS.N    ??OSTaskSuspend_10
   \   00000092   0xE044             B.N      ??OSTaskSuspend_11
   2250                  case OS_TASK_STATE_RDY:
   2251                       p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
   \                     ??OSTaskSuspend_6: (+1)
   \   00000094   0x2004             MOVS     R0,#+4
   \   00000096   0xF884 0x002E      STRB     R0,[R4, #+46]
   2252                       p_tcb->SuspendCtr = 1u;
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0xF884 0x007E      STRB     R0,[R4, #+126]
   2253                       OS_RdyListRemove(p_tcb);
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       OS_RdyListRemove
   2254                       OS_TRACE_TASK_SUSPEND(p_tcb);
   2255                       CPU_CRITICAL_EXIT();
   \   000000A6   0x0030             MOVS     R0,R6
   \   000000A8   0x.... 0x....      BL       CPU_SR_Restore
   2256                       break;
   2257          
   2258                  case OS_TASK_STATE_DLY:
   2259                       p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
   2260                       p_tcb->SuspendCtr = 1u;
   2261                       CPU_CRITICAL_EXIT();
   2262                       break;
   2263          
   2264                  case OS_TASK_STATE_PEND:
   2265                       p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
   2266                       p_tcb->SuspendCtr = 1u;
   2267                       CPU_CRITICAL_EXIT();
   2268                       break;
   2269          
   2270                  case OS_TASK_STATE_PEND_TIMEOUT:
   2271                       p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
   2272                       p_tcb->SuspendCtr = 1u;
   2273                       CPU_CRITICAL_EXIT();
   2274                       break;
   2275          
   2276                  case OS_TASK_STATE_SUSPENDED:
   2277                  case OS_TASK_STATE_DLY_SUSPENDED:
   2278                  case OS_TASK_STATE_PEND_SUSPENDED:
   2279                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2280                       if (p_tcb->SuspendCtr == (OS_NESTING_CTR)-1) {
   2281                           CPU_CRITICAL_EXIT();
   2282                          *p_err = OS_ERR_TASK_SUSPEND_CTR_OVF;
   2283                           OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_TASK_SUSPEND_CTR_OVF);
   2284                           return;
   2285                       }
   2286                       p_tcb->SuspendCtr++;
   2287                       CPU_CRITICAL_EXIT();
   2288                       break;
   2289          
   2290                  default:
   2291                       CPU_CRITICAL_EXIT();
   2292                      *p_err = OS_ERR_STATE_INVALID;
   2293                       OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_STATE_INVALID);
   2294                       return;
   2295              }
   2296          
   2297              if (OSRunning == OS_STATE_OS_RUNNING) {                     /* Only schedule when the kernel is running             */
   \                     ??OSTaskSuspend_12: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable20_5
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x2801             CMP      R0,#+1
   \   000000B2   0xD101             BNE.N    ??OSTaskSuspend_13
   2298                  OSSched();
   \   000000B4   0x.... 0x....      BL       OSSched
   2299                  OS_TRACE_TASK_SUSPEND_EXIT(OS_ERR_NONE);
   2300              }
   2301          }
   \                     ??OSTaskSuspend_13: (+1)
   \                     ??OSTaskSuspend_1: (+1)
   \   000000B8   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??OSTaskSuspend_7: (+1)
   \   000000BA   0x2005             MOVS     R0,#+5
   \   000000BC   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   000000C0   0x2001             MOVS     R0,#+1
   \   000000C2   0xF884 0x007E      STRB     R0,[R4, #+126]
   \   000000C6   0x0030             MOVS     R0,R6
   \   000000C8   0x.... 0x....      BL       CPU_SR_Restore
   \   000000CC   0xE7EE             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_8: (+1)
   \   000000CE   0x2006             MOVS     R0,#+6
   \   000000D0   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   000000D4   0x2001             MOVS     R0,#+1
   \   000000D6   0xF884 0x007E      STRB     R0,[R4, #+126]
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0x.... 0x....      BL       CPU_SR_Restore
   \   000000E0   0xE7E4             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_9: (+1)
   \   000000E2   0x2007             MOVS     R0,#+7
   \   000000E4   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   000000E8   0x2001             MOVS     R0,#+1
   \   000000EA   0xF884 0x007E      STRB     R0,[R4, #+126]
   \   000000EE   0x0030             MOVS     R0,R6
   \   000000F0   0x.... 0x....      BL       CPU_SR_Restore
   \   000000F4   0xE7DA             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_10: (+1)
   \   000000F6   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   000000FA   0x28FF             CMP      R0,#+255
   \   000000FC   0xD106             BNE.N    ??OSTaskSuspend_14
   \   000000FE   0x0030             MOVS     R0,R6
   \   00000100   0x.... 0x....      BL       CPU_SR_Restore
   \   00000104   0xF247 0x1060      MOVW     R0,#+29024
   \   00000108   0x8028             STRH     R0,[R5, #+0]
   \   0000010A   0xE7D5             B.N      ??OSTaskSuspend_1
   \                     ??OSTaskSuspend_14: (+1)
   \   0000010C   0xF894 0x007E      LDRB     R0,[R4, #+126]
   \   00000110   0x1C40             ADDS     R0,R0,#+1
   \   00000112   0xF884 0x007E      STRB     R0,[R4, #+126]
   \   00000116   0x0030             MOVS     R0,R6
   \   00000118   0x.... 0x....      BL       CPU_SR_Restore
   \   0000011C   0xE7C6             B.N      ??OSTaskSuspend_12
   \                     ??OSTaskSuspend_11: (+1)
   \   0000011E   0x0030             MOVS     R0,R6
   \   00000120   0x.... 0x....      BL       CPU_SR_Restore
   \   00000124   0xF646 0x602D      MOVW     R0,#+28205
   \   00000128   0x8028             STRH     R0,[R5, #+0]
   \   0000012A   0xE7C5             B.N      ??OSTaskSuspend_1
   2302          #endif
   2303          
   2304          
   2305          /*
   2306          ************************************************************************************************************************
   2307          *                                                CHANGE A TASK'S TIME SLICE
   2308          *
   2309          * Description: This function is called to change the value of the task's specific time slice.
   2310          *
   2311          * Arguments  : p_tcb        is the pointer to the TCB of the task to change. If you specify an NULL pointer, the current
   2312          *                           task is assumed.
   2313          *
   2314          *              time_quanta  is the number of ticks before the CPU is taken away when round-robin scheduling is enabled.
   2315          *
   2316          *              p_err        is a pointer to an error code returned by this function:
   2317          *
   2318          *                               OS_ERR_NONE       Upon success
   2319          *                               OS_ERR_SET_ISR    If you called this function from an ISR
   2320          *
   2321          * Returns    : none
   2322          *
   2323          * Note(s)    : none
   2324          ************************************************************************************************************************
   2325          */
   2326          
   2327          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   2328          void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
   2329                                     OS_TICK   time_quanta,
   2330                                     OS_ERR   *p_err)
   2331          {
   \                     OSTaskTimeQuantaSet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   2332              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
   2333          
   2334          
   2335          
   2336          #ifdef OS_SAFETY_CRITICAL
   2337              if (p_err == (OS_ERR *)0) {
   2338                  OS_SAFETY_CRITICAL_EXCEPTION();
   2339                  return;
   2340              }
   2341          #endif
   2342          
   2343          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
   2344              if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
   \   0000000A   0x....             LDR.N    R0,??DataTable20_3
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??OSTaskTimeQuantaSet_0
   2345                 *p_err = OS_ERR_SET_ISR;
   \   00000012   0xF646 0x50C6      MOVW     R0,#+28102
   \   00000016   0x8030             STRH     R0,[R6, #+0]
   2346                  return;
   \   00000018   0xE017             B.N      ??OSTaskTimeQuantaSet_1
   2347              }
   2348          #endif
   2349          
   2350              CPU_CRITICAL_ENTER();
   \                     ??OSTaskTimeQuantaSet_0: (+1)
   \   0000001A   0x2040             MOVS     R0,#+64
   \   0000001C   0x.... 0x....      BL       CPU_SR_Save
   2351              if (p_tcb == (OS_TCB *)0) {
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD101             BNE.N    ??OSTaskTimeQuantaSet_2
   2352                  p_tcb = OSTCBCurPtr;
   \   00000024   0x....             LDR.N    R1,??DataTable20
   \   00000026   0x680C             LDR      R4,[R1, #+0]
   2353              }
   2354          
   2355              if (time_quanta == 0u) {
   \                     ??OSTaskTimeQuantaSet_2: (+1)
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD103             BNE.N    ??OSTaskTimeQuantaSet_3
   2356                  p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
   \   0000002C   0x....             LDR.N    R1,??DataTable20_6
   \   0000002E   0x6809             LDR      R1,[R1, #+0]
   \   00000030   0x64E1             STR      R1,[R4, #+76]
   \   00000032   0xE000             B.N      ??OSTaskTimeQuantaSet_4
   2357              } else {
   2358                  p_tcb->TimeQuanta    = time_quanta;
   \                     ??OSTaskTimeQuantaSet_3: (+1)
   \   00000034   0x64E5             STR      R5,[R4, #+76]
   2359              }
   2360              if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
   \                     ??OSTaskTimeQuantaSet_4: (+1)
   \   00000036   0x6D21             LDR      R1,[R4, #+80]
   \   00000038   0x6CE2             LDR      R2,[R4, #+76]
   \   0000003A   0x4291             CMP      R1,R2
   \   0000003C   0xD201             BCS.N    ??OSTaskTimeQuantaSet_5
   2361                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
   \   0000003E   0x6CE1             LDR      R1,[R4, #+76]
   \   00000040   0x6521             STR      R1,[R4, #+80]
   2362              }
   2363              CPU_CRITICAL_EXIT();
   \                     ??OSTaskTimeQuantaSet_5: (+1)
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
   2364             *p_err = OS_ERR_NONE;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x8030             STRH     R0,[R6, #+0]
   2365          }
   \                     ??OSTaskTimeQuantaSet_1: (+1)
   \   0000004A   0xBD70             POP      {R4-R6,PC}       ;; return
   2366          #endif
   2367          
   2368          
   2369          /*
   2370          ************************************************************************************************************************
   2371          *                                            ADD/REMOVE TASK TO/FROM DEBUG LIST
   2372          *
   2373          * Description: These functions are called by uC/OS-III to add or remove an OS_TCB from the debug list.
   2374          *
   2375          * Arguments  : p_tcb     is a pointer to the OS_TCB to add/remove
   2376          *
   2377          * Returns    : none
   2378          *
   2379          * Note(s)    : These functions are INTERNAL to uC/OS-III and your application should not call it.
   2380          ************************************************************************************************************************
   2381          */
   2382          
   2383          #if (OS_CFG_DBG_EN > 0u)
   2384          void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
   2385          {
   2386              p_tcb->DbgPrevPtr                = (OS_TCB *)0;
   2387              if (OSTaskDbgListPtr == (OS_TCB *)0) {
   2388                  p_tcb->DbgNextPtr            = (OS_TCB *)0;
   2389              } else {
   2390                  p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
   2391                  OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
   2392              }
   2393              OSTaskDbgListPtr                 =  p_tcb;
   2394          }
   2395          
   2396          
   2397          
   2398          void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
   2399          {
   2400              OS_TCB  *p_tcb_next;
   2401              OS_TCB  *p_tcb_prev;
   2402          
   2403          
   2404              p_tcb_prev = p_tcb->DbgPrevPtr;
   2405              p_tcb_next = p_tcb->DbgNextPtr;
   2406          
   2407              if (p_tcb_prev == (OS_TCB *)0) {
   2408                  OSTaskDbgListPtr = p_tcb_next;
   2409                  if (p_tcb_next != (OS_TCB *)0) {
   2410                      p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
   2411                  }
   2412                  p_tcb->DbgNextPtr = (OS_TCB *)0;
   2413          
   2414              } else if (p_tcb_next == (OS_TCB *)0) {
   2415                  p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
   2416                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   2417          
   2418              } else {
   2419                  p_tcb_prev->DbgNextPtr =  p_tcb_next;
   2420                  p_tcb_next->DbgPrevPtr =  p_tcb_prev;
   2421                  p_tcb->DbgNextPtr      = (OS_TCB *)0;
   2422                  p_tcb->DbgPrevPtr      = (OS_TCB *)0;
   2423              }
   2424          }
   2425          #endif
   2426          
   2427          
   2428          /*
   2429          ************************************************************************************************************************
   2430          *                                             TASK MANAGER INITIALIZATION
   2431          *
   2432          * Description: This function is called by OSInit() to initialize the task management.
   2433          *
   2434          
   2435          * Argument(s): p_err        is a pointer to a variable that will contain an error code returned by this function.
   2436          *
   2437          *                                OS_ERR_NONE     the call was successful
   2438          *
   2439          * Returns    : none
   2440          *
   2441          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2442          ************************************************************************************************************************
   2443          */
   2444          

   \                                 In section .text, align 2, keep-with-next
   2445          void  OS_TaskInit (OS_ERR  *p_err)
   2446          {
   2447          #if (OS_CFG_DBG_EN > 0u)
   2448              OSTaskDbgListPtr = (OS_TCB *)0;
   2449          #endif
   2450          
   2451              OSTaskQty        = 0u;                                      /* Clear the number of tasks                            */
   \                     OS_TaskInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x....             LDR.N    R2,??DataTable20_7
   \   00000004   0x8011             STRH     R1,[R2, #+0]
   2452          
   2453          #if ((OS_CFG_TASK_PROFILE_EN > 0u) || (OS_CFG_DBG_EN > 0u))
   2454              OSTaskCtxSwCtr   = 0u;                                      /* Clear the context switch counter                     */
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR.N    R2,??DataTable20_8
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   2455          #endif
   2456          
   2457             *p_err            = OS_ERR_NONE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   2458          }
   \   00000010   0x4770             BX       LR               ;; return
   2459          
   2460          
   2461          /*
   2462          ************************************************************************************************************************
   2463          *                                               INITIALIZE TCB FIELDS
   2464          *
   2465          * Description: This function is called to initialize a TCB to default values
   2466          *
   2467          * Arguments  : p_tcb    is a pointer to the TCB to initialize
   2468          *
   2469          * Returns    : none
   2470          *
   2471          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2472          ************************************************************************************************************************
   2473          */
   2474          

   \                                 In section .text, align 2, keep-with-next
   2475          void  OS_TaskInitTCB (OS_TCB  *p_tcb)
   2476          {
   \                     OS_TaskInitTCB: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2477          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2478              OS_REG_ID   reg_id;
   2479          #endif
   2480          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2481              OS_TLS_ID   id;
   2482          #endif
   2483          
   2484          
   2485              p_tcb->StkPtr               = (CPU_STK          *)0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
   2486              p_tcb->StkLimitPtr          = (CPU_STK          *)0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x60A0             STR      R0,[R4, #+8]
   2487          
   2488              p_tcb->ExtPtr               = (void             *)0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6060             STR      R0,[R4, #+4]
   2489          
   2490              p_tcb->NextPtr              = (OS_TCB           *)0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x60E0             STR      R0,[R4, #+12]
   2491              p_tcb->PrevPtr              = (OS_TCB           *)0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6120             STR      R0,[R4, #+16]
   2492          
   2493          #if (OS_CFG_TICK_EN > 0u)
   2494              p_tcb->TickNextPtr          = (OS_TCB           *)0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6160             STR      R0,[R4, #+20]
   2495              p_tcb->TickPrevPtr          = (OS_TCB           *)0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61A0             STR      R0,[R4, #+24]
   2496          #endif
   2497          
   2498          #if (OS_CFG_DBG_EN > 0u)
   2499              p_tcb->NamePtr              = (CPU_CHAR *)((void *)"?Task");
   2500          #endif
   2501          
   2502          #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
   2503              p_tcb->StkBasePtr           = (CPU_STK          *)0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x61E0             STR      R0,[R4, #+28]
   2504          #endif
   2505          
   2506          #if (OS_CFG_DBG_EN > 0u)
   2507              p_tcb->TaskEntryAddr        = (OS_TASK_PTR       )0;
   2508              p_tcb->TaskEntryArg         = (void             *)0;
   2509          #endif
   2510          
   2511          #if (OS_CFG_TS_EN > 0u)
   2512              p_tcb->TS                   =                     0u;
   2513          #endif
   2514          
   2515          #if (OS_MSG_EN > 0u)
   2516              p_tcb->MsgPtr               = (void             *)0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6560             STR      R0,[R4, #+84]
   2517              p_tcb->MsgSize              =                     0u;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   2518          #endif
   2519          
   2520          #if (OS_CFG_TASK_Q_EN > 0u)
   2521              OS_MsgQInit(&p_tcb->MsgQ,
   2522                           0u);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF114 0x005C      ADDS     R0,R4,#+92
   \   00000034   0x.... 0x....      BL       OS_MsgQInit
   2523          #if (OS_CFG_TASK_PROFILE_EN > 0u)
   2524              p_tcb->MsgQPendTime         =                     0u;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x66A0             STR      R0,[R4, #+104]
   2525              p_tcb->MsgQPendTimeMax      =                     0u;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x66E0             STR      R0,[R4, #+108]
   2526          #endif
   2527          #endif
   2528          
   2529          #if (OS_CFG_FLAG_EN > 0u)
   2530              p_tcb->FlagsPend            =                     0u;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6760             STR      R0,[R4, #+116]
   2531              p_tcb->FlagsOpt             =                     0u;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xF8A4 0x007C      STRH     R0,[R4, #+124]
   2532              p_tcb->FlagsRdy             =                     0u;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x67A0             STR      R0,[R4, #+120]
   2533          #endif
   2534          
   2535          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
   2536              for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xE006             B.N      ??OS_TaskInitTCB_0
   2537                  p_tcb->RegTbl[reg_id]   =                     0u;
   \                     ??OS_TaskInitTCB_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x000A             MOVS     R2,R1
   \   00000056   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000058   0xEB04 0x0282      ADD      R2,R4,R2, LSL #+2
   \   0000005C   0x6710             STR      R0,[R2, #+112]
   2538              }
   \   0000005E   0x1C49             ADDS     R1,R1,#+1
   \                     ??OS_TaskInitTCB_0: (+1)
   \   00000060   0x0008             MOVS     R0,R1
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD0F4             BEQ.N    ??OS_TaskInitTCB_1
   2539          #endif
   2540          
   2541          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
   2542              for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
   2543                  p_tcb->TLS_Tbl[id]      =                     0u;
   2544              }
   2545          #endif
   2546          
   2547              p_tcb->SemCtr               =                     0u;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x6420             STR      R0,[R4, #+64]
   2548          #if (OS_CFG_TASK_PROFILE_EN > 0u)
   2549              p_tcb->SemPendTime          =                     0u;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF8C4 0x0098      STR      R0,[R4, #+152]
   2550              p_tcb->SemPendTimeMax       =                     0u;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF8C4 0x009C      STR      R0,[R4, #+156]
   2551          #endif
   2552          
   2553          #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_STK_CHK_EN > 0u))
   2554              p_tcb->StkSize              =                     0u;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x63A0             STR      R0,[R4, #+56]
   2555          #endif
   2556          
   2557          
   2558          #if (OS_CFG_TASK_SUSPEND_EN > 0u)
   2559              p_tcb->SuspendCtr           =                     0u;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xF884 0x007E      STRB     R0,[R4, #+126]
   2560          #endif
   2561          
   2562          #if (OS_CFG_STAT_TASK_STK_CHK_EN > 0u)
   2563              p_tcb->StkFree              =                     0u;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF8C4 0x00A4      STR      R0,[R4, #+164]
   2564              p_tcb->StkUsed              =                     0u;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF8C4 0x00A0      STR      R0,[R4, #+160]
   2565          #endif
   2566          
   2567              p_tcb->Opt                  =                     0u;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x87A0             STRH     R0,[R4, #+60]
   2568          
   2569          #if (OS_CFG_TICK_EN > 0u)
   2570              p_tcb->TickRemain           =                     0u;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6460             STR      R0,[R4, #+68]
   2571              p_tcb->TickCtrPrev          =                     0u;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x64A0             STR      R0,[R4, #+72]
   2572          #endif
   2573          
   2574          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)
   2575              p_tcb->TimeQuanta           =                     0u;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x64E0             STR      R0,[R4, #+76]
   2576              p_tcb->TimeQuantaCtr        =                     0u;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x6520             STR      R0,[R4, #+80]
   2577          #endif
   2578          
   2579          #if (OS_CFG_TASK_PROFILE_EN > 0u)
   2580              p_tcb->CPUUsage             =                     0u;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF8A4 0x0080      STRH     R0,[R4, #+128]
   2581              p_tcb->CPUUsageMax          =                     0u;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0xF8A4 0x0082      STRH     R0,[R4, #+130]
   2582              p_tcb->CtxSwCtr             =                     0u;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8C4 0x0084      STR      R0,[R4, #+132]
   2583              p_tcb->CyclesDelta          =                     0u;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xF8C4 0x0088      STR      R0,[R4, #+136]
   2584          #if (OS_CFG_TS_EN > 0u)
   2585              p_tcb->CyclesStart          =  OS_TS_GET();                 /* Read the current timestamp and save                  */
   2586          #else
   2587              p_tcb->CyclesStart          =                     0u;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF8C4 0x008C      STR      R0,[R4, #+140]
   2588          #endif
   2589              p_tcb->CyclesTotal          =                     0u;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xF8C4 0x0090      STR      R0,[R4, #+144]
   2590          #endif
   2591          
   2592          #ifdef CPU_CFG_INT_DIS_MEAS_EN
   2593              p_tcb->IntDisTimeMax        =                     0u;
   2594          #endif
   2595          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
   2596              p_tcb->SchedLockTimeMax     =                     0u;
   2597          #endif
   2598          
   2599              p_tcb->PendNextPtr          = (OS_TCB           *)0;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x6220             STR      R0,[R4, #+32]
   2600              p_tcb->PendPrevPtr          = (OS_TCB           *)0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x6260             STR      R0,[R4, #+36]
   2601              p_tcb->PendObjPtr           = (OS_PEND_OBJ      *)0;
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x62A0             STR      R0,[R4, #+40]
   2602              p_tcb->PendOn               =  OS_TASK_PEND_ON_NOTHING;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF884 0x002C      STRB     R0,[R4, #+44]
   2603              p_tcb->PendStatus           =  OS_STATUS_PEND_OK;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0xF884 0x002D      STRB     R0,[R4, #+45]
   2604              p_tcb->TaskState            =  OS_TASK_STATE_RDY;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0xF884 0x002E      STRB     R0,[R4, #+46]
   2605          
   2606              p_tcb->Prio                 =  OS_PRIO_INIT;
   \   000000E4   0x2040             MOVS     R0,#+64
   \   000000E6   0xF884 0x002F      STRB     R0,[R4, #+47]
   2607          #if (OS_CFG_MUTEX_EN > 0u)
   2608              p_tcb->BasePrio             =  OS_PRIO_INIT;
   \   000000EA   0x2040             MOVS     R0,#+64
   \   000000EC   0xF884 0x0030      STRB     R0,[R4, #+48]
   2609              p_tcb->MutexGrpHeadPtr      = (OS_MUTEX         *)0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x6360             STR      R0,[R4, #+52]
   2610          #endif
   2611          
   2612          #if (OS_CFG_DBG_EN > 0u)
   2613              p_tcb->DbgPrevPtr           = (OS_TCB           *)0;
   2614              p_tcb->DbgNextPtr           = (OS_TCB           *)0;
   2615              p_tcb->DbgNamePtr           = (CPU_CHAR *)((void *)" ");
   2616          #endif
   2617          }
   \   000000F4   0xBD10             POP      {R4,PC}          ;; return
   2618          
   2619          
   2620          /*
   2621          ************************************************************************************************************************
   2622          *                                              CATCH ACCIDENTAL TASK RETURN
   2623          *
   2624          * Description: This function is called if a task accidentally returns without deleting itself.  In other words, a task
   2625          *              should either be an infinite loop or delete itself if it's done.
   2626          *
   2627          * Arguments  : none
   2628          *
   2629          * Returns    : none
   2630          *
   2631          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   2632          ************************************************************************************************************************
   2633          */
   2634          

   \                                 In section .text, align 2, keep-with-next
   2635          void  OS_TaskReturn (void)
   2636          {
   \                     OS_TaskReturn: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2637              OS_ERR  err;
   2638          
   2639          
   2640          
   2641              OSTaskReturnHook(OSTCBCurPtr);                              /* Call hook to let user decide on what to do           */
   \   00000002   0x....             LDR.N    R0,??DataTable20
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       OSTaskReturnHook
   2642          #if (OS_CFG_TASK_DEL_EN > 0u)
   2643              OSTaskDel((OS_TCB *)0,                                      /* Delete task if it accidentally returns!              */
   2644                        &err);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       OSTaskDel
   2645          #else
   2646              for (;;) {
   2647                  OSTimeDly(OSCfg_TickRate_Hz,
   2648                            OS_OPT_TIME_DLY,
   2649                            &err);
   2650              }
   2651          #endif
   2652          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   2653          
   2654          
   2655          /*
   2656          ************************************************************************************************************************
   2657          *                                          CHECK THE STACK REDZONE OF A TASK
   2658          *
   2659          * Description: Verify a task's stack redzone.
   2660          *
   2661          * Arguments  : p_tcb        is a pointer to the base of the stack.
   2662          *
   2663          *              stk_size     is the size of the stack.
   2664          *
   2665          * Returns    : If the stack is corrupted (OS_FALSE) or not (OS_TRUE).
   2666          *
   2667          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
   2668          ************************************************************************************************************************
   2669          */
   2670          
   2671          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
   2672          CPU_BOOLEAN   OS_TaskStkRedzoneChk (CPU_STK       *p_base,
   2673                                              CPU_STK_SIZE   stk_size)
   2674          {
   2675              CPU_INT32U  i;
   2676          
   2677          
   2678          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2679             (void)stk_size;                                              /* Prevent compiler warning for not using 'stk_size'    */
   2680          
   2681              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2682                  if (*p_base != (CPU_DATA)OS_STACK_CHECK_VAL) {
   2683                      return (OS_FALSE);
   2684                  }
   2685                  p_base++;
   2686              }
   2687          #else
   2688              p_base = p_base + stk_size - 1u;
   2689              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2690                  if (*p_base != (CPU_DATA)OS_STACK_CHECK_VAL) {
   2691                      return (OS_FALSE);
   2692                  }
   2693                  p_base--;
   2694              }
   2695          #endif
   2696          
   2697              return (OS_TRUE);
   2698          }
   2699          #endif
   2700          
   2701          
   2702          /*
   2703          ************************************************************************************************************************
   2704          *                                          INITIALIZE A REDZONE ENABLED STACK
   2705          *
   2706          * Description: This functions is used to initialize a stack with Redzone checking.
   2707          *
   2708          * Arguments  : p_tcb        is a pointer to the base of the stack.
   2709          *
   2710          *              stk_size     is the size of the stack.
   2711          *
   2712          * Returns    : none.
   2713          *
   2714          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application should not call it.
   2715          ************************************************************************************************************************
   2716          */
   2717          
   2718          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
   2719          void  OS_TaskStkRedzoneInit (CPU_STK       *p_base,
   2720                                       CPU_STK_SIZE   stk_size)
   2721          {
   2722              CPU_STK_SIZE   i;
   2723          
   2724          
   2725          #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
   2726             (void)stk_size;                                              /* Prevent compiler warning for not using 'stk_size'    */
   2727          
   2728              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2729                  *(p_base + i) = (CPU_DATA)OS_STACK_CHECK_VAL;
   2730              }
   2731          #else
   2732              for (i = 0u; i < OS_CFG_TASK_STK_REDZONE_DEPTH; i++) {
   2733                  *(p_base + stk_size - 1u - i) = (CPU_DATA)OS_STACK_CHECK_VAL;
   2734              }
   2735          #endif
   2736          }
   2737          #endif
   2738          
   2739          
   2740          /*
   2741          ************************************************************************************************************************
   2742          *                                               CHANGE PRIORITY OF A TASK
   2743          *
   2744          * Description: This function is called by the kernel to perform the actual operation of changing a task's priority.
   2745          *              Priority inheritance is updated if necessary.
   2746          *
   2747          *
   2748          *
   2749          * Argument(s): p_tcb        is a pointer to the tcb of the task to change the priority.
   2750          *
   2751          *              prio_new     is the new priority to give to the task.
   2752          *
   2753          *
   2754          * Returns    : none.
   2755          *
   2756          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2757          ************************************************************************************************************************
   2758          */
   2759          

   \                                 In section .text, align 2, keep-with-next
   2760          void  OS_TaskChangePrio(OS_TCB  *p_tcb,
   2761                                  OS_PRIO  prio_new)
   2762          {
   \                     OS_TaskChangePrio: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2763              OS_TCB  *p_tcb_owner;
   2764          #if (OS_CFG_MUTEX_EN > 0u)
   2765              OS_PRIO  prio_cur;
   2766          #endif
   2767          
   2768          
   2769              do {
   2770                  p_tcb_owner = (OS_TCB *)0;
   \                     ??OS_TaskChangePrio_0: (+1)
   \   00000006   0x2600             MOVS     R6,#+0
   2771          #if (OS_CFG_MUTEX_EN > 0u)
   2772                  prio_cur    =  p_tcb->Prio;
   \   00000008   0xF894 0x702F      LDRB     R7,[R4, #+47]
   2773          #endif
   2774                  switch (p_tcb->TaskState) {
   \   0000000C   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00B             BEQ.N    ??OS_TaskChangePrio_1
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD021             BEQ.N    ??OS_TaskChangePrio_2
   \   00000018   0xD31D             BCC.N    ??OS_TaskChangePrio_3
   \   0000001A   0x2804             CMP      R0,#+4
   \   0000001C   0xD01B             BEQ.N    ??OS_TaskChangePrio_3
   \   0000001E   0xD31D             BCC.N    ??OS_TaskChangePrio_2
   \   00000020   0x2806             CMP      R0,#+6
   \   00000022   0xD01B             BEQ.N    ??OS_TaskChangePrio_2
   \   00000024   0xD317             BCC.N    ??OS_TaskChangePrio_3
   \   00000026   0x2807             CMP      R0,#+7
   \   00000028   0xD018             BEQ.N    ??OS_TaskChangePrio_2
   \   0000002A   0xE05A             B.N      ??OS_TaskChangePrio_4
   2775                      case OS_TASK_STATE_RDY:
   2776                           OS_RdyListRemove(p_tcb);                       /* Remove from current priority                         */
   \                     ??OS_TaskChangePrio_1: (+1)
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       OS_RdyListRemove
   2777                           p_tcb->Prio = prio_new;                        /* Set new task priority                                */
   \   00000032   0xF884 0x502F      STRB     R5,[R4, #+47]
   2778                           OS_PrioInsert(p_tcb->Prio);
   \   00000036   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   0000003A   0x.... 0x....      BL       OS_PrioInsert
   2779                           if (p_tcb == OSTCBCurPtr) {
   \   0000003E   0x....             LDR.N    R0,??DataTable20
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD103             BNE.N    ??OS_TaskChangePrio_5
   2780                               OS_RdyListInsertHead(p_tcb);
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       OS_RdyListInsertHead
   \   0000004C   0xE002             B.N      ??OS_TaskChangePrio_6
   2781                           } else {
   2782                               OS_RdyListInsertTail(p_tcb);
   \                     ??OS_TaskChangePrio_5: (+1)
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       OS_RdyListInsertTail
   2783                           }
   2784                           break;
   \                     ??OS_TaskChangePrio_6: (+1)
   \   00000054   0xE041             B.N      ??OS_TaskChangePrio_7
   2785          
   2786                      case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB*/
   2787                      case OS_TASK_STATE_SUSPENDED:
   2788                      case OS_TASK_STATE_DLY_SUSPENDED:
   2789                           p_tcb->Prio = prio_new;                        /* Set new task priority                                */
   \                     ??OS_TaskChangePrio_3: (+1)
   \   00000056   0xF884 0x502F      STRB     R5,[R4, #+47]
   2790                           break;
   \   0000005A   0xE03E             B.N      ??OS_TaskChangePrio_7
   2791          
   2792                      case OS_TASK_STATE_PEND:
   2793                      case OS_TASK_STATE_PEND_TIMEOUT:
   2794                      case OS_TASK_STATE_PEND_SUSPENDED:
   2795                      case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   2796                           p_tcb->Prio = prio_new;                        /* Set new task priority                                */
   \                     ??OS_TaskChangePrio_2: (+1)
   \   0000005C   0xF884 0x502F      STRB     R5,[R4, #+47]
   2797                           switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on         */
   \   00000060   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD005             BEQ.N    ??OS_TaskChangePrio_8
   \   00000068   0x2804             CMP      R0,#+4
   \   0000006A   0xD007             BEQ.N    ??OS_TaskChangePrio_9
   \   0000006C   0x2805             CMP      R0,#+5
   \   0000006E   0xD001             BEQ.N    ??OS_TaskChangePrio_8
   \   00000070   0x2806             CMP      R0,#+6
   \   00000072   0xD132             BNE.N    ??OS_TaskChangePrio_10
   2798                               case OS_TASK_PEND_ON_FLAG:
   2799                               case OS_TASK_PEND_ON_Q:
   2800                               case OS_TASK_PEND_ON_SEM:
   2801                                    OS_PendListChangePrio(p_tcb);
   \                     ??OS_TaskChangePrio_8: (+1)
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       OS_PendListChangePrio
   2802                                    break;
   \   0000007A   0xE02E             B.N      ??OS_TaskChangePrio_11
   2803          
   2804                               case OS_TASK_PEND_ON_MUTEX:
   2805          #if (OS_CFG_MUTEX_EN > 0u)
   2806                                    OS_PendListChangePrio(p_tcb);
   \                     ??OS_TaskChangePrio_9: (+1)
   \   0000007C   0x0020             MOVS     R0,R4
   \   0000007E   0x.... 0x....      BL       OS_PendListChangePrio
   2807                                    p_tcb_owner = ((OS_MUTEX *)((void *)p_tcb->PendObjPtr))->OwnerTCBPtr;
   \   00000082   0x6AA0             LDR      R0,[R4, #+40]
   \   00000084   0x6906             LDR      R6,[R0, #+16]
   2808                                    if (prio_cur > prio_new) {            /* Are we increasing the priority?                      */
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x0039             MOVS     R1,R7
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD207             BCS.N    ??OS_TaskChangePrio_12
   2809                                        if (p_tcb_owner->Prio <= prio_new) { /* Yes, do we need to give this prio to the owner?   */
   \   00000092   0x0028             MOVS     R0,R5
   \   00000094   0xF896 0x102F      LDRB     R1,[R6, #+47]
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD31C             BCC.N    ??OS_TaskChangePrio_13
   2810                                            p_tcb_owner = (OS_TCB *)0;
   \   0000009E   0x2600             MOVS     R6,#+0
   \   000000A0   0xE01A             B.N      ??OS_TaskChangePrio_13
   2811                                        } else {
   2812                                                                          /* Block is empty when trace is disabled.               */
   2813                                           OS_TRACE_MUTEX_TASK_PRIO_INHERIT(p_tcb_owner, prio_new);
   2814                                        }
   2815                                    } else {
   2816                                        if (p_tcb_owner->Prio == prio_cur) { /* No, is it required to check for a lower prio?     */
   \                     ??OS_TaskChangePrio_12: (+1)
   \   000000A2   0xF896 0x002F      LDRB     R0,[R6, #+47]
   \   000000A6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A8   0x42B8             CMP      R0,R7
   \   000000AA   0xD114             BNE.N    ??OS_TaskChangePrio_14
   2817                                            prio_new = OS_MutexGrpPrioFindHighest(p_tcb_owner);
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0x.... 0x....      BL       OS_MutexGrpPrioFindHighest
   \   000000B2   0x0005             MOVS     R5,R0
   2818                                            prio_new = (prio_new > p_tcb_owner->BasePrio) ? p_tcb_owner->BasePrio : prio_new;
   \   000000B4   0xF896 0x0030      LDRB     R0,[R6, #+48]
   \   000000B8   0x0029             MOVS     R1,R5
   \   000000BA   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xD202             BCS.N    ??OS_TaskChangePrio_15
   \   000000C0   0xF896 0x5030      LDRB     R5,[R6, #+48]
   \   000000C4   0xE7FF             B.N      ??OS_TaskChangePrio_16
   2819                                            if (prio_new == p_tcb_owner->Prio) {
   \                     ??OS_TaskChangePrio_15: (+1)
   \                     ??OS_TaskChangePrio_16: (+1)
   \   000000C6   0x0028             MOVS     R0,R5
   \   000000C8   0xF896 0x102F      LDRB     R1,[R6, #+47]
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD102             BNE.N    ??OS_TaskChangePrio_13
   2820                                                p_tcb_owner = (OS_TCB *)0;
   \   000000D2   0x2600             MOVS     R6,#+0
   \   000000D4   0xE000             B.N      ??OS_TaskChangePrio_13
   2821                                            } else {
   2822                                                                          /* Block is empty when trace is disabled.               */
   2823                                               OS_TRACE_MUTEX_TASK_PRIO_DISINHERIT(p_tcb_owner, prio_new);
   2824                                            }
   2825                                        } else {
   2826                                            p_tcb_owner = (OS_TCB *)0;
   \                     ??OS_TaskChangePrio_14: (+1)
   \   000000D6   0x2600             MOVS     R6,#+0
   2827                                        }
   2828                                    }
   2829          #endif
   2830                                    break;
   \                     ??OS_TaskChangePrio_13: (+1)
   \   000000D8   0xE7FF             B.N      ??OS_TaskChangePrio_11
   2831          
   2832                               case OS_TASK_PEND_ON_TASK_Q:
   2833                               case OS_TASK_PEND_ON_TASK_SEM:
   2834                               default:
   2835                                                                          /* Default case.                                        */
   2836                                    break;
   2837                           }
   2838                           break;
   2839          
   2840                      default:
   2841                           return;
   2842                  }
   2843                  p_tcb = p_tcb_owner;
   \                     ??OS_TaskChangePrio_10: (+1)
   \                     ??OS_TaskChangePrio_11: (+1)
   \                     ??OS_TaskChangePrio_7: (+1)
   \   000000DA   0x0034             MOVS     R4,R6
   2844              } while (p_tcb != (OS_TCB *)0);
   \   000000DC   0x2C00             CMP      R4,#+0
   \   000000DE   0xD192             BNE.N    ??OS_TaskChangePrio_0
   2845          }
   \                     ??OS_TaskChangePrio_17: (+1)
   \   000000E0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \                     ??OS_TaskChangePrio_4: (+1)
   \   000000E2   0xE7FD             B.N      ??OS_TaskChangePrio_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     OSCfg_StkSizeMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   OSTaskChangePrio
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_TaskChangePrio
      48   OSTaskCreate
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> OSSched
        48   -> OSTaskCreateHook
        48   -> OSTaskStkInit
        48   -> OS_MsgQInit
        48   -> OS_PrioInsert
        48   -> OS_RdyListInsertTail
        48   -> OS_TaskInitTCB
      24   OSTaskDel
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OSTaskDelHook
        24   -> OS_MsgQFreeAll
        24   -> OS_MutexGrpPostAll
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_PendListRemove
        24   -> OS_RdyListRemove
        24   -> OS_TaskChangePrio
        24   -> OS_TaskInitTCB
        24   -> OS_TickListRemove
      16   OSTaskQFlush
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_MsgQFreeAll
      32   OSTaskQPend
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_MsgQGet
        32   -> OS_Pend
      24   OSTaskQPendAbort
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_PendAbort
      40   OSTaskQPost
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSSched
        40   -> OS_MsgQPut
        40   -> OS_Post
      16   OSTaskRegGet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSTaskRegGetID
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   OSTaskRegSet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskResume
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListInsert
      24   OSTaskSemPend
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_Pend
      24   OSTaskSemPendAbort
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OSSched
        24   -> OS_PendAbort
      32   OSTaskSemPost
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> OSSched
        32   -> OS_Post
      24   OSTaskSemSet
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   OSTaskStkChk
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      16   OSTaskSuspend
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListRemove
      16   OSTaskTimeQuantaSet
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   OS_TaskChangePrio
        24   -> OS_MutexGrpPrioFindHighest
        24   -> OS_PendListChangePrio
        24   -> OS_PrioInsert
        24   -> OS_RdyListInsertHead
        24   -> OS_RdyListInsertTail
        24   -> OS_RdyListRemove
       0   OS_TaskInit
       8   OS_TaskInitTCB
         8   -> OS_MsgQInit
       8   OS_TaskReturn
         8   -> OSTaskDel
         8   -> OSTaskReturnHook


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
     184  OSTaskChangePrio
     426  OSTaskCreate
     382  OSTaskDel
     102  OSTaskQFlush
     338  OSTaskQPend
     170  OSTaskQPendAbort
     264  OSTaskQPost
      64  OSTaskRegGet
      70  OSTaskRegGetID
      62  OSTaskRegSet
     290  OSTaskResume
     278  OSTaskSemPend
     172  OSTaskSemPendAbort
     256  OSTaskSemPost
      92  OSTaskSemSet
     172  OSTaskStkChk
     300  OSTaskSuspend
      76  OSTaskTimeQuantaSet
     228  OS_TaskChangePrio
      18  OS_TaskInit
     246  OS_TaskInitTCB
      20  OS_TaskReturn

 
 4 278 bytes in section .text
 
 4 278 bytes of CODE memory

Errors: none
Warnings: none
