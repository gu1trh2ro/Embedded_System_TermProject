###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       20/Dec/2025  16:25:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_core.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EW3930.tmp
#        (C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_core.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List
#        -o
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\inc\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\libraries\LCD\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-CPU\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Ports\ARM-Cortex-M\ARMv7-M\IAR\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\user\uCOS-III\
#        -I
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uC-LIB\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\List\os_core.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Debug\Obj\os_core.o
#
###############################################################################

C:\Users\pnu3\Desktop\deskproject\Embedded_System_TermProject\Micrium\Software\uCOS-III\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/OS-III
      4          *                                        The Real-Time Kernel
      5          *
      6          *                    Copyright 2009-2022 Silicon Laboratories Inc. www.silabs.com
      7          *
      8          *                                 SPDX-License-Identifier: APACHE-2.0
      9          *
     10          *               This software is subject to an open source license and is distributed by
     11          *                Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     12          *                    Version 2.0 available at www.apache.org/licenses/LICENSE-2.0.
     13          *
     14          *********************************************************************************************************
     15          */
     16          
     17          /*
     18          *********************************************************************************************************
     19          *                                            CORE FUNCTIONS
     20          *
     21          * File    : os_core.c
     22          * Version : V3.08.02
     23          *********************************************************************************************************
     24          */
     25          
     26          #define  MICRIUM_SOURCE
     27          #include "os.h"
     28          
     29          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     30          const  CPU_CHAR  *os_core__c = "$Id: $";
     31          #endif
     32          
     33          /*
     34          ************************************************************************************************************************
     35          *                                                    INITIALIZATION
     36          *
     37          * Description: This function is used to initialize the internals of uC/OS-III and MUST be called prior to
     38          *              creating any uC/OS-III object and, prior to calling OSStart().
     39          *
     40          * Arguments  : p_err         is a pointer to a variable that will contain an error code returned by this function.
     41          *
     42          *                                OS_ERR_NONE    Initialization was successful
     43          *                                Other          Other OS_ERR_xxx depending on the sub-functions called by OSInit().
     44          * Returns    : none
     45          ************************************************************************************************************************
     46          */
     47          

   \                                 In section .text, align 2, keep-with-next
     48          void  OSInit (OS_ERR  *p_err)
     49          {
   \                     OSInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     50          #if (OS_CFG_ISR_STK_SIZE > 0u)
     51              CPU_STK      *p_stk;
     52              CPU_STK_SIZE  size;
     53          #endif
     54          
     55          
     56          
     57          #ifdef OS_SAFETY_CRITICAL
     58              if (p_err == (OS_ERR *)0) {
     59                  OS_SAFETY_CRITICAL_EXCEPTION();
     60                  return;
     61              }
     62          #endif
     63          
     64              OSInitHook();                                               /* Call port specific initialization code               */
   \   00000004   0x.... 0x....      BL       OSInitHook
     65          
     66              OSIntNestingCtr       =           0u;                       /* Clear the interrupt nesting counter                  */
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
     67          
     68              OSRunning             =  OS_STATE_OS_STOPPED;               /* Indicate that multitasking has not started           */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
     69          
     70              OSSchedLockNestingCtr =           0u;                       /* Clear the scheduling lock counter                    */
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
     71          
     72              OSTCBCurPtr           = (OS_TCB *)0;                        /* Initialize OS_TCB pointers to a known state          */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000026   0x6008             STR      R0,[R1, #+0]
     73              OSTCBHighRdyPtr       = (OS_TCB *)0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   0000002E   0x6008             STR      R0,[R1, #+0]
     74          
     75              OSPrioCur             =           0u;                       /* Initialize priority variables to a known state       */
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   00000036   0x7008             STRB     R0,[R1, #+0]
     76              OSPrioHighRdy         =           0u;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
     77          
     78          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
     79              OSSchedLockTimeBegin  =           0u;
     80              OSSchedLockTimeMax    =           0u;
     81              OSSchedLockTimeMaxCur =           0u;
     82          #endif
     83          
     84          #ifdef OS_SAFETY_CRITICAL_IEC61508
     85              OSSafetyCriticalStartFlag = OS_FALSE;
     86          #endif
     87          
     88          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)
     89              OSSchedRoundRobinEn             = OS_FALSE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000046   0x7008             STRB     R0,[R1, #+0]
     90              OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x210A             MOVS     R1,#+10
   \   00000050   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable17_9
   \   00000058   0x6008             STR      R0,[R1, #+0]
     91          #endif
     92          
     93          #if (OS_CFG_ISR_STK_SIZE > 0u)
     94              p_stk = OSCfg_ISRStkBasePtr;                                /* Clear exception stack for stack checking.            */
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable17_10
   \   0000005E   0x6801             LDR      R1,[R0, #+0]
     95              if (p_stk != (CPU_STK *)0) {
   \   00000060   0x2900             CMP      R1,#+0
   \   00000062   0xD009             BEQ.N    ??OSInit_0
     96                  size  = OSCfg_ISRStkSize;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable17_11
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xE003             B.N      ??OSInit_1
     97                  while (size > 0u) {
     98                      size--;
   \                     ??OSInit_2: (+1)
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
     99                     *p_stk = 0u;
   \   0000006E   0x2200             MOVS     R2,#+0
   \   00000070   0x600A             STR      R2,[R1, #+0]
    100                      p_stk++;
   \   00000072   0x1D09             ADDS     R1,R1,#+4
    101                  }
   \                     ??OSInit_1: (+1)
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD1F9             BNE.N    ??OSInit_2
    102              }
    103          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)                           /* Initialize Redzoned ISR stack                        */
    104              OS_TaskStkRedzoneInit(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    105          #endif
    106          #endif
    107          
    108          #if (OS_CFG_APP_HOOKS_EN > 0u)                                  /* Clear application hook pointers                      */
    109          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
    110              OS_AppRedzoneHitHookPtr = (OS_APP_HOOK_TCB )0;
    111          #endif
    112              OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;
   \                     ??OSInit_0: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    113              OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable17_13
   \   00000086   0x6008             STR      R0,[R1, #+0]
    114              OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable17_14
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    115          
    116              OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable17_15
   \   00000096   0x6008             STR      R0,[R1, #+0]
    117              OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000009E   0x6008             STR      R0,[R1, #+0]
    118              OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable17_17
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    119              OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    120          #endif
    121          
    122          #if (OS_CFG_TASK_REG_TBL_SIZE > 0u)
    123              OSTaskRegNextAvailID = 0u;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable17_19
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
    124          #endif
    125          
    126              OS_PrioInit();                                              /* Initialize the priority bitmap table                 */
   \   000000B8   0x.... 0x....      BL       OS_PrioInit
    127          
    128              OS_RdyListInit();                                           /* Initialize the Ready List                            */
   \   000000BC   0x.... 0x....      BL       OS_RdyListInit
    129          
    130          
    131          #if (OS_CFG_FLAG_EN > 0u)                                       /* Initialize the Event Flag module                     */
    132          #if (OS_CFG_DBG_EN > 0u)
    133              OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
    134              OSFlagQty        =                0u;
    135          #endif
    136          #endif
    137          
    138          #if (OS_CFG_MEM_EN > 0u)                                        /* Initialize the Memory Manager module                 */
    139              OS_MemInit(p_err);
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0x.... 0x....      BL       OS_MemInit
    140              if (*p_err != OS_ERR_NONE) {
   \   000000C6   0x8820             LDRH     R0,[R4, #+0]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD129             BNE.N    ??OSInit_3
    141                  return;
    142              }
    143          #endif
    144          
    145          
    146          #if (OS_MSG_EN > 0u)                                            /* Initialize the free list of OS_MSGs                  */
    147              OS_MsgPoolInit(p_err);
   \                     ??OSInit_4: (+1)
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       OS_MsgPoolInit
    148              if (*p_err != OS_ERR_NONE) {
   \   000000D2   0x8820             LDRH     R0,[R4, #+0]
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD123             BNE.N    ??OSInit_3
    149                  return;
    150              }
    151          #endif
    152          
    153          
    154          #if (OS_CFG_MUTEX_EN > 0u)                                      /* Initialize the Mutex Manager module                  */
    155          #if (OS_CFG_DBG_EN > 0u)
    156              OSMutexDbgListPtr = (OS_MUTEX *)0;
    157              OSMutexQty        =             0u;
    158          #endif
    159          #endif
    160          
    161          
    162          #if (OS_CFG_Q_EN > 0u)                                          /* Initialize the Message Queue Manager module          */
    163          #if (OS_CFG_DBG_EN > 0u)
    164              OSQDbgListPtr = (OS_Q *)0;
    165              OSQQty        =         0u;
    166          #endif
    167          #endif
    168          
    169          
    170          #if (OS_CFG_SEM_EN > 0u)                                        /* Initialize the Semaphore Manager module              */
    171          #if (OS_CFG_DBG_EN > 0u)
    172              OSSemDbgListPtr = (OS_SEM *)0;
    173              OSSemQty        =           0u;
    174          #endif
    175          #endif
    176          
    177          
    178          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    179              OS_TLS_Init(p_err);                                         /* Initialize Task Local Storage, before creating tasks */
    180              if (*p_err != OS_ERR_NONE) {
    181                  return;
    182              }
    183          #endif
    184          
    185          
    186              OS_TaskInit(p_err);                                         /* Initialize the task manager                          */
   \                     ??OSInit_5: (+1)
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       OS_TaskInit
    187              if (*p_err != OS_ERR_NONE) {
   \   000000DE   0x8820             LDRH     R0,[R4, #+0]
   \   000000E0   0x2800             CMP      R0,#+0
   \   000000E2   0xD11D             BNE.N    ??OSInit_3
    188                  return;
    189              }
    190          
    191          
    192          #if (OS_CFG_TASK_IDLE_EN > 0u)
    193              OS_IdleTaskInit(p_err);                                     /* Initialize the Idle Task                             */
   \                     ??OSInit_6: (+1)
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       OS_IdleTaskInit
    194              if (*p_err != OS_ERR_NONE) {
   \   000000EA   0x8820             LDRH     R0,[R4, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD117             BNE.N    ??OSInit_3
    195                  return;
    196              }
    197          #endif
    198          
    199          
    200          #if (OS_CFG_TICK_EN > 0u)
    201              OS_TickInit(p_err);
   \                     ??OSInit_7: (+1)
   \   000000F0   0x0020             MOVS     R0,R4
   \   000000F2   0x.... 0x....      BL       OS_TickInit
    202              if (*p_err != OS_ERR_NONE) {
   \   000000F6   0x8820             LDRH     R0,[R4, #+0]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD111             BNE.N    ??OSInit_3
    203                  return;
    204              }
    205          #endif
    206          
    207          
    208          #if (OS_CFG_STAT_TASK_EN > 0u)                                  /* Initialize the Statistic Task                        */
    209              OS_StatTaskInit(p_err);
   \                     ??OSInit_8: (+1)
   \   000000FC   0x0020             MOVS     R0,R4
   \   000000FE   0x.... 0x....      BL       OS_StatTaskInit
    210              if (*p_err != OS_ERR_NONE) {
   \   00000102   0x8820             LDRH     R0,[R4, #+0]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD10B             BNE.N    ??OSInit_3
    211                  return;
    212              }
    213          #endif
    214          
    215          
    216          #if (OS_CFG_TMR_EN > 0u)                                        /* Initialize the Timer Manager module                  */
    217              OS_TmrInit(p_err);
   \                     ??OSInit_9: (+1)
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x.... 0x....      BL       OS_TmrInit
    218              if (*p_err != OS_ERR_NONE) {
   \   0000010E   0x8820             LDRH     R0,[R4, #+0]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD105             BNE.N    ??OSInit_3
    219                  return;
    220              }
    221          #endif
    222          
    223          
    224          #if (OS_CFG_DBG_EN > 0u)
    225              OS_Dbg_Init();
    226          #endif
    227          
    228          
    229              OSCfg_Init();
   \                     ??OSInit_10: (+1)
   \   00000114   0x.... 0x....      BL       OSCfg_Init
    230          
    231              OSInitialized = OS_TRUE;                                    /* Kernel is initialized                                */
   \   00000118   0x2001             MOVS     R0,#+1
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable17_20
   \   0000011E   0x7008             STRB     R0,[R1, #+0]
    232          }
   \                     ??OSInit_3: (+1)
   \   00000120   0xBD10             POP      {R4,PC}          ;; return
    233          
    234          
    235          /*
    236          ************************************************************************************************************************
    237          *                                                      ENTER ISR
    238          *
    239          * Description: This function is used to notify uC/OS-III that you are about to service an interrupt service routine
    240          *              (ISR).  This allows uC/OS-III to keep track of interrupt nesting and thus only perform rescheduling at
    241          *              the last nested ISR.
    242          *
    243          * Arguments  : none
    244          *
    245          * Returns    : none
    246          *
    247          * Note(s)    : 1) This function MUST be called with interrupts already disabled
    248          *
    249          *              2) Your ISR can directly increment 'OSIntNestingCtr' without calling this function because OSIntNestingCtr has
    250          *                 been declared 'global', the port is actually considered part of the OS and thus is allowed to access
    251          *                 uC/OS-III variables.
    252          *
    253          *              3) You MUST still call OSIntExit() even though you increment 'OSIntNestingCtr' directly.
    254          *
    255          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    256          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    257          *                 at the end of the ISR.
    258          *
    259          *              5) You are allowed to nest interrupts up to 250 levels deep.
    260          ************************************************************************************************************************
    261          */
    262          

   \                                 In section .text, align 2, keep-with-next
    263          void  OSIntEnter (void)
    264          {
    265              OS_TRACE_ISR_ENTER();
    266          
    267              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Is OS running?                                       */
   \                     OSIntEnter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10B             BNE.N    ??OSIntEnter_0
    268                  return;                                                 /* No                                                   */
    269              }
    270          
    271              if (OSIntNestingCtr >= 250u) {                              /* Have we nested past 250 levels?                      */
   \                     ??OSIntEnter_1: (+1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x28FA             CMP      R0,#+250
   \   00000012   0xD206             BCS.N    ??OSIntEnter_0
    272                  return;                                                 /* Yes                                                  */
    273              }
    274          
    275              OSIntNestingCtr++;                                          /* Increment ISR nesting level                          */
   \                     ??OSIntEnter_2: (+1)
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    276          }
   \                     ??OSIntEnter_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    277          
    278          
    279          /*
    280          ************************************************************************************************************************
    281          *                                                       EXIT ISR
    282          *
    283          * Description: This function is used to notify uC/OS-III that you have completed servicing an ISR.  When the last nested
    284          *              ISR has completed, uC/OS-III will call the scheduler to determine whether a new, high-priority task, is
    285          *              ready to run.
    286          *
    287          * Arguments  : none
    288          *
    289          * Returns    : none
    290          *
    291          * Note(s)    : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call to OSIntEnter()
    292          *                 (or direct increment to OSIntNestingCtr) at the beginning of the ISR you MUST have a call to OSIntExit()
    293          *                 at the end of the ISR.
    294          *
    295          *              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    296          ************************************************************************************************************************
    297          */
    298          

   \                                 In section .text, align 2, keep-with-next
    299          void  OSIntExit (void)
    300          {
   \                     OSIntExit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    301          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
    302              CPU_BOOLEAN  stk_status;
    303          #endif
    304              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    305          
    306          
    307          
    308              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Has the OS started?                                  */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD157             BNE.N    ??OSIntExit_0
    309                  OS_TRACE_ISR_EXIT();
    310                  return;                                                 /* No                                                   */
    311              }
    312          
    313              CPU_INT_DIS();
   \                     ??OSIntExit_1: (+1)
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   \   00000014   0x0004             MOVS     R4,R0
    314              if (OSIntNestingCtr == 0u) {                                /* Prevent OSIntNestingCtr from wrapping                */
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD103             BNE.N    ??OSIntExit_2
    315                  OS_TRACE_ISR_EXIT();
    316                  CPU_INT_EN();
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    317                  return;
   \   00000026   0xE04A             B.N      ??OSIntExit_0
    318              }
    319              OSIntNestingCtr--;
   \                     ??OSIntExit_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    320              if (OSIntNestingCtr > 0u) {                                 /* ISRs still nested?                                   */
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD003             BEQ.N    ??OSIntExit_3
    321                  OS_TRACE_ISR_EXIT();
    322                  CPU_INT_EN();                                           /* Yes                                                  */
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       CPU_SR_Restore
    323                  return;
   \   00000046   0xE03A             B.N      ??OSIntExit_0
    324              }
    325          
    326              if (OSSchedLockNestingCtr > 0u) {                           /* Scheduler still locked?                              */
   \                     ??OSIntExit_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD003             BEQ.N    ??OSIntExit_4
    327                  OS_TRACE_ISR_EXIT();
    328                  CPU_INT_EN();                                           /* Yes                                                  */
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
    329                  return;
   \   00000058   0xE031             B.N      ??OSIntExit_0
    330              }
    331          
    332                                                                          /* Verify ISR Stack                                     */
    333          #if (OS_CFG_ISR_STK_SIZE > 0u)
    334          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
    335              stk_status = OS_TaskStkRedzoneChk(OSCfg_ISRStkBasePtr, OSCfg_ISRStkSize);
    336              if (stk_status != OS_TRUE) {
    337                  OSRedzoneHitHook((OS_TCB *)0);
    338              }
    339          #endif
    340          #endif
    341          
    342              OSPrioHighRdy   = OS_PrioGetHighest();                      /* Find highest priority                                */
   \                     ??OSIntExit_4: (+1)
   \   0000005A   0x.... 0x....      BL       OS_PrioGetHighest
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    343          #if (OS_CFG_TASK_IDLE_EN > 0u)
    344              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         /* Get highest priority task ready-to-run               */
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable17_21
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000076   0x6008             STR      R0,[R1, #+0]
    345              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       /* Current task still the highest priority?             */
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD103             BNE.N    ??OSIntExit_5
    346                                                                          /* Yes                                                  */
    347          #if (OS_CFG_TASK_STK_REDZONE_EN > 0u)
    348                  stk_status = OSTaskStkRedzoneChk((OS_TCB *)0);
    349                  if (stk_status != OS_TRUE) {
    350                      OSRedzoneHitHook(OSTCBCurPtr);
    351                  }
    352          #endif
    353                  OS_TRACE_ISR_EXIT();
    354                  CPU_INT_EN();
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
    355                  OS_TRACE_TASK_SWITCHED_IN(OSTCBHighRdyPtr);             /* Do this here because we don't execute OSIntCtxSw().  */
    356                  return;
   \   0000008E   0xE016             B.N      ??OSIntExit_0
    357              }
    358          #else
    359              if (OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u)) {              /* Are we returning to idle?                            */
    360                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* No ... get highest priority task ready-to-run        */
    361                  if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?             */
    362                                                                          /* Yes                                                  */
    363                      OS_TRACE_ISR_EXIT();
    364                      CPU_INT_EN();
    365                      OS_TRACE_TASK_SWITCHED_IN(OSTCBHighRdyPtr);         /* Do this here because we don't execute OSIntCtxSw().  */
    366                      return;
    367                  }
    368              }
    369          #endif
    370          
    371          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    372              OSTCBHighRdyPtr->CtxSwCtr++;                                /* Inc. # of context switches for this new task         */
   \                     ??OSIntExit_5: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000094   0x6800             LDR      R0,[R0, #+0]
   \   00000096   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000009A   0x1C40             ADDS     R0,R0,#+1
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0xF8C1 0x0084      STR      R0,[R1, #+132]
    373          #endif
    374          #if ((OS_CFG_TASK_PROFILE_EN > 0u) || (OS_CFG_DBG_EN > 0u))
    375              OSTaskCtxSwCtr++;                                           /* Keep track of the total number of ctx switches       */
   \   000000A6   0x.... 0x....      LDR.W    R0,??DataTable17_22
   \   000000AA   0x6800             LDR      R0,[R0, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable17_22
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    376          #endif
    377          
    378          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    379              OS_TLS_TaskSw();
    380          #endif
    381          
    382              OS_TRACE_ISR_EXIT_TO_SCHEDULER();
    383          
    384              OSIntCtxSw();                                               /* Perform interrupt level ctx switch                   */
   \   000000B4   0x.... 0x....      BL       OSIntCtxSw
    385          
    386              CPU_INT_EN();
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       CPU_SR_Restore
    387          }
   \                     ??OSIntExit_0: (+1)
   \   000000BE   0xBD10             POP      {R4,PC}          ;; return
    388          
    389          
    390          /*
    391          ************************************************************************************************************************
    392          *                                    INDICATE THAT IT'S NO LONGER SAFE TO CREATE OBJECTS
    393          *
    394          * Description: This function is called by the application code to indicate that all initialization has been completed
    395          *              and that kernel objects are no longer allowed to be created.
    396          *
    397          * Arguments  : none
    398          *
    399          * Returns    : none
    400          *
    401          * Note(s)    : none
    402          ************************************************************************************************************************
    403          */
    404          
    405          #ifdef OS_SAFETY_CRITICAL_IEC61508
    406          void  OSSafetyCriticalStart (void)
    407          {
    408              OSSafetyCriticalStartFlag = OS_TRUE;
    409          }
    410          
    411          #endif
    412          
    413          
    414          /*
    415          ************************************************************************************************************************
    416          *                                                      SCHEDULER
    417          *
    418          * Description: This function is called by other uC/OS-III services to determine whether a new, high priority task has
    419          *              been made ready to run.  This function is invoked by TASK level code and is not used to reschedule tasks
    420          *              from ISRs (see OSIntExit() for ISR rescheduling).
    421          *
    422          * Arguments  : none
    423          *
    424          * Returns    : none
    425          *
    426          * Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
    427          ************************************************************************************************************************
    428          */
    429          

   \                                 In section .text, align 2, keep-with-next
    430          void  OSSched (void)
    431          {
   \                     OSSched: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    432              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    433          
    434          
    435          #if (OS_CFG_INVALID_OS_CALLS_CHK_EN > 0u)                       /* Can't schedule when the kernel is stopped.           */
    436              if (OSRunning != OS_STATE_OS_RUNNING) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD141             BNE.N    ??OSSched_0
    437                  return;
    438              }
    439          #endif
    440          
    441              if (OSIntNestingCtr > 0u) {                                 /* ISRs still nested?                                   */
   \                     ??OSSched_1: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD13C             BNE.N    ??OSSched_0
    442                  return;                                                 /* Yes ... only schedule when no nested ISRs            */
    443              }
    444          
    445              if (OSSchedLockNestingCtr > 0u) {                           /* Scheduler locked?                                    */
   \                     ??OSSched_2: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD137             BNE.N    ??OSSched_0
    446                  return;                                                 /* Yes                                                  */
    447              }
    448          
    449              CPU_INT_DIS();
   \                     ??OSSched_3: (+1)
   \   00000022   0x2040             MOVS     R0,#+64
   \   00000024   0x.... 0x....      BL       CPU_SR_Save
   \   00000028   0x0004             MOVS     R4,R0
    450              OSPrioHighRdy   = OS_PrioGetHighest();                      /* Find the highest priority ready                      */
   \   0000002A   0x.... 0x....      BL       OS_PrioGetHighest
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000032   0x7008             STRB     R0,[R1, #+0]
    451          #if (OS_CFG_TASK_IDLE_EN > 0u)
    452              OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;         /* Get highest priority task ready-to-run               */
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable17_21
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000046   0x6008             STR      R0,[R1, #+0]
    453              if (OSTCBHighRdyPtr == OSTCBCurPtr) {                       /* Current task still the highest priority?             */
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD103             BNE.N    ??OSSched_4
    454                  CPU_INT_EN();                                           /* Yes                                                  */
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    455                  return;
   \   0000005E   0xE018             B.N      ??OSSched_0
    456              }
    457          #else
    458              if (OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u)) {              /* Are we returning to idle?                              */
    459                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* No ... get highest priority task ready-to-run          */
    460                  if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
    461                      CPU_INT_EN();                                       /* Yes                                                    */
    462                      return;
    463                  }
    464              }
    465          #endif
    466          
    467              OS_TRACE_TASK_PREEMPT(OSTCBCurPtr);
    468          
    469          #if (OS_CFG_TASK_PROFILE_EN > 0u)
    470              OSTCBHighRdyPtr->CtxSwCtr++;                                /* Inc. # of context switches to this task              */
   \                     ??OSSched_4: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000070   0x6809             LDR      R1,[R1, #+0]
   \   00000072   0xF8C1 0x0084      STR      R0,[R1, #+132]
    471          #endif
    472          
    473          #if ((OS_CFG_TASK_PROFILE_EN > 0u) || (OS_CFG_DBG_EN > 0u))
    474              OSTaskCtxSwCtr++;                                           /* Increment context switch counter                     */
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable17_22
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable17_22
   \   00000082   0x6008             STR      R0,[R1, #+0]
    475          #endif
    476          
    477          #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    478              OS_TLS_TaskSw();
    479          #endif
    480          
    481          #if (OS_CFG_TASK_IDLE_EN > 0u)
    482              OS_TASK_SW();                                               /* Perform a task level context switch                  */
   \   00000084   0x.... 0x....      BL       OSCtxSw
    483              CPU_INT_EN();
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
    484          #else
    485              if ((OSPrioHighRdy != (OS_CFG_PRIO_MAX - 1u))) {
    486                  OS_TASK_SW();                                           /* Perform a task level context switch                  */
    487                  CPU_INT_EN();
    488              } else {
    489                  OSTCBHighRdyPtr = OSTCBCurPtr;
    490                  CPU_INT_EN();
    491                  for (;;) {
    492          #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_EN > 0u))
    493                      CPU_CRITICAL_ENTER();
    494          #if (OS_CFG_DBG_EN > 0u)
    495                      OSIdleTaskCtr++;
    496          #endif
    497          #if (OS_CFG_STAT_TASK_EN > 0u)
    498                      OSStatTaskCtr++;
    499          #endif
    500                      CPU_CRITICAL_EXIT();
    501          #endif
    502          
    503          #if (OS_CFG_APP_HOOKS_EN > 0u)
    504                      OSIdleTaskHook();                                   /* Call user definable HOOK                             */
    505          #endif
    506                      if ((*((volatile OS_PRIO *)&OSPrioHighRdy) != (OS_CFG_PRIO_MAX - 1u))) {
    507                          break;
    508                      }
    509                  }
    510              }
    511          #endif
    512          
    513          #ifdef OS_TASK_SW_SYNC
    514              OS_TASK_SW_SYNC();
   \   0000008E   0xF3BF 0x8F6F      ISB      
    515          #endif
    516          }
   \                     ??OSSched_0: (+1)
   \   00000092   0xBD10             POP      {R4,PC}          ;; return
    517          
    518          
    519          /*
    520          ************************************************************************************************************************
    521          *                                                 PREVENT SCHEDULING
    522          *
    523          * Description: This function is used to prevent rescheduling from taking place.  This allows your application to prevent
    524          *              context switches until you are ready to permit context switching.
    525          *
    526          * Arguments  : p_err     is a pointer to a variable that will receive an error code:
    527          *
    528          *                            OS_ERR_NONE                 The scheduler is locked
    529          *                            OS_ERR_LOCK_NESTING_OVF     If you attempted to nest call to this function > 250 levels
    530          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet
    531          *                            OS_ERR_SCHED_LOCK_ISR       If you called this function from an ISR
    532          *
    533          * Returns    : none
    534          *
    535          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    536          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    537          ************************************************************************************************************************
    538          */
    539          

   \                                 In section .text, align 2, keep-with-next
    540          void  OSSchedLock (OS_ERR  *p_err)
    541          {
   \                     OSSchedLock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    542              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    543          
    544          
    545          
    546          #ifdef OS_SAFETY_CRITICAL
    547              if (p_err == (OS_ERR *)0) {
    548                  OS_SAFETY_CRITICAL_EXCEPTION();
    549                  return;
    550              }
    551          #endif
    552          
    553          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    554              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedLock_0
    555                 *p_err = OS_ERR_SCHED_LOCK_ISR;
   \   00000010   0xF646 0x5062      MOVW     R0,#+28002
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    556                  return;
   \   00000016   0xE01F             B.N      ??OSSchedLock_1
    557              }
    558          #endif
    559          
    560              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Make sure multitasking is running                    */
   \                     ??OSSchedLock_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSSchedLock_2
    561                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    562                  return;
   \   00000028   0xE016             B.N      ??OSSchedLock_1
    563              }
    564          
    565              if (OSSchedLockNestingCtr >= 250u) {                        /* Prevent OSSchedLockNestingCtr overflowing            */
   \                     ??OSSchedLock_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x28FA             CMP      R0,#+250
   \   00000032   0xD303             BCC.N    ??OSSchedLock_3
    566                 *p_err = OS_ERR_LOCK_NESTING_OVF;
   \   00000034   0xF245 0x2009      MOVW     R0,#+21001
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    567                  return;
   \   0000003A   0xE00D             B.N      ??OSSchedLock_1
    568              }
    569          
    570              CPU_CRITICAL_ENTER();
   \                     ??OSSchedLock_3: (+1)
   \   0000003C   0x2040             MOVS     R0,#+64
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
    571              OSSchedLockNestingCtr++;                                    /* Increment lock nesting level                         */
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000046   0x7809             LDRB     R1,[R1, #+0]
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable17_2
   \   0000004E   0x7011             STRB     R1,[R2, #+0]
    572          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
    573              OS_SchedLockTimeMeasStart();
    574          #endif
    575              CPU_CRITICAL_EXIT();
   \   00000050   0x.... 0x....      BL       CPU_SR_Restore
    576             *p_err = OS_ERR_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x8020             STRH     R0,[R4, #+0]
    577          }
   \                     ??OSSchedLock_1: (+1)
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    578          
    579          
    580          /*
    581          ************************************************************************************************************************
    582          *                                                  ENABLE SCHEDULING
    583          *
    584          * Description: This function is used to re-allow rescheduling.
    585          *
    586          * Arguments  : p_err     is a pointer to a variable that will contain an error code returned by this function.
    587          *
    588          *                            OS_ERR_NONE                 The scheduler has been enabled
    589          *                            OS_ERR_OS_NOT_RUNNING       If uC/OS-III is not running yet
    590          *                            OS_ERR_SCHED_LOCKED         The scheduler is still locked, still nested
    591          *                            OS_ERR_SCHED_NOT_LOCKED     The scheduler was not locked
    592          *                            OS_ERR_SCHED_UNLOCK_ISR     If you called this function from an ISR
    593          *
    594          * Returns    : none
    595          *
    596          * Note(s)    : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every call to
    597          *                 OSSchedLock() you MUST have a call to OSSchedUnlock().
    598          ************************************************************************************************************************
    599          */
    600          

   \                                 In section .text, align 2, keep-with-next
    601          void  OSSchedUnlock (OS_ERR  *p_err)
    602          {
   \                     OSSchedUnlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    603              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    604          
    605          
    606          
    607          #ifdef OS_SAFETY_CRITICAL
    608              if (p_err == (OS_ERR *)0) {
    609                  OS_SAFETY_CRITICAL_EXCEPTION();
    610                  return;
    611              }
    612          #endif
    613          
    614          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    615              if (OSIntNestingCtr > 0u) {                                 /* Not allowed to call from an ISR                      */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedUnlock_0
    616                 *p_err = OS_ERR_SCHED_UNLOCK_ISR;
   \   00000010   0xF646 0x5065      MOVW     R0,#+28005
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    617                  return;
   \   00000016   0xE02C             B.N      ??OSSchedUnlock_1
    618              }
    619          #endif
    620          
    621              if (OSRunning != OS_STATE_OS_RUNNING) {                     /* Make sure multitasking is running                    */
   \                     ??OSSchedUnlock_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD003             BEQ.N    ??OSSchedUnlock_2
    622                 *p_err = OS_ERR_OS_NOT_RUNNING;
   \   00000022   0xF645 0x6089      MOVW     R0,#+24201
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    623                  return;
   \   00000028   0xE023             B.N      ??OSSchedUnlock_1
    624              }
    625          
    626              if (OSSchedLockNestingCtr == 0u) {                          /* See if the scheduler is locked                       */
   \                     ??OSSchedUnlock_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD103             BNE.N    ??OSSchedUnlock_3
    627                 *p_err = OS_ERR_SCHED_NOT_LOCKED;
   \   00000034   0xF646 0x5064      MOVW     R0,#+28004
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    628                  return;
   \   0000003A   0xE01A             B.N      ??OSSchedUnlock_1
    629              }
    630          
    631              CPU_CRITICAL_ENTER();
   \                     ??OSSchedUnlock_3: (+1)
   \   0000003C   0x2040             MOVS     R0,#+64
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
    632              OSSchedLockNestingCtr--;                                    /* Decrement lock nesting level                         */
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000046   0x7809             LDRB     R1,[R1, #+0]
   \   00000048   0x1E49             SUBS     R1,R1,#+1
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable17_2
   \   0000004E   0x7011             STRB     R1,[R2, #+0]
    633              if (OSSchedLockNestingCtr > 0u) {
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x2900             CMP      R1,#+0
   \   00000058   0xD005             BEQ.N    ??OSSchedUnlock_4
    634                  CPU_CRITICAL_EXIT();                                    /* Scheduler is still locked                            */
   \   0000005A   0x.... 0x....      BL       CPU_SR_Restore
    635                 *p_err = OS_ERR_SCHED_LOCKED;
   \   0000005E   0xF646 0x5063      MOVW     R0,#+28003
   \   00000062   0x8020             STRH     R0,[R4, #+0]
    636                  return;
   \   00000064   0xE005             B.N      ??OSSchedUnlock_1
    637              }
    638          
    639          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
    640              OS_SchedLockTimeMeasStop();
    641          #endif
    642          
    643              CPU_CRITICAL_EXIT();                                        /* Scheduler should be re-enabled                       */
   \                     ??OSSchedUnlock_4: (+1)
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
    644              OSSched();                                                  /* Run the scheduler                                    */
   \   0000006A   0x.... 0x....      BL       OSSched
    645             *p_err = OS_ERR_NONE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x8020             STRH     R0,[R4, #+0]
    646          }
   \                     ??OSSchedUnlock_1: (+1)
   \   00000072   0xBD10             POP      {R4,PC}          ;; return
    647          
    648          
    649          /*
    650          ************************************************************************************************************************
    651          *                                      CONFIGURE ROUND-ROBIN SCHEDULING PARAMETERS
    652          *
    653          * Description: This function is called to change the round-robin scheduling parameters.
    654          *
    655          * Arguments  : en                determines whether round-robin will be enabled (when OS_TRUE) or not (when OS_FALSE)
    656          *
    657          *              dflt_time_quanta  default number of ticks between time slices.  0 means OSCfg_TickRate_Hz / 10.
    658          *
    659          *              p_err             is a pointer to a variable that will contain an error code returned by this function.
    660          *
    661          *                                    OS_ERR_NONE    The call was successful
    662          *
    663          * Returns    : none
    664          *
    665          * Note(s)    : none
    666          ************************************************************************************************************************
    667          */
    668          
    669          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    670          void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
    671                                      OS_TICK       dflt_time_quanta,
    672                                      OS_ERR       *p_err)
    673          {
   \                     OSSchedRoundRobinCfg: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0016             MOVS     R6,R2
    674              CPU_SR_ALLOC();
   \   00000008   0x2000             MOVS     R0,#+0
    675          
    676          
    677          
    678          #ifdef OS_SAFETY_CRITICAL
    679              if (p_err == (OS_ERR *)0) {
    680                  OS_SAFETY_CRITICAL_EXCEPTION();
    681                  return;
    682              }
    683          #endif
    684          
    685              CPU_CRITICAL_ENTER();
   \   0000000A   0x2040             MOVS     R0,#+64
   \   0000000C   0x.... 0x....      BL       CPU_SR_Save
    686              if (en == 0u) {
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD104             BNE.N    ??OSSchedRoundRobinCfg_0
    687                  OSSchedRoundRobinEn = OS_FALSE;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable17_7
   \   0000001C   0x7011             STRB     R1,[R2, #+0]
   \   0000001E   0xE003             B.N      ??OSSchedRoundRobinCfg_1
    688              } else {
    689                  OSSchedRoundRobinEn = OS_TRUE;
   \                     ??OSSchedRoundRobinCfg_0: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable17_7
   \   00000026   0x7011             STRB     R1,[R2, #+0]
    690              }
    691          
    692              if (dflt_time_quanta > 0u) {
   \                     ??OSSchedRoundRobinCfg_1: (+1)
   \   00000028   0x2C00             CMP      R4,#+0
   \   0000002A   0xD003             BEQ.N    ??OSSchedRoundRobinCfg_2
    693                  OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_9
   \   00000030   0x600C             STR      R4,[R1, #+0]
   \   00000032   0xE008             B.N      ??OSSchedRoundRobinCfg_3
    694              } else {
    695                  OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / 10u);
   \                     ??OSSchedRoundRobinCfg_2: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable17_8
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x220A             MOVS     R2,#+10
   \   0000003C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable17_9
   \   00000044   0x6011             STR      R1,[R2, #+0]
    696              }
    697              CPU_CRITICAL_EXIT();
   \                     ??OSSchedRoundRobinCfg_3: (+1)
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
    698             *p_err = OS_ERR_NONE;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x8030             STRH     R0,[R6, #+0]
    699          }
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
    700          #endif
    701          
    702          
    703          /*
    704          ************************************************************************************************************************
    705          *                                    YIELD CPU WHEN TASK NO LONGER NEEDS THE TIME SLICE
    706          *
    707          * Description: This function is called to give up the CPU when a task is done executing before its time slice expires.
    708          *
    709          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    710          *
    711          *                             OS_ERR_NONE                   The call was successful
    712          *                             OS_ERR_ROUND_ROBIN_1          Only 1 task at this priority, nothing to yield to
    713          *                             OS_ERR_ROUND_ROBIN_DISABLED   Round Robin is not enabled
    714          *                             OS_ERR_SCHED_LOCKED           The scheduler has been locked
    715          *                             OS_ERR_YIELD_ISR              Can't be called from an ISR
    716          *
    717          * Returns    : none
    718          *
    719          * Note(s)    : 1) This function MUST be called from a task.
    720          ************************************************************************************************************************
    721          */
    722          
    723          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    724          void  OSSchedRoundRobinYield (OS_ERR  *p_err)
    725          {
   \                     OSSchedRoundRobinYield: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    726              OS_RDY_LIST  *p_rdy_list;
    727              OS_TCB       *p_tcb;
    728              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
    729          
    730          
    731          
    732          #ifdef OS_SAFETY_CRITICAL
    733              if (p_err == (OS_ERR *)0) {
    734                  OS_SAFETY_CRITICAL_EXCEPTION();
    735                  return;
    736              }
    737          #endif
    738          
    739          #if (OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u)
    740              if (OSIntNestingCtr > 0u) {                                 /* Can't call this function from an ISR                 */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ.N    ??OSSchedRoundRobinYield_0
    741                 *p_err = OS_ERR_YIELD_ISR;
   \   00000010   0xF248 0x40D1      MOVW     R0,#+34001
   \   00000014   0x8020             STRH     R0,[R4, #+0]
    742                  return;
   \   00000016   0xE03C             B.N      ??OSSchedRoundRobinYield_1
    743              }
    744          #endif
    745          
    746              if (OSSchedLockNestingCtr > 0u) {                           /* Can't yield if the scheduler is locked               */
   \                     ??OSSchedRoundRobinYield_0: (+1)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??OSSchedRoundRobinYield_2
    747                 *p_err = OS_ERR_SCHED_LOCKED;
   \   00000022   0xF646 0x5063      MOVW     R0,#+28003
   \   00000026   0x8020             STRH     R0,[R4, #+0]
    748                  return;
   \   00000028   0xE033             B.N      ??OSSchedRoundRobinYield_1
    749              }
    750          
    751              if (OSSchedRoundRobinEn != OS_TRUE) {                       /* Make sure round-robin has been enabled               */
   \                     ??OSSchedRoundRobinYield_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x2801             CMP      R0,#+1
   \   00000032   0xD003             BEQ.N    ??OSSchedRoundRobinYield_3
    752                 *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
   \   00000034   0xF646 0x107B      MOVW     R0,#+27003
   \   00000038   0x8020             STRH     R0,[R4, #+0]
    753                  return;
   \   0000003A   0xE02A             B.N      ??OSSchedRoundRobinYield_1
    754              }
    755          
    756              CPU_CRITICAL_ENTER();
   \                     ??OSSchedRoundRobinYield_3: (+1)
   \   0000003C   0x2040             MOVS     R0,#+64
   \   0000003E   0x.... 0x....      BL       CPU_SR_Save
   \   00000042   0x0005             MOVS     R5,R0
    757              p_rdy_list = &OSRdyList[OSPrioCur];                         /* Can't yield if it's the only task at that priority   */
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_21
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0xEB00 0x06C1      ADD      R6,R0,R1, LSL #+3
    758              if (p_rdy_list->HeadPtr == p_rdy_list->TailPtr) {
   \   00000052   0x6830             LDR      R0,[R6, #+0]
   \   00000054   0x6871             LDR      R1,[R6, #+4]
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xD106             BNE.N    ??OSSchedRoundRobinYield_4
    759                  CPU_CRITICAL_EXIT();
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       CPU_SR_Restore
    760                 *p_err = OS_ERR_ROUND_ROBIN_1;
   \   00000060   0xF646 0x107A      MOVW     R0,#+27002
   \   00000064   0x8020             STRH     R0,[R4, #+0]
    761                  return;
   \   00000066   0xE014             B.N      ??OSSchedRoundRobinYield_1
    762              }
    763          
    764              OS_RdyListMoveHeadToTail(p_rdy_list);                       /* Move current OS_TCB to the end of the list           */
   \                     ??OSSchedRoundRobinYield_4: (+1)
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
    765              p_tcb = p_rdy_list->HeadPtr;                                /* Point to new OS_TCB at head of the list              */
   \   0000006E   0x6831             LDR      R1,[R6, #+0]
    766              if (p_tcb->TimeQuanta == 0u) {                              /* See if we need to use the default time slice         */
   \   00000070   0x6CC8             LDR      R0,[R1, #+76]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD104             BNE.N    ??OSSchedRoundRobinYield_5
    767                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x6508             STR      R0,[R1, #+80]
   \   0000007E   0xE001             B.N      ??OSSchedRoundRobinYield_6
    768              } else {
    769                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;               /* Load time slice counter with new time                */
   \                     ??OSSchedRoundRobinYield_5: (+1)
   \   00000080   0x6CC8             LDR      R0,[R1, #+76]
   \   00000082   0x6508             STR      R0,[R1, #+80]
    770              }
    771          
    772              CPU_CRITICAL_EXIT();
   \                     ??OSSchedRoundRobinYield_6: (+1)
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
    773          
    774              OSSched();                                                  /* Run new task                                         */
   \   0000008A   0x.... 0x....      BL       OSSched
    775             *p_err = OS_ERR_NONE;
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x8020             STRH     R0,[R4, #+0]
    776          }
   \                     ??OSSchedRoundRobinYield_1: (+1)
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
    777          #endif
    778          
    779          
    780          /*
    781          ************************************************************************************************************************
    782          *                                                 START MULTITASKING
    783          *
    784          * Description: This function is used to start the multitasking process which lets uC/OS-III manage the task that you
    785          *              created.  Before you can call OSStart(), you MUST have called OSInit() and you MUST have created at least
    786          *              one application task.
    787          *
    788          * Argument(s): p_err      is a pointer to a variable that will contain an error code returned by this function.
    789          *
    790          *                             OS_ERR_FATAL_RETURN    OS was running and OSStart() returned
    791          *                             OS_ERR_OS_NOT_INIT     OS is not initialized, OSStart() has no effect
    792          *                             OS_ERR_OS_NO_APP_TASK  No application task created, OSStart() has no effect
    793          *                             OS_ERR_OS_RUNNING      OS is already running, OSStart() has no effect
    794          *
    795          * Returns    : none
    796          *
    797          * Note(s)    : 1) OSStartHighRdy() MUST:
    798          *                 a) Call OSTaskSwHook() then,
    799          *                 b) Load the context of the task pointed to by OSTCBHighRdyPtr.
    800          *                 c) Execute the task.
    801          *
    802          *              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
    803          ************************************************************************************************************************
    804          */
    805          

   \                                 In section .text, align 2, keep-with-next
    806          void  OSStart (OS_ERR  *p_err)
    807          {
   \                     OSStart: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    808              OS_OBJ_QTY  kernel_task_cnt;
    809          
    810          
    811          #ifdef OS_SAFETY_CRITICAL
    812              if (p_err == (OS_ERR *)0) {
    813                  OS_SAFETY_CRITICAL_EXCEPTION();
    814                  return;
    815              }
    816          #endif
    817          
    818              if (OSInitialized != OS_TRUE) {
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_20
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ.N    ??OSStart_0
    819                 *p_err = OS_ERR_OS_NOT_INIT;
   \   0000000E   0xF645 0x608B      MOVW     R0,#+24203
   \   00000012   0x8020             STRH     R0,[R4, #+0]
    820                  return;
   \   00000014   0xE03A             B.N      ??OSStart_1
    821              }
    822          
    823              kernel_task_cnt = 0u;                                       /* Calculate the number of kernel tasks                 */
   \                     ??OSStart_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
    824          #if (OS_CFG_STAT_TASK_EN > 0u)
    825              kernel_task_cnt++;
   \   00000018   0x1C40             ADDS     R0,R0,#+1
    826          #endif
    827          #if (OS_CFG_TMR_EN > 0u)
    828              kernel_task_cnt++;
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
    829          #endif
    830          #if (OS_CFG_TASK_IDLE_EN > 0u)
    831              kernel_task_cnt++;
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    832          #endif
    833          
    834              if (OSTaskQty <= kernel_task_cnt) {                         /* No application task created                          */
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable17_23
   \   00000022   0x8809             LDRH     R1,[R1, #+0]
   \   00000024   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD303             BCC.N    ??OSStart_2
    835                  *p_err = OS_ERR_OS_NO_APP_TASK;
   \   0000002A   0xF645 0x608C      MOVW     R0,#+24204
   \   0000002E   0x8020             STRH     R0,[R4, #+0]
    836                   return;
   \   00000030   0xE02C             B.N      ??OSStart_1
    837              }
    838          
    839              if (OSRunning == OS_STATE_OS_STOPPED) {
   \                     ??OSStart_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD124             BNE.N    ??OSStart_3
    840                  OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority                            */
   \   0000003C   0x.... 0x....      BL       OS_PrioGetHighest
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    841                  OSPrioCur       = OSPrioHighRdy;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    842                  OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_21
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0xF850 0x0031      LDR      R0,[R0, R1, LSL #+3]
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000064   0x6008             STR      R0,[R1, #+0]
    843                  OSTCBCurPtr     = OSTCBHighRdyPtr;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000070   0x6008             STR      R0,[R1, #+0]
    844                  OSRunning       = OS_STATE_OS_RUNNING;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable17_1
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    845                  OSStartHighRdy();                                       /* Execute target specific code to start task           */
   \   0000007A   0x.... 0x....      BL       OSStartHighRdy
    846                 *p_err           = OS_ERR_FATAL_RETURN;                  /* OSStart() is not supposed to return                  */
   \   0000007E   0xF643 0x2099      MOVW     R0,#+15001
   \   00000082   0x8020             STRH     R0,[R4, #+0]
   \   00000084   0xE002             B.N      ??OSStart_4
    847              } else {
    848                 *p_err           = OS_ERR_OS_RUNNING;                    /* OS is already running                                */
   \                     ??OSStart_3: (+1)
   \   00000086   0xF645 0x608A      MOVW     R0,#+24202
   \   0000008A   0x8020             STRH     R0,[R4, #+0]
    849              }
    850          }
   \                     ??OSStart_4: (+1)
   \                     ??OSStart_1: (+1)
   \   0000008C   0xBD10             POP      {R4,PC}          ;; return
    851          
    852          
    853          /*
    854          ************************************************************************************************************************
    855          *                                                    GET VERSION
    856          *
    857          * Description: This function is used to return the version number of uC/OS-III.  The returned value corresponds to
    858          *              uC/OS-III's version number multiplied by 10000.  In other words, version 3.01.02 would be returned as 30102.
    859          *
    860          * Arguments  : p_err   is a pointer to a variable that will receive an error code.  However, OSVersion() set this
    861          *                      variable to
    862          *
    863          *                         OS_ERR_NONE
    864          *
    865          * Returns    : The version number of uC/OS-III multiplied by 10000.
    866          *
    867          * Note(s)    : none
    868          ************************************************************************************************************************
    869          */
    870          

   \                                 In section .text, align 2, keep-with-next
    871          CPU_INT16U  OSVersion (OS_ERR  *p_err)
    872          {
    873          #ifdef OS_SAFETY_CRITICAL
    874              if (p_err == (OS_ERR *)0) {
    875                  OS_SAFETY_CRITICAL_EXCEPTION();
    876                  return (0u);
    877              }
    878          #endif
    879          
    880             *p_err = OS_ERR_NONE;
   \                     OSVersion: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    881              return (OS_VERSION);
   \   00000004   0xF647 0x0052      MOVW     R0,#+30802
   \   00000008   0x4770             BX       LR               ;; return
    882          }
    883          
    884          
    885          /*
    886          ************************************************************************************************************************
    887          *                                                      IDLE TASK
    888          *
    889          * Description: This task is internal to uC/OS-III and executes whenever no other higher priority tasks executes because
    890          *              they are ALL waiting for event(s) to occur.
    891          *
    892          * Arguments  : p_arg    is an argument passed to the task when the task is created.
    893          *
    894          * Returns    : none
    895          *
    896          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    897          *
    898          *              2) OSIdleTaskHook() is called after the critical section to ensure that interrupts will be enabled for at
    899          *                 least a few instructions.  On some processors (ex. Philips XA), enabling and then disabling interrupts
    900          *                 doesn't allow the processor enough time to have interrupts enabled before they were disabled again.
    901          *                 uC/OS-III would thus never recognize interrupts.
    902          *
    903          *              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
    904          ************************************************************************************************************************
    905          */
    906          #if (OS_CFG_TASK_IDLE_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    907          void  OS_IdleTask (void  *p_arg)
    908          {
   \                     OS_IdleTask: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    909          #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_EN > 0u))
    910              CPU_SR_ALLOC();
   \   00000002   0x2000             MOVS     R0,#+0
    911          #endif
    912          
    913          
    914              (void)p_arg;                                                /* Prevent compiler warning for not using 'p_arg'       */
    915          
    916              for (;;) {
    917          #if ((OS_CFG_DBG_EN > 0u) || (OS_CFG_STAT_TASK_EN > 0u))
    918                  CPU_CRITICAL_ENTER();
   \                     ??OS_IdleTask_0: (+1)
   \   00000004   0x2040             MOVS     R0,#+64
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
    919          #if (OS_CFG_DBG_EN > 0u)
    920                  OSIdleTaskCtr++;
    921          #endif
    922          #if (OS_CFG_STAT_TASK_EN > 0u)
    923                  OSStatTaskCtr++;
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable17_24
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable17_24
   \   00000016   0x6011             STR      R1,[R2, #+0]
    924          #endif
    925                  CPU_CRITICAL_EXIT();
   \   00000018   0x.... 0x....      BL       CPU_SR_Restore
    926          #endif
    927          
    928          #if (OS_CFG_APP_HOOKS_EN > 0u)
    929                  OSIdleTaskHook();                                       /* Call user definable HOOK                             */
   \   0000001C   0x.... 0x....      BL       OSIdleTaskHook
   \   00000020   0xE7F0             B.N      ??OS_IdleTask_0
    930          #endif
    931              }
    932          }
    933          #endif
    934          
    935          /*
    936          ************************************************************************************************************************
    937          *                                               INITIALIZE THE IDLE TASK
    938          *
    939          * Description: This function initializes the idle task
    940          *
    941          * Arguments  : p_err    is a pointer to a variable that will contain an error code returned by this function.
    942          *
    943          * Returns    : none
    944          *
    945          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
    946          ************************************************************************************************************************
    947          */
    948          #if (OS_CFG_TASK_IDLE_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
    949          void  OS_IdleTaskInit (OS_ERR  *p_err)
    950          {
   \                     OS_IdleTaskInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    951          #if (OS_CFG_DBG_EN > 0u)
    952              OSIdleTaskCtr = 0u;
    953          #endif
    954                                                                          /* --------------- CREATE THE IDLE TASK --------------- */
    955              OSTaskCreate(&OSIdleTaskTCB,
    956          #if  (OS_CFG_DBG_EN == 0u)
    957                           (CPU_CHAR   *)0,
    958          #else
    959                           (CPU_CHAR   *)"uC/OS-III Idle Task",
    960          #endif
    961                            OS_IdleTask,
    962                           (void       *)0,
    963                           (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
    964                            OSCfg_IdleTaskStkBasePtr,
    965                            OSCfg_IdleTaskStkLimit,
    966                            OSCfg_IdleTaskStkSize,
    967                            0u,
    968                            0u,
    969                           (void       *)0,
    970                           (OS_OPT_TASK_STK_CHK | (OS_OPT)(OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS)),
    971                            p_err);
   \   00000004   0x9008             STR      R0,[SP, #+32]
   \   00000006   0x200B             MOVS     R0,#+11
   \   00000008   0x9007             STR      R0,[SP, #+28]
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x9006             STR      R0,[SP, #+24]
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9005             STR      R0,[SP, #+20]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x9004             STR      R0,[SP, #+16]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_25
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable17_27
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x9001             STR      R0,[SP, #+4]
   \   0000002E   0x203F             MOVS     R0,#+63
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable17_28
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_29
   \   0000003E   0x.... 0x....      BL       OSTaskCreate
    972          }
   \   00000042   0xB009             ADD      SP,SP,#+36
   \   00000044   0xBD00             POP      {PC}             ;; return
    973          #endif
    974          
    975          /*
    976          ************************************************************************************************************************
    977          *                                             BLOCK A TASK PENDING ON EVENT
    978          *
    979          * Description: This function is called to place a task in the blocked state waiting for an event to occur. This function
    980          *              exists because it is common to a number of OSxxxPend() services.
    981          *
    982          * Arguments  : p_obj          is a pointer to the object to pend on.  If there are no object used to pend on then
    983          *              -----          the caller must pass a NULL pointer.
    984          *
    985          *              p_tcb          is the task that will be blocked.
    986          *
    987          *              pending_on     Specifies what the task will be pending on:
    988          *
    989          *                                 OS_TASK_PEND_ON_FLAG
    990          *                                 OS_TASK_PEND_ON_TASK_Q     <- No object (pending for a message sent to the task)
    991          *                                 OS_TASK_PEND_ON_MUTEX
    992          *                                 OS_TASK_PEND_ON_COND
    993          *                                 OS_TASK_PEND_ON_Q
    994          *                                 OS_TASK_PEND_ON_SEM
    995          *                                 OS_TASK_PEND_ON_TASK_SEM   <- No object (pending on a signal sent to the task)
    996          *
    997          *              timeout        Is the amount of time the task will wait for the event to occur.
    998          *
    999          * Returns    : none
   1000          *
   1001          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1002          ************************************************************************************************************************
   1003          */
   1004          

   \                                 In section .text, align 2, keep-with-next
   1005          void  OS_Pend (OS_PEND_OBJ  *p_obj,
   1006                         OS_TCB       *p_tcb,
   1007                         OS_STATE      pending_on,
   1008                         OS_TICK       timeout)
   1009          {
   \                     OS_Pend: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0019             MOVS     R1,R3
   1010              OS_PEND_LIST  *p_pend_list;
   1011          
   1012          
   1013              p_tcb->PendOn     = pending_on;                             /* Resource not available, wait until it is             */
   \   00000008   0xF885 0x202C      STRB     R2,[R5, #+44]
   1014              p_tcb->PendStatus = OS_STATUS_PEND_OK;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF885 0x002D      STRB     R0,[R5, #+45]
   1015          
   1016              OS_TaskBlock(p_tcb,                                         /* Block the task and add it to the tick list if needed */
   1017                           timeout);
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       OS_TaskBlock
   1018          
   1019              if (p_obj != (OS_PEND_OBJ *)0) {                            /* Add the current task to the pend list ...            */
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD005             BEQ.N    ??OS_Pend_0
   1020                  p_pend_list             = &p_obj->PendList;             /* ... if there is an object to pend on                 */
   \   0000001C   0x1D20             ADDS     R0,R4,#+4
   1021                  p_tcb->PendObjPtr =  p_obj;                             /* Save the pointer to the object pending on            */
   \   0000001E   0x62AC             STR      R4,[R5, #+40]
   1022                  OS_PendListInsertPrio(p_pend_list,                      /* Insert in the pend list in priority order            */
   1023                                        p_tcb);
   \   00000020   0x0029             MOVS     R1,R5
   \   00000022   0x.... 0x....      BL       OS_PendListInsertPrio
   \   00000026   0xE001             B.N      ??OS_Pend_1
   1024          
   1025              } else {
   1026                  p_tcb->PendObjPtr = (OS_PEND_OBJ *)0;                   /* If no object being pended on, clear the pend object  */
   \                     ??OS_Pend_0: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x62A8             STR      R0,[R5, #+40]
   1027              }
   1028          #if (OS_CFG_DBG_EN > 0u)
   1029              OS_PendDbgNameAdd(p_obj,
   1030                                p_tcb);
   1031          #endif
   1032          }
   \                     ??OS_Pend_1: (+1)
   \   0000002C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1033          
   1034          
   1035          /*
   1036          ************************************************************************************************************************
   1037          *                                                    CANCEL PENDING
   1038          *
   1039          * Description: This function is called by the OSxxxPendAbort() and OSxxxDel() functions to cancel pending on an event.
   1040          *
   1041          * Arguments  : p_tcb          Is a pointer to the OS_TCB of the task that we'll abort the pend for
   1042          *              -----
   1043          *
   1044          *              ts             Is a timestamp as to when the pend was cancelled
   1045          *
   1046          *              reason         Indicates how the task was readied:
   1047          *
   1048          *                                 OS_STATUS_PEND_DEL       Object pended on was deleted.
   1049          *                                 OS_STATUS_PEND_ABORT     Pend was aborted.
   1050          *
   1051          * Returns    : none
   1052          *
   1053          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1054          ************************************************************************************************************************
   1055          */
   1056          

   \                                 In section .text, align 2, keep-with-next
   1057          void  OS_PendAbort (OS_TCB     *p_tcb,
   1058                              CPU_TS      ts,
   1059                              OS_STATUS   reason)
   1060          {
   \                     OS_PendAbort: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1061          #if (OS_CFG_TS_EN == 0u)
   1062              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
   1063          #endif
   1064          
   1065              switch (p_tcb->TaskState) {
   \   00000006   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000000A   0x1E80             SUBS     R0,R0,#+2
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD903             BLS.N    ??OS_PendAbort_0
   \   00000010   0x1F00             SUBS     R0,R0,#+4
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD91B             BLS.N    ??OS_PendAbort_1
   \   00000016   0xE032             B.N      ??OS_PendAbort_2
   1066                  case OS_TASK_STATE_PEND:
   1067                  case OS_TASK_STATE_PEND_TIMEOUT:
   1068          #if (OS_MSG_EN > 0u)
   1069                       p_tcb->MsgPtr     = (void *)0;
   \                     ??OS_PendAbort_0: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6560             STR      R0,[R4, #+84]
   1070                       p_tcb->MsgSize    =         0u;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   1071          #endif
   1072          #if (OS_CFG_TS_EN > 0u)
   1073                       p_tcb->TS         = ts;
   1074          #endif
   1075                       OS_PendListRemove(p_tcb);                          /* Remove task from the pend list                       */
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       OS_PendListRemove
   1076          
   1077          #if (OS_CFG_TICK_EN > 0u)
   1078                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \   00000028   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000002C   0x2803             CMP      R0,#+3
   \   0000002E   0xD102             BNE.N    ??OS_PendAbort_3
   1079                           OS_TickListRemove(p_tcb);                      /* Cancel the timeout                                   */
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       OS_TickListRemove
   1080                       }
   1081          #endif
   1082                       OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
   \                     ??OS_PendAbort_3: (+1)
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       OS_RdyListInsert
   1083                       p_tcb->TaskState  = OS_TASK_STATE_RDY;             /* Task will be ready                                   */
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xF884 0x002E      STRB     R0,[R4, #+46]
   1084                       p_tcb->PendStatus = reason;                        /* Indicate how the task became ready                   */
   \   00000042   0xF884 0x502D      STRB     R5,[R4, #+45]
   1085                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xF884 0x002C      STRB     R0,[R4, #+44]
   1086                       break;
   \   0000004C   0xE017             B.N      ??OS_PendAbort_4
   1087          
   1088                  case OS_TASK_STATE_PEND_SUSPENDED:
   1089                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1090          #if (OS_MSG_EN > 0u)
   1091                       p_tcb->MsgPtr     = (void *)0;
   \                     ??OS_PendAbort_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x6560             STR      R0,[R4, #+84]
   1092                       p_tcb->MsgSize    =         0u;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xF8A4 0x0058      STRH     R0,[R4, #+88]
   1093          #endif
   1094          #if (OS_CFG_TS_EN > 0u)
   1095                       p_tcb->TS         = ts;
   1096          #endif
   1097                       OS_PendListRemove(p_tcb);                          /* Remove task from the pend list                       */
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       OS_PendListRemove
   1098          
   1099          #if (OS_CFG_TICK_EN > 0u)
   1100                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \   0000005E   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000062   0x2807             CMP      R0,#+7
   \   00000064   0xD102             BNE.N    ??OS_PendAbort_5
   1101                           OS_TickListRemove(p_tcb);                      /* Cancel the timeout                                   */
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       OS_TickListRemove
   1102                       }
   1103          #endif
   1104                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;       /* Task needs to remain suspended                       */
   \                     ??OS_PendAbort_5: (+1)
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0xF884 0x002E      STRB     R0,[R4, #+46]
   1105                       p_tcb->PendStatus = reason;                        /* Indicate how the task became ready                   */
   \   00000072   0xF884 0x502D      STRB     R5,[R4, #+45]
   1106                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x002C      STRB     R0,[R4, #+44]
   1107                       break;
   \   0000007C   0xE7FF             B.N      ??OS_PendAbort_4
   1108          
   1109                  case OS_TASK_STATE_RDY:                                 /* Cannot cancel a pend when a task is in these states. */
   1110                  case OS_TASK_STATE_DLY:
   1111                  case OS_TASK_STATE_SUSPENDED:
   1112                  case OS_TASK_STATE_DLY_SUSPENDED:
   1113                  default:
   1114                                                                          /* Default case.                                        */
   1115                       break;
   1116              }
   1117          }
   \                     ??OS_PendAbort_2: (+1)
   \                     ??OS_PendAbort_4: (+1)
   \   0000007E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1118          
   1119          
   1120          /*
   1121          ************************************************************************************************************************
   1122          *                                     ADD/REMOVE DEBUG NAMES TO PENDED OBJECT AND OS_TCB
   1123          *
   1124          * Description: These functions are used to add pointers to ASCII 'names' of objects so they can easily be displayed
   1125          *              using a kernel aware tool.
   1126          *
   1127          * Arguments  : p_obj              is a pointer to the object being pended on
   1128          *
   1129          *              p_tcb              is a pointer to the OS_TCB of the task pending on the object
   1130          *
   1131          * Returns    : none
   1132          *
   1133          * Note(s)    : 1) These functions are INTERNAL to uC/OS-III and your application must not call it.
   1134          ************************************************************************************************************************
   1135          */
   1136          
   1137          #if (OS_CFG_DBG_EN > 0u)
   1138          void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
   1139                                   OS_TCB       *p_tcb)
   1140          {
   1141              OS_PEND_LIST  *p_pend_list;
   1142              OS_TCB        *p_tcb1;
   1143          
   1144          
   1145              if (p_obj != (OS_PEND_OBJ *)0) {
   1146                  p_tcb->DbgNamePtr =  p_obj->NamePtr;                    /* Task pending on this object ... save name in TCB     */
   1147                  p_pend_list       = &p_obj->PendList;                   /* Find name of HP task pending on this object ...      */
   1148                  p_tcb1            =  p_pend_list->HeadPtr;
   1149                  p_obj->DbgNamePtr =  p_tcb1->NamePtr;                   /* ... Save in object                                   */
   1150              } else {
   1151                  switch (p_tcb->PendOn) {
   1152                      case OS_TASK_PEND_ON_TASK_Q:
   1153                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
   1154                           break;
   1155          
   1156                      case OS_TASK_PEND_ON_TASK_SEM:
   1157                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
   1158                           break;
   1159          
   1160                      default:
   1161                           p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
   1162                           break;
   1163                  }
   1164              }
   1165          }
   1166          
   1167          
   1168          void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
   1169                                      OS_TCB       *p_tcb)
   1170          {
   1171              OS_PEND_LIST  *p_pend_list;
   1172              OS_TCB        *p_tcb1;
   1173          
   1174          
   1175              p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");              /* Remove name of object pended on for readied task     */
   1176          
   1177              if (p_obj != (OS_PEND_OBJ *)0) {
   1178                  p_pend_list = &p_obj->PendList;
   1179                  p_tcb1      =  p_pend_list->HeadPtr;
   1180                  if (p_tcb1 != (OS_TCB *)0) {                            /* Find name of HP task pending on this object ...      */
   1181                      p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                   */
   1182                  } else {
   1183                      p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* Or no other task is pending on object                */
   1184                  }
   1185              }
   1186          }
   1187          #endif
   1188          
   1189          
   1190          /*
   1191          ************************************************************************************************************************
   1192          *                                 CHANGE THE PRIORITY OF A TASK WAITING IN A PEND LIST
   1193          *
   1194          * Description: This function is called to change the position of a task waiting in a pend list. The strategy used is to
   1195          *              remove the task from the pend list and add it again using its changed priority.
   1196          *
   1197          * Arguments  : p_tcb       is a pointer to the TCB of the task to move
   1198          *              -----
   1199          *
   1200          * Returns    : none
   1201          *
   1202          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1203          *
   1204          *              2) It's assumed that the TCB contains the NEW priority in its .Prio field.
   1205          ************************************************************************************************************************
   1206          */
   1207          

   \                                 In section .text, align 2, keep-with-next
   1208          void  OS_PendListChangePrio (OS_TCB  *p_tcb)
   1209          {
   \                     OS_PendListChangePrio: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1210              OS_PEND_LIST  *p_pend_list;
   1211              OS_PEND_OBJ   *p_obj;
   1212          
   1213              p_obj       =  p_tcb->PendObjPtr;                           /* Get pointer to pend list                             */
   \   00000004   0x6AA6             LDR      R6,[R4, #+40]
   1214              p_pend_list = &p_obj->PendList;
   \   00000006   0x1D35             ADDS     R5,R6,#+4
   1215          
   1216              if (p_pend_list->HeadPtr->PendNextPtr != (OS_TCB *)0) {     /* Only move if multiple entries in the list            */
   \   00000008   0x6828             LDR      R0,[R5, #+0]
   \   0000000A   0x6A00             LDR      R0,[R0, #+32]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD007             BEQ.N    ??OS_PendListChangePrio_0
   1217                      OS_PendListRemove(p_tcb);                           /* Remove entry from current position                   */
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       OS_PendListRemove
   1218                      p_tcb->PendObjPtr = p_obj;
   \   00000016   0x62A6             STR      R6,[R4, #+40]
   1219                      OS_PendListInsertPrio(p_pend_list,                  /* INSERT it back in the list                           */
   1220                                            p_tcb);
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       OS_PendListInsertPrio
   1221              }
   1222          }
   \                     ??OS_PendListChangePrio_0: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
   1223          
   1224          
   1225          /*
   1226          ************************************************************************************************************************
   1227          *                                                INITIALIZE A WAIT LIST
   1228          *
   1229          * Description: This function is called to initialize the fields of an OS_PEND_LIST.
   1230          *
   1231          * Arguments  : p_pend_list   is a pointer to an OS_PEND_LIST
   1232          *              -----------
   1233          *
   1234          * Returns    : none
   1235          *
   1236          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application must not call it.
   1237          ************************************************************************************************************************
   1238          */
   1239          

   \                                 In section .text, align 2, keep-with-next
   1240          void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
   1241          {
   1242              p_pend_list->HeadPtr    = (OS_TCB *)0;
   \                     OS_PendListInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1243              p_pend_list->TailPtr    = (OS_TCB *)0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x6041             STR      R1,[R0, #+4]
   1244          #if (OS_CFG_DBG_EN > 0u)
   1245              p_pend_list->NbrEntries =           0u;
   1246          #endif
   1247          }
   \   00000008   0x4770             BX       LR               ;; return
   1248          
   1249          
   1250          /*
   1251          ************************************************************************************************************************
   1252          *                                  INSERT A TASK BASED ON IT'S PRIORITY IN A PEND LIST
   1253          *
   1254          * Description: This function is called to place an OS_TCB entry in a linked list based on its priority.  The
   1255          *              highest priority being placed at the head of the list. The TCB is assumed to contain the priority
   1256          *              of the task in its .Prio field.
   1257          *
   1258          *              CASE 0: Insert in an empty list.
   1259          *
   1260          *                     OS_PEND_LIST
   1261          *                     +---------------+
   1262          *                     | TailPtr       |-> 0
   1263          *                     +---------------+
   1264          *                     | HeadPtr       |-> 0
   1265          *                     +---------------+
   1266          *                     | NbrEntries=0  |
   1267          *                     +---------------+
   1268          *
   1269          *
   1270          *
   1271          *              CASE 1: Insert BEFORE or AFTER an OS_TCB
   1272          *
   1273          *                     OS_PEND_LIST
   1274          *                     +--------------+         OS_TCB
   1275          *                     | TailPtr      |--+---> +--------------+
   1276          *                     +--------------+  |     | PendNextPtr  |->0
   1277          *                     | HeadPtr      |--/     +--------------+
   1278          *                     +--------------+     0<-| PendPrevPtr  |
   1279          *                     | NbrEntries=1 |        +--------------+
   1280          *                     +--------------+        |              |
   1281          *                                             +--------------+
   1282          *                                             |              |
   1283          *                                             +--------------+
   1284          *
   1285          *
   1286          *                     OS_PEND_LIST
   1287          *                     +--------------+
   1288          *                     | TailPtr      |---------------------------------------------------+
   1289          *                     +--------------+         OS_TCB                 OS_TCB             |    OS_TCB
   1290          *                     | HeadPtr      |------> +--------------+       +--------------+    +-> +--------------+
   1291          *                     +--------------+        | PendNextPtr  |<------| PendNextPtr  | ...... | PendNextPtr  |->0
   1292          *                     | NbrEntries=N |        +--------------+       +--------------+        +--------------+
   1293          *                     +--------------+     0<-| PendPrevPtr  |<------| PendPrevPtr  | ...... | PendPrevPtr  |
   1294          *                                             +--------------+       +--------------+        +--------------+
   1295          *                                             |              |       |              |        |              |
   1296          *                                             +--------------+       +--------------+        +--------------+
   1297          *                                             |              |       |              |        |              |
   1298          *                                             +--------------+       +--------------+        +--------------+
   1299          *
   1300          *
   1301          * Arguments  : p_pend_list    is a pointer to the OS_PEND_LIST where the OS_TCB entry will be inserted
   1302          *              -----------
   1303          *
   1304          *              p_tcb          is the OS_TCB to insert in the list
   1305          *              -----
   1306          *
   1307          * Returns    : none
   1308          *
   1309          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1310          ************************************************************************************************************************
   1311          */
   1312          

   \                                 In section .text, align 2, keep-with-next
   1313          void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
   1314                                       OS_TCB        *p_tcb)
   1315          {
   \                     OS_PendListInsertPrio: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0002             MOVS     R2,R0
   1316              OS_PRIO   prio;
   1317              OS_TCB   *p_tcb_next;
   1318          
   1319          
   1320              prio  = p_tcb->Prio;                                        /* Obtain the priority of the task to insert            */
   \   00000004   0xF891 0x302F      LDRB     R3,[R1, #+47]
   1321          
   1322              if (p_pend_list->HeadPtr == (OS_TCB *)0) {                  /* CASE 0: Insert when there are no entries             */
   \   00000008   0x6810             LDR      R0,[R2, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD106             BNE.N    ??OS_PendListInsertPrio_0
   1323          #if (OS_CFG_DBG_EN > 0u)
   1324                  p_pend_list->NbrEntries = 1u;                           /* This is the first entry                              */
   1325          #endif
   1326                  p_tcb->PendNextPtr   = (OS_TCB *)0;                     /* No other OS_TCBs in the list                         */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x6208             STR      R0,[R1, #+32]
   1327                  p_tcb->PendPrevPtr   = (OS_TCB *)0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x6248             STR      R0,[R1, #+36]
   1328                  p_pend_list->HeadPtr =  p_tcb;
   \   00000016   0x6011             STR      R1,[R2, #+0]
   1329                  p_pend_list->TailPtr =  p_tcb;
   \   00000018   0x6051             STR      R1,[R2, #+4]
   \   0000001A   0xE023             B.N      ??OS_PendListInsertPrio_1
   1330              } else {
   1331          #if (OS_CFG_DBG_EN > 0u)
   1332                  p_pend_list->NbrEntries++;                              /* CASE 1: One more OS_TCBs in the list                 */
   1333          #endif
   1334                  p_tcb_next = p_pend_list->HeadPtr;
   \                     ??OS_PendListInsertPrio_0: (+1)
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0xE000             B.N      ??OS_PendListInsertPrio_2
   1335                  while (p_tcb_next != (OS_TCB *)0) {                     /* Find the position where to insert                    */
   1336                      if (prio < p_tcb_next->Prio) {
   1337                          break;                                          /* Found! ... insert BEFORE current                     */
   1338                      } else {
   1339                          p_tcb_next = p_tcb_next->PendNextPtr;           /* Not Found, follow the list                           */
   \                     ??OS_PendListInsertPrio_3: (+1)
   \   00000020   0x6A00             LDR      R0,[R0, #+32]
   1340                      }
   \                     ??OS_PendListInsertPrio_2: (+1)
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD005             BEQ.N    ??OS_PendListInsertPrio_4
   \   00000026   0x001C             MOVS     R4,R3
   \   00000028   0xF890 0x502F      LDRB     R5,[R0, #+47]
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x42AC             CMP      R4,R5
   \   00000030   0xD2F6             BCS.N    ??OS_PendListInsertPrio_3
   1341                  }
   1342                  if (p_tcb_next == (OS_TCB *)0) {                        /* TCB to insert is lowest in priority                  */
   \                     ??OS_PendListInsertPrio_4: (+1)
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD107             BNE.N    ??OS_PendListInsertPrio_5
   1343                      p_tcb->PendNextPtr              = (OS_TCB *)0;      /* ... insert at the tail.                              */
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6208             STR      R0,[R1, #+32]
   1344                      p_tcb->PendPrevPtr              =  p_pend_list->TailPtr;
   \   0000003A   0x6850             LDR      R0,[R2, #+4]
   \   0000003C   0x6248             STR      R0,[R1, #+36]
   1345                      p_tcb->PendPrevPtr->PendNextPtr =  p_tcb;
   \   0000003E   0x6A48             LDR      R0,[R1, #+36]
   \   00000040   0x6201             STR      R1,[R0, #+32]
   1346                      p_pend_list->TailPtr            =  p_tcb;
   \   00000042   0x6051             STR      R1,[R2, #+4]
   \   00000044   0xE00E             B.N      ??OS_PendListInsertPrio_1
   1347                  } else {
   1348                      if (p_tcb_next->PendPrevPtr == (OS_TCB *)0) {       /* Is new TCB highest priority?                         */
   \                     ??OS_PendListInsertPrio_5: (+1)
   \   00000046   0x6A43             LDR      R3,[R0, #+36]
   \   00000048   0x2B00             CMP      R3,#+0
   \   0000004A   0xD105             BNE.N    ??OS_PendListInsertPrio_6
   1349                          p_tcb->PendNextPtr      =  p_tcb_next;          /* Yes, insert as new Head of list                      */
   \   0000004C   0x6208             STR      R0,[R1, #+32]
   1350                          p_tcb->PendPrevPtr      = (OS_TCB *)0;
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x624B             STR      R3,[R1, #+36]
   1351                          p_tcb_next->PendPrevPtr =  p_tcb;
   \   00000052   0x6241             STR      R1,[R0, #+36]
   1352                          p_pend_list->HeadPtr    =  p_tcb;
   \   00000054   0x6011             STR      R1,[R2, #+0]
   \   00000056   0xE005             B.N      ??OS_PendListInsertPrio_1
   1353                      } else {                                            /* No,  insert in between two entries                   */
   1354                          p_tcb->PendNextPtr              = p_tcb_next;
   \                     ??OS_PendListInsertPrio_6: (+1)
   \   00000058   0x6208             STR      R0,[R1, #+32]
   1355                          p_tcb->PendPrevPtr              = p_tcb_next->PendPrevPtr;
   \   0000005A   0x6A42             LDR      R2,[R0, #+36]
   \   0000005C   0x624A             STR      R2,[R1, #+36]
   1356                          p_tcb->PendPrevPtr->PendNextPtr = p_tcb;
   \   0000005E   0x6A4A             LDR      R2,[R1, #+36]
   \   00000060   0x6211             STR      R1,[R2, #+32]
   1357                          p_tcb_next->PendPrevPtr         = p_tcb;
   \   00000062   0x6241             STR      R1,[R0, #+36]
   1358                      }
   1359                  }
   1360              }
   1361          }
   \                     ??OS_PendListInsertPrio_1: (+1)
   \   00000064   0xBC30             POP      {R4,R5}
   \   00000066   0x4770             BX       LR               ;; return
   1362          
   1363          
   1364          /*
   1365          ************************************************************************************************************************
   1366          *                           REMOVE TASK FROM A PEND LIST KNOWING ONLY WHICH TCB TO REMOVE
   1367          *
   1368          * Description: This function is called to remove a task from a pend list knowing the TCB of the task to remove.
   1369          *
   1370          *              CASE 0: OS_PEND_LIST list is empty, nothing to do.
   1371          *
   1372          *              CASE 1: Only 1 OS_TCB in the list.
   1373          *
   1374          *                     OS_PEND_LIST
   1375          *                     +--------------+         OS_TCB
   1376          *                     | TailPtr      |--+---> +--------------+
   1377          *                     +--------------+  |     | PendNextPtr  |->0
   1378          *                     | HeadPtr      |--/     +--------------+
   1379          *                     +--------------+     0<-| PendPrevPtr  |
   1380          *                     | NbrEntries=1 |        +--------------+
   1381          *                     +--------------+        |              |
   1382          *                                             +--------------+
   1383          *                                             |              |
   1384          *                                             +--------------+
   1385          *
   1386          *              CASE N: Two or more OS_TCBs in the list.
   1387          *
   1388          *                     OS_PEND_LIST
   1389          *                     +--------------+
   1390          *                     | TailPtr      |---------------------------------------------------+
   1391          *                     +--------------+         OS_TCB                 OS_TCB             |    OS_TCB
   1392          *                     | HeadPtr      |------> +--------------+       +--------------+    +-> +--------------+
   1393          *                     +--------------+        | PendNextPtr  |<------| PendNextPtr  | ...... | PendNextPtr  |->0
   1394          *                     | NbrEntries=N |        +--------------+       +--------------+        +--------------+
   1395          *                     +--------------+     0<-| PendPrevPtr  |<------| PendPrevPtr  | ...... | PendPrevPtr  |
   1396          *                                             +--------------+       +--------------+        +--------------+
   1397          *                                             |              |       |              |        |              |
   1398          *                                             +--------------+       +--------------+        +--------------+
   1399          *                                             |              |       |              |        |              |
   1400          *                                             +--------------+       +--------------+        +--------------+
   1401          *
   1402          *
   1403          * Arguments  : p_tcb          is a pointer to the TCB of the task to remove from the pend list
   1404          *              -----
   1405          *
   1406          * Returns    : none
   1407          *
   1408          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1409          ************************************************************************************************************************
   1410          */
   1411          

   \                                 In section .text, align 2, keep-with-next
   1412          void  OS_PendListRemove (OS_TCB  *p_tcb)
   1413          {
   1414              OS_PEND_LIST  *p_pend_list;
   1415              OS_TCB        *p_next;
   1416              OS_TCB        *p_prev;
   1417          
   1418          
   1419              if (p_tcb->PendObjPtr != (OS_PEND_OBJ *)0) {                /* Only remove if object has a pend list.               */
   \                     OS_PendListRemove: (+1)
   \   00000000   0x6A81             LDR      R1,[R0, #+40]
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD024             BEQ.N    ??OS_PendListRemove_0
   1420                  p_pend_list = &p_tcb->PendObjPtr->PendList;             /* Get pointer to pend list                             */
   \   00000006   0x6A81             LDR      R1,[R0, #+40]
   \   00000008   0x1D0A             ADDS     R2,R1,#+4
   1421          
   1422                                                                          /* Remove TCB from the pend list.                       */
   1423                  if (p_pend_list->HeadPtr->PendNextPtr == (OS_TCB *)0) {
   \   0000000A   0x6811             LDR      R1,[R2, #+0]
   \   0000000C   0x6A09             LDR      R1,[R1, #+32]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD104             BNE.N    ??OS_PendListRemove_1
   1424                      p_pend_list->HeadPtr = (OS_TCB *)0;                 /* Only one entry in the pend list                      */
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6011             STR      R1,[R2, #+0]
   1425                      p_pend_list->TailPtr = (OS_TCB *)0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6051             STR      R1,[R2, #+4]
   \   0000001A   0xE013             B.N      ??OS_PendListRemove_2
   1426                  } else if (p_tcb->PendPrevPtr == (OS_TCB *)0) {         /* See if entry is at the head of the list              */
   \                     ??OS_PendListRemove_1: (+1)
   \   0000001C   0x6A41             LDR      R1,[R0, #+36]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD104             BNE.N    ??OS_PendListRemove_3
   1427                      p_next               =  p_tcb->PendNextPtr;         /* Yes                                                  */
   \   00000022   0x6A01             LDR      R1,[R0, #+32]
   1428                      p_next->PendPrevPtr  = (OS_TCB *)0;
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x624B             STR      R3,[R1, #+36]
   1429                      p_pend_list->HeadPtr =  p_next;
   \   00000028   0x6011             STR      R1,[R2, #+0]
   \   0000002A   0xE00B             B.N      ??OS_PendListRemove_2
   1430          
   1431                  } else if (p_tcb->PendNextPtr == (OS_TCB *)0) {         /* See if entry is at the tail of the list              */
   \                     ??OS_PendListRemove_3: (+1)
   \   0000002C   0x6A01             LDR      R1,[R0, #+32]
   \   0000002E   0x2900             CMP      R1,#+0
   \   00000030   0xD104             BNE.N    ??OS_PendListRemove_4
   1432                      p_prev               =  p_tcb->PendPrevPtr;         /* Yes                                                  */
   \   00000032   0x6A41             LDR      R1,[R0, #+36]
   1433                      p_prev->PendNextPtr  = (OS_TCB *)0;
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x620B             STR      R3,[R1, #+32]
   1434                      p_pend_list->TailPtr =  p_prev;
   \   00000038   0x6051             STR      R1,[R2, #+4]
   \   0000003A   0xE003             B.N      ??OS_PendListRemove_2
   1435          
   1436                  } else {
   1437                      p_prev               = p_tcb->PendPrevPtr;          /* Remove from inside the list                          */
   \                     ??OS_PendListRemove_4: (+1)
   \   0000003C   0x6A42             LDR      R2,[R0, #+36]
   1438                      p_next               = p_tcb->PendNextPtr;
   \   0000003E   0x6A01             LDR      R1,[R0, #+32]
   1439                      p_prev->PendNextPtr  = p_next;
   \   00000040   0x6211             STR      R1,[R2, #+32]
   1440                      p_next->PendPrevPtr  = p_prev;
   \   00000042   0x624A             STR      R2,[R1, #+36]
   1441                  }
   1442          #if (OS_CFG_DBG_EN > 0u)
   1443                  p_pend_list->NbrEntries--;                              /* One less entry in the list                           */
   1444          #endif
   1445                  p_tcb->PendNextPtr = (OS_TCB      *)0;
   \                     ??OS_PendListRemove_2: (+1)
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x6201             STR      R1,[R0, #+32]
   1446                  p_tcb->PendPrevPtr = (OS_TCB      *)0;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x6241             STR      R1,[R0, #+36]
   1447                  p_tcb->PendObjPtr  = (OS_PEND_OBJ *)0;
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6281             STR      R1,[R0, #+40]
   1448              }
   1449          }
   \                     ??OS_PendListRemove_0: (+1)
   \   00000050   0x4770             BX       LR               ;; return
   1450          
   1451          
   1452          /*
   1453          ************************************************************************************************************************
   1454          *                                                   POST TO A TASK
   1455          *
   1456          * Description: This function is called to post to a task.  This function exist because it is common to a number of
   1457          *              OSxxxPost() services.
   1458          *
   1459          * Arguments  : p_obj          Is a pointer to the object being posted to or NULL pointer if there is no object
   1460          *              -----
   1461          *
   1462          *              p_tcb          Is a pointer to the OS_TCB that will receive the 'post'
   1463          *              -----
   1464          *
   1465          *              p_void         If we are posting a message to a task, this is the message that the task will receive
   1466          *
   1467          *              msg_size       If we are posting a message to a task, this is the size of the message
   1468          *
   1469          *              ts             The timestamp as to when the post occurred
   1470          *
   1471          * Returns    : none
   1472          *
   1473          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1474          ************************************************************************************************************************
   1475          */
   1476          

   \                                 In section .text, align 2, keep-with-next
   1477          void  OS_Post (OS_PEND_OBJ  *p_obj,
   1478                         OS_TCB       *p_tcb,
   1479                         void         *p_void,
   1480                         OS_MSG_SIZE   msg_size,
   1481                         CPU_TS        ts)
   1482          {
   \                     OS_Post: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1483          #if (OS_CFG_TS_EN == 0u)
   1484              (void)ts;                                                   /* Prevent compiler warning for not using 'ts'          */
   1485          #endif
   1486          #if (OS_MSG_EN == 0u)
   1487              (void)p_void;
   1488              (void)msg_size;
   1489          #endif
   1490          
   1491              switch (p_tcb->TaskState) {
   \   00000004   0xF894 0x102E      LDRB     R1,[R4, #+46]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD00B             BEQ.N    ??OS_Post_0
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD00A             BEQ.N    ??OS_Post_1
   \   00000010   0xD308             BCC.N    ??OS_Post_0
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD006             BEQ.N    ??OS_Post_0
   \   00000016   0xD306             BCC.N    ??OS_Post_1
   \   00000018   0x2906             CMP      R1,#+6
   \   0000001A   0xD020             BEQ.N    ??OS_Post_2
   \   0000001C   0xD302             BCC.N    ??OS_Post_0
   \   0000001E   0x2907             CMP      R1,#+7
   \   00000020   0xD01D             BEQ.N    ??OS_Post_2
   \   00000022   0xE035             B.N      ??OS_Post_3
   1492                  case OS_TASK_STATE_RDY:                                 /* Cannot Post a task that is ready                     */
   1493                  case OS_TASK_STATE_DLY:                                 /* Cannot Post a task that is delayed                   */
   1494                  case OS_TASK_STATE_SUSPENDED:                           /* Cannot Post a suspended task                         */
   1495                  case OS_TASK_STATE_DLY_SUSPENDED:                       /* Cannot Post a suspended task that was also dly'd     */
   1496                       break;
   \                     ??OS_Post_0: (+1)
   \   00000024   0xE034             B.N      ??OS_Post_4
   1497          
   1498                  case OS_TASK_STATE_PEND:
   1499                  case OS_TASK_STATE_PEND_TIMEOUT:
   1500          #if (OS_MSG_EN > 0u)
   1501                       p_tcb->MsgPtr  = p_void;                           /* Deposit message in OS_TCB of task waiting            */
   \                     ??OS_Post_1: (+1)
   \   00000026   0x6562             STR      R2,[R4, #+84]
   1502                       p_tcb->MsgSize = msg_size;                         /* ... assuming posting a message                       */
   \   00000028   0xF8A4 0x3058      STRH     R3,[R4, #+88]
   1503          #endif
   1504          #if (OS_CFG_TS_EN > 0u)
   1505                           p_tcb->TS      = ts;
   1506          #endif
   1507                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??OS_Post_5
   1508                           OS_PendListRemove(p_tcb);                      /* Remove task from pend list                           */
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       OS_PendListRemove
   1509                       }
   1510          #if (OS_CFG_DBG_EN > 0u)
   1511                       OS_PendDbgNameRemove(p_obj,
   1512                                            p_tcb);
   1513          #endif
   1514          #if (OS_CFG_TICK_EN > 0u)
   1515                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT) {
   \                     ??OS_Post_5: (+1)
   \   00000036   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD102             BNE.N    ??OS_Post_6
   1516                           OS_TickListRemove(p_tcb);                      /* Remove from tick list                                */
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       OS_TickListRemove
   1517                       }
   1518          #endif
   1519                       OS_RdyListInsert(p_tcb);                           /* Insert the task in the ready list                    */
   \                     ??OS_Post_6: (+1)
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       OS_RdyListInsert
   1520                       p_tcb->TaskState  = OS_TASK_STATE_RDY;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xF884 0x002E      STRB     R0,[R4, #+46]
   1521                       p_tcb->PendStatus = OS_STATUS_PEND_OK;             /* Clear pend status                                    */
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF884 0x002D      STRB     R0,[R4, #+45]
   1522                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF884 0x002C      STRB     R0,[R4, #+44]
   1523                       break;
   \   0000005C   0xE018             B.N      ??OS_Post_4
   1524          
   1525                  case OS_TASK_STATE_PEND_SUSPENDED:
   1526                  case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
   1527          #if (OS_MSG_EN > 0u)
   1528                       p_tcb->MsgPtr  = p_void;                           /* Deposit message in OS_TCB of task waiting            */
   \                     ??OS_Post_2: (+1)
   \   0000005E   0x6562             STR      R2,[R4, #+84]
   1529                       p_tcb->MsgSize = msg_size;                         /* ... assuming posting a message                       */
   \   00000060   0xF8A4 0x3058      STRH     R3,[R4, #+88]
   1530          #endif
   1531          #if (OS_CFG_TS_EN > 0u)
   1532                       p_tcb->TS      = ts;
   1533          #endif
   1534                       if (p_obj != (OS_PEND_OBJ *)0) {
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD002             BEQ.N    ??OS_Post_7
   1535                           OS_PendListRemove(p_tcb);                      /* Remove from pend list                                */
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       OS_PendListRemove
   1536                       }
   1537          #if (OS_CFG_DBG_EN > 0u)
   1538                       OS_PendDbgNameRemove(p_obj,
   1539                                            p_tcb);
   1540          #endif
   1541          #if (OS_CFG_TICK_EN > 0u)
   1542                       if (p_tcb->TaskState == OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED) {
   \                     ??OS_Post_7: (+1)
   \   0000006E   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \   00000072   0x2807             CMP      R0,#+7
   \   00000074   0xD102             BNE.N    ??OS_Post_8
   1543                           OS_TickListRemove(p_tcb);                      /* Cancel any timeout                                   */
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       OS_TickListRemove
   1544                       }
   1545          #endif
   1546                       p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
   \                     ??OS_Post_8: (+1)
   \   0000007C   0x2004             MOVS     R0,#+4
   \   0000007E   0xF884 0x002E      STRB     R0,[R4, #+46]
   1547                       p_tcb->PendStatus = OS_STATUS_PEND_OK;             /* Clear pend status                                    */
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x002D      STRB     R0,[R4, #+45]
   1548                       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;       /* Indicate no longer pending                           */
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF884 0x002C      STRB     R0,[R4, #+44]
   1549                       break;
   \   0000008E   0xE7FF             B.N      ??OS_Post_4
   1550          
   1551                  default:
   1552                                                                          /* Default case.                                        */
   1553                       break;
   1554              }
   1555          }
   \                     ??OS_Post_3: (+1)
   \                     ??OS_Post_4: (+1)
   \   00000090   0xBD10             POP      {R4,PC}          ;; return
   1556          
   1557          
   1558          /*
   1559          ************************************************************************************************************************
   1560          *                                                    INITIALIZATION
   1561          *                                               READY LIST INITIALIZATION
   1562          *
   1563          * Description: This function is called by OSInit() to initialize the ready list.  The ready list contains a list of all
   1564          *              the tasks that are ready to run.  The list is actually an array of OS_RDY_LIST.  An OS_RDY_LIST contains
   1565          *              three fields.  The number of OS_TCBs in the list (i.e. .NbrEntries), a pointer to the first OS_TCB in the
   1566          *              OS_RDY_LIST (i.e. .HeadPtr) and a pointer to the last OS_TCB in the OS_RDY_LIST (i.e. .TailPtr).
   1567          *
   1568          *              OS_TCBs are doubly linked in the OS_RDY_LIST and each OS_TCB points pack to the OS_RDY_LIST it belongs
   1569          *              to.
   1570          *
   1571          *              'OS_RDY_LIST  OSRdyTbl[OS_CFG_PRIO_MAX]'  looks like this once initialized:
   1572          *
   1573          *                               +---------------+--------------+
   1574          *                               |               | TailPtr      |-----> 0
   1575          *                          [0]  | NbrEntries=0  +--------------+
   1576          *                               |               | HeadPtr      |-----> 0
   1577          *                               +---------------+--------------+
   1578          *                               |               | TailPtr      |-----> 0
   1579          *                          [1]  | NbrEntries=0  +--------------+
   1580          *                               |               | HeadPtr      |-----> 0
   1581          *                               +---------------+--------------+
   1582          *                                       :              :
   1583          *                                       :              :
   1584          *                                       :              :
   1585          *                               +---------------+--------------+
   1586          *                               |               | TailPtr      |-----> 0
   1587          *          [OS_CFG_PRIO_MAX-1]  | NbrEntries=0  +--------------+
   1588          *                               |               | HeadPtr      |-----> 0
   1589          *                               +---------------+--------------+
   1590          *
   1591          *
   1592          * Arguments  : none
   1593          *
   1594          * Returns    : none
   1595          *
   1596          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1597          ************************************************************************************************************************
   1598          */
   1599          

   \                                 In section .text, align 2, keep-with-next
   1600          void  OS_RdyListInit (void)
   1601          {
   1602              CPU_INT32U    i;
   1603              OS_RDY_LIST  *p_rdy_list;
   1604          
   1605          
   1606          
   1607              for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                    /* Initialize the array of OS_RDY_LIST at each priority */
   \                     OS_RdyListInit: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE007             B.N      ??OS_RdyListInit_0
   1608                  p_rdy_list = &OSRdyList[i];
   \                     ??OS_RdyListInit_1: (+1)
   \   00000004   0x....             LDR.N    R1,??DataTable17_21
   \   00000006   0xEB01 0x01C0      ADD      R1,R1,R0, LSL #+3
   1609          #if (OS_CFG_DBG_EN > 0u)
   1610                  p_rdy_list->NbrEntries =           0u;
   1611          #endif
   1612                  p_rdy_list->HeadPtr    = (OS_TCB *)0;
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   1613                  p_rdy_list->TailPtr    = (OS_TCB *)0;
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x604A             STR      R2,[R1, #+4]
   1614              }
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \                     ??OS_RdyListInit_0: (+1)
   \   00000014   0x2840             CMP      R0,#+64
   \   00000016   0xD3F5             BCC.N    ??OS_RdyListInit_1
   1615          }
   \   00000018   0x4770             BX       LR               ;; return
   1616          
   1617          
   1618          /*
   1619          ************************************************************************************************************************
   1620          *                                             INSERT TCB IN THE READY LIST
   1621          *
   1622          * Description: This function is called to insert a TCB in the ready list.
   1623          *
   1624          *              The TCB is inserted at the tail of the list if the priority of the TCB is the same as the priority of the
   1625          *              current task.  The TCB is inserted at the head of the list if not.
   1626          *
   1627          * Arguments  : p_tcb     is a pointer to the TCB to insert into the ready list
   1628          *              -----
   1629          *
   1630          * Returns    : none
   1631          *
   1632          * Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
   1633          ************************************************************************************************************************
   1634          */
   1635          

   \                                 In section .text, align 2, keep-with-next
   1636          void  OS_RdyListInsert (OS_TCB  *p_tcb)
   1637          {
   \                     OS_RdyListInsert: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1638              OS_PrioInsert(p_tcb->Prio);
   \   00000004   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   00000008   0x.... 0x....      BL       OS_PrioInsert
   1639              if (p_tcb->Prio == OSPrioCur) {                             /* Are we readying a task at the same prio?             */
   \   0000000C   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   00000010   0x....             LDR.N    R1,??DataTable17_5
   \   00000012   0x7809             LDRB     R1,[R1, #+0]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD103             BNE.N    ??OS_RdyListInsert_0
   1640                  OS_RdyListInsertTail(p_tcb);                            /* Yes, insert readied task at the end of the list      */
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       OS_RdyListInsertTail
   \   0000001E   0xE002             B.N      ??OS_RdyListInsert_1
   1641              } else {
   1642                  OS_RdyListInsertHead(p_tcb);                            /* No,  insert readied task at the beginning of the list*/
   \                     ??OS_RdyListInsert_0: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       OS_RdyListInsertHead
   1643              }
   1644          
   1645              OS_TRACE_TASK_READY(p_tcb);
   1646          }
   \                     ??OS_RdyListInsert_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   1647          
   1648          
   1649          /*
   1650          ************************************************************************************************************************
   1651          *                                          INSERT TCB AT THE BEGINNING OF A LIST
   1652          *
   1653          * Description: This function is called to place an OS_TCB at the beginning of a linked list as follows:
   1654          *
   1655          *              CASE 0: Insert in an empty list.
   1656          *
   1657          *                     OS_RDY_LIST
   1658          *                     +--------------+
   1659          *                     | TailPtr      |-> 0
   1660          *                     +--------------+
   1661          *                     | HeadPtr      |-> 0
   1662          *                     +--------------+
   1663          *                     | NbrEntries=0 |
   1664          *                     +--------------+
   1665          *
   1666          *
   1667          *
   1668          *              CASE 1: Insert BEFORE the current head of list
   1669          *
   1670          *                     OS_RDY_LIST
   1671          *                     +--------------+          OS_TCB
   1672          *                     | TailPtr      |--+---> +------------+
   1673          *                     +--------------+  |     | NextPtr    |->0
   1674          *                     | HeadPtr      |--/     +------------+
   1675          *                     +--------------+     0<-| PrevPtr    |
   1676          *                     | NbrEntries=1 |        +------------+
   1677          *                     +--------------+        :            :
   1678          *                                             :            :
   1679          *                                             +------------+
   1680          *
   1681          *
   1682          *                     OS_RDY_LIST
   1683          *                     +--------------+
   1684          *                     | TailPtr      |-----------------------------------------------+
   1685          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1686          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1687          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1688          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1689          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1690          *                                             +------------+       +------------+        +------------+
   1691          *                                             :            :       :            :        :            :
   1692          *                                             :            :       :            :        :            :
   1693          *                                             +------------+       +------------+        +------------+
   1694          *
   1695          *
   1696          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   1697          *              -----
   1698          *
   1699          * Returns    : none
   1700          *
   1701          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1702          ************************************************************************************************************************
   1703          */
   1704          

   \                                 In section .text, align 2, keep-with-next
   1705          void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
   1706          {
   1707              OS_RDY_LIST  *p_rdy_list;
   1708              OS_TCB       *p_tcb2;
   1709          
   1710          
   1711          
   1712              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertHead: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_21
   \   00000002   0xF890 0x202F      LDRB     R2,[R0, #+47]
   \   00000006   0xEB01 0x02C2      ADD      R2,R1,R2, LSL #+3
   1713              if (p_rdy_list->HeadPtr == (OS_TCB *)0) {                   /* CASE 0: Insert when there are no entries             */
   \   0000000A   0x6811             LDR      R1,[R2, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD106             BNE.N    ??OS_RdyListInsertHead_0
   1714          #if (OS_CFG_DBG_EN > 0u)
   1715                  p_rdy_list->NbrEntries =           1u;                  /* This is the first entry                              */
   1716          #endif
   1717                  p_tcb->NextPtr         = (OS_TCB *)0;                   /* No other OS_TCBs in the list                         */
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
   1718                  p_tcb->PrevPtr         = (OS_TCB *)0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
   1719                  p_rdy_list->HeadPtr    =  p_tcb;                        /* Both list pointers point to this OS_TCB              */
   \   00000018   0x6010             STR      R0,[R2, #+0]
   1720                  p_rdy_list->TailPtr    =  p_tcb;
   \   0000001A   0x6050             STR      R0,[R2, #+4]
   \   0000001C   0xE006             B.N      ??OS_RdyListInsertHead_1
   1721              } else {                                                    /* CASE 1: Insert BEFORE the current head of list       */
   1722          #if (OS_CFG_DBG_EN > 0u)
   1723                  p_rdy_list->NbrEntries++;                               /* One more OS_TCB in the list                          */
   1724          #endif
   1725                  p_tcb->NextPtr         =  p_rdy_list->HeadPtr;          /* Adjust new OS_TCBs links                             */
   \                     ??OS_RdyListInsertHead_0: (+1)
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   1726                  p_tcb->PrevPtr         = (OS_TCB *)0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x6101             STR      R1,[R0, #+16]
   1727                  p_tcb2                 =  p_rdy_list->HeadPtr;          /* Adjust old head of list's links                      */
   \   00000026   0x6811             LDR      R1,[R2, #+0]
   1728                  p_tcb2->PrevPtr        =  p_tcb;
   \   00000028   0x6108             STR      R0,[R1, #+16]
   1729                  p_rdy_list->HeadPtr    =  p_tcb;
   \   0000002A   0x6010             STR      R0,[R2, #+0]
   1730              }
   1731          }
   \                     ??OS_RdyListInsertHead_1: (+1)
   \   0000002C   0x4770             BX       LR               ;; return
   1732          
   1733          
   1734          /*
   1735          ************************************************************************************************************************
   1736          *                                           INSERT TCB AT THE END OF A LIST
   1737          *
   1738          * Description: This function is called to place an OS_TCB at the end of a linked list as follows:
   1739          *
   1740          *              CASE 0: Insert in an empty list.
   1741          *
   1742          *                     OS_RDY_LIST
   1743          *                     +--------------+
   1744          *                     | TailPtr      |-> 0
   1745          *                     +--------------+
   1746          *                     | HeadPtr      |-> 0
   1747          *                     +--------------+
   1748          *                     | NbrEntries=0 |
   1749          *                     +--------------+
   1750          *
   1751          *
   1752          *
   1753          *              CASE 1: Insert AFTER the current tail of list
   1754          *
   1755          *                     OS_RDY_LIST
   1756          *                     +--------------+          OS_TCB
   1757          *                     | TailPtr      |--+---> +------------+
   1758          *                     +--------------+  |     | NextPtr    |->0
   1759          *                     | HeadPtr      |--/     +------------+
   1760          *                     +--------------+     0<-| PrevPtr    |
   1761          *                     | NbrEntries=1 |        +------------+
   1762          *                     +--------------+        :            :
   1763          *                                             :            :
   1764          *                                             +------------+
   1765          *
   1766          *
   1767          *                     OS_RDY_LIST
   1768          *                     +--------------+
   1769          *                     | TailPtr      |-----------------------------------------------+
   1770          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1771          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1772          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1773          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1774          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1775          *                                             +------------+       +------------+        +------------+
   1776          *                                             :            :       :            :        :            :
   1777          *                                             :            :       :            :        :            :
   1778          *                                             +------------+       +------------+        +------------+
   1779          *
   1780          *
   1781          * Arguments  : p_tcb     is the OS_TCB to insert in the list
   1782          *              -----
   1783          *
   1784          * Returns    : none
   1785          *
   1786          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1787          ************************************************************************************************************************
   1788          */
   1789          

   \                                 In section .text, align 2, keep-with-next
   1790          void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
   1791          {
   1792              OS_RDY_LIST  *p_rdy_list;
   1793              OS_TCB       *p_tcb2;
   1794          
   1795          
   1796          
   1797              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \                     OS_RdyListInsertTail: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_21
   \   00000002   0xF890 0x202F      LDRB     R2,[R0, #+47]
   \   00000006   0xEB01 0x02C2      ADD      R2,R1,R2, LSL #+3
   1798              if (p_rdy_list->HeadPtr == (OS_TCB *)0) {                   /* CASE 0: Insert when there are no entries             */
   \   0000000A   0x6811             LDR      R1,[R2, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD106             BNE.N    ??OS_RdyListInsertTail_0
   1799          #if (OS_CFG_DBG_EN > 0u)
   1800                  p_rdy_list->NbrEntries  =           1u;                 /* This is the first entry                              */
   1801          #endif
   1802                  p_tcb->NextPtr          = (OS_TCB *)0;                  /* No other OS_TCBs in the list                         */
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x60C1             STR      R1,[R0, #+12]
   1803                  p_tcb->PrevPtr          = (OS_TCB *)0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6101             STR      R1,[R0, #+16]
   1804                  p_rdy_list->HeadPtr     =  p_tcb;                       /* Both list pointers point to this OS_TCB              */
   \   00000018   0x6010             STR      R0,[R2, #+0]
   1805                  p_rdy_list->TailPtr     =  p_tcb;
   \   0000001A   0x6050             STR      R0,[R2, #+4]
   \   0000001C   0xE005             B.N      ??OS_RdyListInsertTail_1
   1806              } else {                                                    /* CASE 1: Insert AFTER the current tail of list        */
   1807          #if (OS_CFG_DBG_EN > 0u)
   1808                  p_rdy_list->NbrEntries++;                               /* One more OS_TCB in the list                          */
   1809          #endif
   1810                  p_tcb->NextPtr          = (OS_TCB *)0;                  /* Adjust new OS_TCBs links                             */
   \                     ??OS_RdyListInsertTail_0: (+1)
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x60C1             STR      R1,[R0, #+12]
   1811                  p_tcb2                  =  p_rdy_list->TailPtr;
   \   00000022   0x6851             LDR      R1,[R2, #+4]
   1812                  p_tcb->PrevPtr          =  p_tcb2;
   \   00000024   0x6101             STR      R1,[R0, #+16]
   1813                  p_tcb2->NextPtr         =  p_tcb;                       /* Adjust old tail of list's links                      */
   \   00000026   0x60C8             STR      R0,[R1, #+12]
   1814                  p_rdy_list->TailPtr     =  p_tcb;
   \   00000028   0x6050             STR      R0,[R2, #+4]
   1815              }
   1816          }
   \                     ??OS_RdyListInsertTail_1: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
   1817          
   1818          
   1819          /*
   1820          ************************************************************************************************************************
   1821          *                                                MOVE TCB AT HEAD TO TAIL
   1822          *
   1823          * Description: This function is called to move the current head of a list to the tail of the list.
   1824          *
   1825          *
   1826          *              CASE 0: TCB list is empty, nothing to do.
   1827          *
   1828          *              CASE 1: Only 1 OS_TCB  in the list, nothing to do.
   1829          *
   1830          *              CASE 2: Only 2 OS_TCBs in the list.
   1831          *
   1832          *                     OS_RDY_LIST
   1833          *                     +--------------+
   1834          *                     | TailPtr      |--------------------------+
   1835          *                     +--------------+          OS_TCB          |     OS_TCB
   1836          *                     | HeadPtr      |------> +------------+    +-> +------------+
   1837          *                     +--------------+        | NextPtr    |------> | NextPtr    |->0
   1838          *                     | NbrEntries=2 |        +------------+        +------------+
   1839          *                     +--------------+     0<-| PrevPtr    | <------| PrevPtr    |
   1840          *                                             +------------+        +------------+
   1841          *                                             :            :        :            :
   1842          *                                             :            :        :            :
   1843          *                                             +------------+        +------------+
   1844          *
   1845          *
   1846          *              CASE N: More than 2 OS_TCBs in the list.
   1847          *
   1848          *                     OS_RDY_LIST
   1849          *                     +--------------+
   1850          *                     | TailPtr      |-----------------------------------------------+
   1851          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1852          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1853          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1854          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1855          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1856          *                                             +------------+       +------------+        +------------+
   1857          *                                             :            :       :            :        :            :
   1858          *                                             :            :       :            :        :            :
   1859          *                                             +------------+       +------------+        +------------+
   1860          *
   1861          *
   1862          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST where the OS_TCB will be inserted
   1863          *              ------
   1864          *
   1865          * Returns    : none
   1866          *
   1867          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1868          ************************************************************************************************************************
   1869          */
   1870          

   \                                 In section .text, align 2, keep-with-next
   1871          void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
   1872          {
   \                     OS_RdyListMoveHeadToTail: (+1)
   \   00000000   0xB410             PUSH     {R4}
   1873              OS_TCB  *p_tcb1;
   1874              OS_TCB  *p_tcb2;
   1875              OS_TCB  *p_tcb3;
   1876          
   1877          
   1878               if (p_rdy_list->HeadPtr != p_rdy_list->TailPtr) {
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x6842             LDR      R2,[R0, #+4]
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD01A             BEQ.N    ??OS_RdyListMoveHeadToTail_0
   1879                   if (p_rdy_list->HeadPtr->NextPtr == p_rdy_list->TailPtr) { /* SWAP the TCBs                                    */
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x68C9             LDR      R1,[R1, #+12]
   \   0000000E   0x6842             LDR      R2,[R0, #+4]
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xD10A             BNE.N    ??OS_RdyListMoveHeadToTail_1
   1880                       p_tcb1              =  p_rdy_list->HeadPtr;        /* Point to current head                                */
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   1881                       p_tcb2              =  p_rdy_list->TailPtr;        /* Point to current tail                                */
   \   00000016   0x6842             LDR      R2,[R0, #+4]
   1882                       p_tcb1->PrevPtr     =  p_tcb2;
   \   00000018   0x610A             STR      R2,[R1, #+16]
   1883                       p_tcb1->NextPtr     = (OS_TCB *)0;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x60CB             STR      R3,[R1, #+12]
   1884                       p_tcb2->PrevPtr     = (OS_TCB *)0;
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x6113             STR      R3,[R2, #+16]
   1885                       p_tcb2->NextPtr     =  p_tcb1;
   \   00000022   0x60D1             STR      R1,[R2, #+12]
   1886                       p_rdy_list->HeadPtr =  p_tcb2;
   \   00000024   0x6002             STR      R2,[R0, #+0]
   1887                       p_rdy_list->TailPtr =  p_tcb1;
   \   00000026   0x6041             STR      R1,[R0, #+4]
   \   00000028   0xE00A             B.N      ??OS_RdyListMoveHeadToTail_0
   1888                   } else {
   1889                       p_tcb1              =  p_rdy_list->HeadPtr;        /* Point to current head                                */
   \                     ??OS_RdyListMoveHeadToTail_1: (+1)
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   1890                       p_tcb2              =  p_rdy_list->TailPtr;        /* Point to current tail                                */
   \   0000002C   0x6842             LDR      R2,[R0, #+4]
   1891                       p_tcb3              =  p_tcb1->NextPtr;            /* Point to new list head                               */
   \   0000002E   0x68CB             LDR      R3,[R1, #+12]
   1892                       p_tcb3->PrevPtr     = (OS_TCB *)0;                 /* Adjust back    link of new list head                 */
   \   00000030   0x2400             MOVS     R4,#+0
   \   00000032   0x611C             STR      R4,[R3, #+16]
   1893                       p_tcb1->NextPtr     = (OS_TCB *)0;                 /* Adjust forward link of new list tail                 */
   \   00000034   0x2400             MOVS     R4,#+0
   \   00000036   0x60CC             STR      R4,[R1, #+12]
   1894                       p_tcb1->PrevPtr     =  p_tcb2;                     /* Adjust back    link of new list tail                 */
   \   00000038   0x610A             STR      R2,[R1, #+16]
   1895                       p_tcb2->NextPtr     =  p_tcb1;                     /* Adjust forward link of old list tail                 */
   \   0000003A   0x60D1             STR      R1,[R2, #+12]
   1896                       p_rdy_list->HeadPtr =  p_tcb3;                     /* Adjust new list head and tail pointers               */
   \   0000003C   0x6003             STR      R3,[R0, #+0]
   1897                       p_rdy_list->TailPtr =  p_tcb1;
   \   0000003E   0x6041             STR      R1,[R0, #+4]
   1898                   }
   1899               }
   1900          }
   \                     ??OS_RdyListMoveHeadToTail_0: (+1)
   \   00000040   0xBC10             POP      {R4}
   \   00000042   0x4770             BX       LR               ;; return
   1901          
   1902          
   1903          /*
   1904          ************************************************************************************************************************
   1905          *                                REMOVE TCB FROM LIST KNOWING ONLY WHICH OS_TCB TO REMOVE
   1906          *
   1907          * Description: This function is called to remove an OS_TCB from an OS_RDY_LIST knowing the address of the OS_TCB to
   1908          *              remove.
   1909          *
   1910          *
   1911          *              CASE 0: TCB list is empty, nothing to do.
   1912          *
   1913          *              CASE 1: Only 1 OS_TCBs in the list.
   1914          *
   1915          *                     OS_RDY_LIST
   1916          *                     +--------------+          OS_TCB
   1917          *                     | TailPtr      |--+---> +------------+
   1918          *                     +--------------+  |     | NextPtr    |->0
   1919          *                     | HeadPtr      |--/     +------------+
   1920          *                     +--------------+     0<-| PrevPtr    |
   1921          *                     | NbrEntries=1 |        +------------+
   1922          *                     +--------------+        :            :
   1923          *                                             :            :
   1924          *                                             +------------+
   1925          *
   1926          *              CASE N: Two or more OS_TCBs in the list.
   1927          *
   1928          *                     OS_RDY_LIST
   1929          *                     +--------------+
   1930          *                     | TailPtr      |-----------------------------------------------+
   1931          *                     +--------------+          OS_TCB               OS_TCB          |     OS_TCB
   1932          *                     | HeadPtr      |------> +------------+       +------------+    +-> +------------+
   1933          *                     +--------------+        | NextPtr    |------>| NextPtr    | ...... | NextPtr    |->0
   1934          *                     | NbrEntries=N |        +------------+       +------------+        +------------+
   1935          *                     +--------------+     0<-| PrevPtr    |<------| PrevPtr    | ...... | PrevPtr    |
   1936          *                                             +------------+       +------------+        +------------+
   1937          *                                             :            :       :            :        :            :
   1938          *                                             :            :       :            :        :            :
   1939          *                                             +------------+       +------------+        +------------+
   1940          *
   1941          *
   1942          * Arguments  : p_tcb    is a pointer to the OS_TCB to remove
   1943          *              -----
   1944          *
   1945          * Returns    : A pointer to the OS_RDY_LIST where the OS_TCB was
   1946          *
   1947          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   1948          ************************************************************************************************************************
   1949          */
   1950          

   \                                 In section .text, align 2, keep-with-next
   1951          void  OS_RdyListRemove (OS_TCB  *p_tcb)
   1952          {
   \                     OS_RdyListRemove: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1953              OS_RDY_LIST  *p_rdy_list;
   1954              OS_TCB       *p_tcb1;
   1955              OS_TCB       *p_tcb2;
   1956          
   1957          
   1958          
   1959              p_rdy_list = &OSRdyList[p_tcb->Prio];
   \   00000004   0x....             LDR.N    R0,??DataTable17_21
   \   00000006   0xF894 0x102F      LDRB     R1,[R4, #+47]
   \   0000000A   0xEB00 0x02C1      ADD      R2,R0,R1, LSL #+3
   1960              p_tcb1     = p_tcb->PrevPtr;                                /* Point to next and previous OS_TCB in the list        */
   \   0000000E   0x6921             LDR      R1,[R4, #+16]
   1961              p_tcb2     = p_tcb->NextPtr;
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   1962              if (p_tcb1 == (OS_TCB *)0) {                                /* Was the OS_TCB to remove at the head?                */
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD10E             BNE.N    ??OS_RdyListRemove_0
   1963                  if (p_tcb2 == (OS_TCB *)0) {                            /* Yes, was it the only OS_TCB?                         */
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD108             BNE.N    ??OS_RdyListRemove_1
   1964          #if (OS_CFG_DBG_EN > 0u)
   1965                      p_rdy_list->NbrEntries =           0u;              /* Yes, no more entries                                 */
   1966          #endif
   1967                      p_rdy_list->HeadPtr    = (OS_TCB *)0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x6010             STR      R0,[R2, #+0]
   1968                      p_rdy_list->TailPtr    = (OS_TCB *)0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6050             STR      R0,[R2, #+4]
   1969                      OS_PrioRemove(p_tcb->Prio);
   \   00000022   0xF894 0x002F      LDRB     R0,[R4, #+47]
   \   00000026   0x.... 0x....      BL       OS_PrioRemove
   \   0000002A   0xE009             B.N      ??OS_RdyListRemove_2
   1970                  } else {
   1971          #if (OS_CFG_DBG_EN > 0u)
   1972                      p_rdy_list->NbrEntries--;                           /* No,  one less entry                                  */
   1973          #endif
   1974                      p_tcb2->PrevPtr     = (OS_TCB *)0;                  /* adjust back link of new list head                    */
   \                     ??OS_RdyListRemove_1: (+1)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x6101             STR      R1,[R0, #+16]
   1975                      p_rdy_list->HeadPtr =  p_tcb2;                      /* adjust OS_RDY_LIST's new head                        */
   \   00000030   0x6010             STR      R0,[R2, #+0]
   \   00000032   0xE005             B.N      ??OS_RdyListRemove_2
   1976                  }
   1977              } else {
   1978          #if (OS_CFG_DBG_EN > 0u)
   1979                  p_rdy_list->NbrEntries--;                               /* No,  one less entry                                  */
   1980          #endif
   1981                  p_tcb1->NextPtr = p_tcb2;
   \                     ??OS_RdyListRemove_0: (+1)
   \   00000034   0x60C8             STR      R0,[R1, #+12]
   1982                  if (p_tcb2 == (OS_TCB *)0) {
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE.N    ??OS_RdyListRemove_3
   1983                      p_rdy_list->TailPtr = p_tcb1;                       /* Removing the TCB at the tail, adj the tail ptr       */
   \   0000003A   0x6051             STR      R1,[R2, #+4]
   \   0000003C   0xE000             B.N      ??OS_RdyListRemove_2
   1984                  } else {
   1985                      p_tcb2->PrevPtr     = p_tcb1;
   \                     ??OS_RdyListRemove_3: (+1)
   \   0000003E   0x6101             STR      R1,[R0, #+16]
   1986                  }
   1987              }
   1988              p_tcb->PrevPtr = (OS_TCB *)0;
   \                     ??OS_RdyListRemove_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6120             STR      R0,[R4, #+16]
   1989              p_tcb->NextPtr = (OS_TCB *)0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x60E0             STR      R0,[R4, #+12]
   1990          
   1991              OS_TRACE_TASK_SUSPENDED(p_tcb);
   1992          }
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
   1993          
   1994          
   1995          /*
   1996          ************************************************************************************************************************
   1997          *                                               SCHEDULER LOCK TIME MEASUREMENT
   1998          *
   1999          * Description: These functions are used to measure the peak amount of time that the scheduler is locked
   2000          *
   2001          * Arguments  : none
   2002          *
   2003          * Returns    : none
   2004          *
   2005          * Note(s)    : 1) The are internal functions to uC/OS-III and MUST not be called by your application code.
   2006          *
   2007          *              2) It's assumed that these functions are called when interrupts are disabled.
   2008          *
   2009          *              3) We are reading the time stamp timer via OS_TS_GET() directly even if this is a 16-bit timer.  The
   2010          *                 reason is that we don't expect to have the scheduler locked for 65536 counts even at the rate the TS
   2011          *                 timer is updated.  In other words, locking the scheduler for longer than 65536 count would not be a
   2012          *                 good thing for a real-time system.
   2013          ************************************************************************************************************************
   2014          */
   2015          
   2016          #if (OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u)
   2017          void  OS_SchedLockTimeMeasStart (void)
   2018          {
   2019              if (OSSchedLockNestingCtr == 1u) {
   2020                  OSSchedLockTimeBegin = OS_TS_GET();
   2021              }
   2022          }
   2023          
   2024          
   2025          
   2026          
   2027          void  OS_SchedLockTimeMeasStop (void)
   2028          {
   2029              CPU_TS_TMR  delta;
   2030          
   2031          
   2032              if (OSSchedLockNestingCtr == 0u) {                          /* Make sure we fully un-nested scheduler lock          */
   2033                  delta = OS_TS_GET()                                     /* Compute the delta time between begin and end         */
   2034                        - OSSchedLockTimeBegin;
   2035                  if (OSSchedLockTimeMax    < delta) {                    /* Detect peak value                                    */
   2036                      OSSchedLockTimeMax    = delta;
   2037                  }
   2038                  if (OSSchedLockTimeMaxCur < delta) {                    /* Detect peak value (for resettable value)             */
   2039                      OSSchedLockTimeMaxCur = delta;
   2040                  }
   2041              }
   2042          }
   2043          #endif
   2044          
   2045          
   2046          /*
   2047          ************************************************************************************************************************
   2048          *                                        RUN ROUND-ROBIN SCHEDULING ALGORITHM
   2049          *
   2050          * Description: This function is called on every tick to determine if a new task at the same priority needs to execute.
   2051          *
   2052          *
   2053          * Arguments  : p_rdy_list    is a pointer to the OS_RDY_LIST entry of the ready list at the current priority
   2054          *              ----------
   2055          *
   2056          * Returns    : none
   2057          *
   2058          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2059          ************************************************************************************************************************
   2060          */
   2061          
   2062          #if (OS_CFG_SCHED_ROUND_ROBIN_EN > 0u)

   \                                 In section .text, align 2, keep-with-next
   2063          void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
   2064          {
   \                     OS_SchedRoundRobin: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2065              OS_TCB  *p_tcb;
   2066              CPU_SR_ALLOC();
   \   00000004   0x2000             MOVS     R0,#+0
   2067          
   2068          
   2069              if (OSSchedRoundRobinEn != OS_TRUE) {                       /* Make sure round-robin has been enabled               */
   \   00000006   0x....             LDR.N    R0,??DataTable17_7
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD13E             BNE.N    ??OS_SchedRoundRobin_0
   2070                  return;
   2071              }
   2072          
   2073              CPU_CRITICAL_ENTER();
   \                     ??OS_SchedRoundRobin_1: (+1)
   \   0000000E   0x2040             MOVS     R0,#+64
   \   00000010   0x.... 0x....      BL       CPU_SR_Save
   \   00000014   0x0005             MOVS     R5,R0
   2074              p_tcb = p_rdy_list->HeadPtr;                                /* Decrement time quanta counter                        */
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   2075          
   2076              if (p_tcb == (OS_TCB *)0) {
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD103             BNE.N    ??OS_SchedRoundRobin_2
   2077                  CPU_CRITICAL_EXIT();
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       CPU_SR_Restore
   2078                  return;
   \   00000022   0xE033             B.N      ??OS_SchedRoundRobin_0
   2079              }
   2080          
   2081          #if (OS_CFG_TASK_IDLE_EN > 0u)
   2082              if (p_tcb == &OSIdleTaskTCB) {
   \                     ??OS_SchedRoundRobin_2: (+1)
   \   00000024   0x....             LDR.N    R0,??DataTable17_29
   \   00000026   0x4281             CMP      R1,R0
   \   00000028   0xD103             BNE.N    ??OS_SchedRoundRobin_3
   2083                  CPU_CRITICAL_EXIT();
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       CPU_SR_Restore
   2084                  return;
   \   00000030   0xE02C             B.N      ??OS_SchedRoundRobin_0
   2085              }
   2086          #endif
   2087          
   2088              if (p_tcb->TimeQuantaCtr > 0u) {
   \                     ??OS_SchedRoundRobin_3: (+1)
   \   00000032   0x6D08             LDR      R0,[R1, #+80]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD002             BEQ.N    ??OS_SchedRoundRobin_4
   2089                  p_tcb->TimeQuantaCtr--;
   \   00000038   0x6D08             LDR      R0,[R1, #+80]
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0x6508             STR      R0,[R1, #+80]
   2090              }
   2091          
   2092              if (p_tcb->TimeQuantaCtr > 0u) {                            /* Task not done with its time quanta                   */
   \                     ??OS_SchedRoundRobin_4: (+1)
   \   0000003E   0x6D08             LDR      R0,[R1, #+80]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD003             BEQ.N    ??OS_SchedRoundRobin_5
   2093                  CPU_CRITICAL_EXIT();
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
   2094                  return;
   \   0000004A   0xE01F             B.N      ??OS_SchedRoundRobin_0
   2095              }
   2096          
   2097              if (p_rdy_list->HeadPtr == p_rdy_list->TailPtr) {           /* See if it's time to time slice current task          */
   \                     ??OS_SchedRoundRobin_5: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x6861             LDR      R1,[R4, #+4]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD103             BNE.N    ??OS_SchedRoundRobin_6
   2098                  CPU_CRITICAL_EXIT();                                    /* ... only if multiple tasks at same priority          */
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       CPU_SR_Restore
   2099                  return;
   \   0000005A   0xE017             B.N      ??OS_SchedRoundRobin_0
   2100              }
   2101          
   2102              if (OSSchedLockNestingCtr > 0u) {                           /* Can't round-robin if the scheduler is locked         */
   \                     ??OS_SchedRoundRobin_6: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable17_2
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ.N    ??OS_SchedRoundRobin_7
   2103                  CPU_CRITICAL_EXIT();
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
   2104                  return;
   \   0000006A   0xE00F             B.N      ??OS_SchedRoundRobin_0
   2105              }
   2106          
   2107              OS_RdyListMoveHeadToTail(p_rdy_list);                       /* Move current OS_TCB to the end of the list           */
   \                     ??OS_SchedRoundRobin_7: (+1)
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       OS_RdyListMoveHeadToTail
   2108              p_tcb = p_rdy_list->HeadPtr;                                /* Point to new OS_TCB at head of the list              */
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   2109              if (p_tcb->TimeQuanta == 0u) {                              /* See if we need to use the default time slice         */
   \   00000074   0x6CC8             LDR      R0,[R1, #+76]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD103             BNE.N    ??OS_SchedRoundRobin_8
   2110                  p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
   \   0000007A   0x....             LDR.N    R0,??DataTable17_9
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x6508             STR      R0,[R1, #+80]
   \   00000080   0xE001             B.N      ??OS_SchedRoundRobin_9
   2111              } else {
   2112                  p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;               /* Load time slice counter with new time                */
   \                     ??OS_SchedRoundRobin_8: (+1)
   \   00000082   0x6CC8             LDR      R0,[R1, #+76]
   \   00000084   0x6508             STR      R0,[R1, #+80]
   2113              }
   2114              CPU_CRITICAL_EXIT();
   \                     ??OS_SchedRoundRobin_9: (+1)
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0x.... 0x....      BL       CPU_SR_Restore
   2115          }
   \                     ??OS_SchedRoundRobin_0: (+1)
   \   0000008C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2116          #endif
   2117          
   2118          
   2119          /*
   2120          ************************************************************************************************************************
   2121          *                                                     BLOCK A TASK
   2122          *
   2123          * Description: This function is called to remove a task from the ready list and also insert it in the timer tick list if
   2124          *              the specified timeout is non-zero.
   2125          *
   2126          * Arguments  : p_tcb          is a pointer to the OS_TCB of the task block
   2127          *              -----
   2128          *
   2129          *              timeout        is the desired timeout
   2130          *
   2131          * Returns    : none
   2132          *
   2133          * Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
   2134          ************************************************************************************************************************
   2135          */
   2136          

   \                                 In section .text, align 2, keep-with-next
   2137          void  OS_TaskBlock (OS_TCB   *p_tcb,
   2138                              OS_TICK   timeout)
   2139          {
   \                     OS_TaskBlock: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000B             MOVS     R3,R1
   2140          #if (OS_CFG_DYN_TICK_EN > 0u)
   2141              OS_TICK  elapsed;
   2142          
   2143          
   2144              elapsed = OS_DynTickGet();
   2145          #endif
   2146          
   2147          #if (OS_CFG_TICK_EN > 0u)
   2148              if (timeout > 0u) {                                         /* Add task to tick list if timeout non zero            */
   \   00000006   0x2B00             CMP      R3,#+0
   \   00000008   0xD009             BEQ.N    ??OS_TaskBlock_0
   2149          #if (OS_CFG_DYN_TICK_EN > 0u)
   2150                  (void)OS_TickListInsert(p_tcb, elapsed, (OSTickCtr + elapsed), timeout);
   2151          #else
   2152                  (void)OS_TickListInsert(p_tcb,      0u,             OSTickCtr, timeout);
   \   0000000A   0x....             LDR.N    R0,??DataTable17_30
   \   0000000C   0x6802             LDR      R2,[R0, #+0]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       OS_TickListInsert
   2153          #endif
   2154                  p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xF884 0x002E      STRB     R0,[R4, #+46]
   \   0000001C   0xE002             B.N      ??OS_TaskBlock_1
   2155              } else {
   2156                  p_tcb->TaskState = OS_TASK_STATE_PEND;
   \                     ??OS_TaskBlock_0: (+1)
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xF884 0x002E      STRB     R0,[R4, #+46]
   2157              }
   2158          #else
   2159              (void)timeout;
   2160              p_tcb->TaskState = OS_TASK_STATE_PEND;
   2161          #endif
   2162              OS_RdyListRemove(p_tcb);
   \                     ??OS_TaskBlock_1: (+1)
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       OS_RdyListRemove
   2163          }
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     OSIntNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     OSRunning

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     OSTCBCurPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     OSTCBHighRdyPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     OSPrioCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     OSPrioHighRdy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     OSSchedRoundRobinEn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     OSCfg_TickRate_Hz

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     OSSchedRoundRobinDfltTimeQuanta

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     OSCfg_ISRStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     OSCfg_ISRStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     OS_AppTaskCreateHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     OS_AppTaskDelHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     OS_AppTaskReturnHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x........         DC32     OS_AppIdleTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x........         DC32     OS_AppStatTaskHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     OS_AppTaskSwHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     OS_AppTimeTickHookPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x........         DC32     OSTaskRegNextAvailID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x........         DC32     OSInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     OSRdyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x........         DC32     OSTaskCtxSwCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     OSTaskQty

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     OSStatTaskCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkLimit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x........         DC32     OSCfg_IdleTaskStkBasePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0x........         DC32     OS_IdleTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     OSIdleTaskTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \   00000000   0x........         DC32     OSTickCtr

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   OSInit
         8   -> OSCfg_Init
         8   -> OSInitHook
         8   -> OS_IdleTaskInit
         8   -> OS_MemInit
         8   -> OS_MsgPoolInit
         8   -> OS_PrioInit
         8   -> OS_RdyListInit
         8   -> OS_StatTaskInit
         8   -> OS_TaskInit
         8   -> OS_TickInit
         8   -> OS_TmrInit
       0   OSIntEnter
       8   OSIntExit
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIntCtxSw
         8   -> OS_PrioGetHighest
       8   OSSched
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSCtxSw
         8   -> OS_PrioGetHighest
       8   OSSchedLock
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
      16   OSSchedRoundRobinCfg
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   OSSchedRoundRobinYield
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OSSched
        16   -> OS_RdyListMoveHeadToTail
       8   OSSchedUnlock
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSSched
       8   OSStart
         8   -> OSStartHighRdy
         8   -> OS_PrioGetHighest
       0   OSVersion
       8   OS_IdleTask
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
         8   -> OSIdleTaskHook
      40   OS_IdleTaskInit
        40   -> OSTaskCreate
      16   OS_Pend
        16   -> OS_PendListInsertPrio
        16   -> OS_TaskBlock
      16   OS_PendAbort
        16   -> OS_PendListRemove
        16   -> OS_RdyListInsert
        16   -> OS_TickListRemove
      16   OS_PendListChangePrio
        16   -> OS_PendListInsertPrio
        16   -> OS_PendListRemove
       0   OS_PendListInit
       8   OS_PendListInsertPrio
       0   OS_PendListRemove
       8   OS_Post
         8   -> OS_PendListRemove
         8   -> OS_RdyListInsert
         8   -> OS_TickListRemove
       0   OS_RdyListInit
       8   OS_RdyListInsert
         8   -> OS_PrioInsert
         8   -> OS_RdyListInsertHead
         8   -> OS_RdyListInsertTail
       0   OS_RdyListInsertHead
       0   OS_RdyListInsertTail
       4   OS_RdyListMoveHeadToTail
       8   OS_RdyListRemove
         8   -> OS_PrioRemove
      16   OS_SchedRoundRobin
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> OS_RdyListMoveHeadToTail
       8   OS_TaskBlock
         8   -> OS_RdyListRemove
         8   -> OS_TickListInsert


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
     290  OSInit
      36  OSIntEnter
     192  OSIntExit
     148  OSSched
      90  OSSchedLock
      80  OSSchedRoundRobinCfg
     148  OSSchedRoundRobinYield
     116  OSSchedUnlock
     142  OSStart
      10  OSVersion
      34  OS_IdleTask
      70  OS_IdleTaskInit
      46  OS_Pend
     128  OS_PendAbort
      34  OS_PendListChangePrio
      10  OS_PendListInit
     104  OS_PendListInsertPrio
      82  OS_PendListRemove
     146  OS_Post
      26  OS_RdyListInit
      40  OS_RdyListInsert
      46  OS_RdyListInsertHead
      44  OS_RdyListInsertTail
      68  OS_RdyListMoveHeadToTail
      74  OS_RdyListRemove
     142  OS_SchedRoundRobin
      44  OS_TaskBlock

 
 2 514 bytes in section .text
 
 2 514 bytes of CODE memory

Errors: none
Warnings: none
